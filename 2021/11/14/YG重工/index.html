<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="YG重工"><meta name="keywords" content="shujujiegou"><meta name="author" content="YaoGui"><meta name="copyright" content="YaoGui"><title>YG重工 | YAOGUI</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#YG%E9%87%8D%E5%B7%A5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">YG重工-数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-0-%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.0 认识数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 数据结构的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 数据的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%94%E2%80%93%E4%BB%A5%E4%B8%8B%E4%B8%BA%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">—–以下为逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1 集合结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2 线性结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">3. 树形结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">4. 图形结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%94%E2%80%93%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">—–物理结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">1. 顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">2.链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 数据的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 抽象数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2. 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">2.1 时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%A9%BA%E9%97%B4%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2.2 空间算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3. 线性表-顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 创建一个顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 顺序表的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%A4%E6%96%AD%E5%92%8C%E6%B8%85%E7%A9%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 顺序表的判断和清空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 顺序表元素的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 顺序表元素获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 顺序表元素插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 顺序表元素的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.8.</span> <span class="toc-text">3.8 顺序表全部代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4.线性表-链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%A4%B4%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 头指针和头节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2单链表的读取</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210618/touxiang.38cvdo15qh40.jpg"></div><div class="author-info__name text-center">YaoGui</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210620/wallhaven-mpmok9.40nviwlii5q0.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">YAOGUI</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">标签页</a><a class="site-page" href="/categories">文章类别</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">YG重工</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-14</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="YG重工-数据结构"><a href="#YG重工-数据结构" class="headerlink" title="YG重工-数据结构"></a>YG重工-数据结构</h1><p>此文中的所有个人理解可不看,很多时候只是愚笨而想,并不具备价值.</p>
<h2 id="1-0-认识数据结构"><a href="#1-0-认识数据结构" class="headerlink" title="1.0 认识数据结构"></a>1.0 认识数据结构</h2><h3 id="1-1-数据结构的介绍"><a href="#1-1-数据结构的介绍" class="headerlink" title="1.1 数据结构的介绍"></a>1.1 数据结构的介绍</h3><p>我们都知道的是 **程序 = 数据结构 + 算法 ** ;</p>
<p>首先正如我所想,数据结构说白了就是描述不同数据之间的关系.<br>我们把最常见的八种关系抽象出来,以供同学学习来扩充我们编程解决问题的思路.</p>
<p>也就是说数据结构是不止八种的,你如果有能力你自己也可以设计数据结构.</p>
<p>个人理解</p>
<blockquote>
<p>仔细想想,</p>
<p>离散的数据结构关系(集合)<br>单一连续的指向性结构关系(数组&gt;&gt;线性结构)<br>将数据抽象成节点 如同一个一个小钩子一样自由的对勾(指针指向),可以构成各种各样的结构关系,因为一个节点在树中我们能够知道它可以指向很多节点.</p>
<p>在我目前所学的有限的知识中觉得没有了,可能是我还没接触到除开八种常见的数据结构之外的数据结构吧.</p>
</blockquote>
<blockquote>
<p>以数据结构是一 门研究非数值计算的程序设计问题中的操作对象，以及官们之间的关系和操作等相关 问题的学科。  – (大话数据结构)</p>
<p><strong>数据结梅: 是相互之间存在一种或多种特定关系的数据元素的集合.</strong></p>
</blockquote>
<p>以下我先介绍几个关于数据的概念</p>
<p><strong>数据</strong></p>
<p>我们看看数据结构中对于数据的描述</p>
<p>数据是描述客观事物的符号,是计算机中可以操作的对象,是能够被计算机识别,并输入给计算机处理的符号集合.</p>
<ul>
<li>可以被输入到计算机中</li>
<li>能被计算机程序处理</li>
</ul>
<p>从根源上说数据不就是一堆的0和1组成的一串一串的数字吗,换句话说难道不是只要现在一种符号能够转化成计算机的0,1那么这个符号不就是数据了码.</p>
<p><strong><em>1. 数据项</em></strong></p>
<p>数据项组成数据元素 。</p>
<p><strong>数据项不是一种固定的测量单位之类的</strong></p>
<p>数据项就是最小的单位，但是这个最小的单位是抽象出来的最小的单位。</p>
<p><strong><em>2.数据元素</em></strong></p>
<p>数据元素:<br>是组成数据的有定意义的基本单位，在计算机中通常作为整体处理,也被称为记录。</p>
<p><strong><em>3. 数据对象</em></strong></p>
<p>**数据对象 **都是简称为 <strong>数据</strong></p>
<p>数据对象: 是性质相同的<strong>数据元素</strong>的集合，是数据的子集</p>
<p><img src="https://arcane-yaogui.oss-cn-beijing.aliyuncs.com/PHOTOS/image-20211105200024124.png" alt="image-20211105200024124"></p>
<p>我们看上面的概念可能不能够很好的理解,但是我在网上看到别人这样理解,挺有意思.</p>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">专业</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小明</td>
<td align="center">男</td>
<td align="center">计算机</td>
</tr>
<tr>
<td align="center">小红</td>
<td align="center">女</td>
<td align="center">商务英语</td>
</tr>
<tr>
<td align="center">小王</td>
<td align="center">男</td>
<td align="center">挑大粪</td>
</tr>
</tbody></table>
<p>以上是一个表格</p>
<blockquote>
<p>数据项是不可分割的最小单位.</p>
</blockquote>
<p>每一个单独的表格就是不可分割的数据项,这个我们可以很好理解.</p>
<blockquote>
<p>数据元素（data element）：<br>由若干个数据项组成的数据基本单元，也称结点，元素，顶点或记录</p>
</blockquote>
<p>每一行的若干个数据项正好是组成一个学生,每一行就表示数据元素.</p>
<blockquote>
<p>数据对象（data object）：<br>由<strong>性质相同的数据元素</strong>组成的集合，是数据的一个子集。<br>比如，整数的数据对象{-3, -2, -1, 0, 1, 2, 3}</p>
</blockquote>
<p>性质相同,那么我们是不是就能够知道这这么一整张表就是数据对象.<br>因为每一行都是相同性质的数据元素啊</p>
<p>最后多张不同的表存在计算机中,我们就称之为<strong>数据</strong>.</p>
<p>呀,这么一理解是不是就对这些文字概念感觉不是那么模模糊糊似懂非懂了</p>
<h3 id="1-2-数据的结构"><a href="#1-2-数据的结构" class="headerlink" title="1.2 数据的结构"></a>1.2 数据的结构</h3><h4 id="—–以下为逻辑结构"><a href="#—–以下为逻辑结构" class="headerlink" title="—–以下为逻辑结构"></a>—–以下为逻辑结构</h4><h4 id="1-集合结构"><a href="#1-集合结构" class="headerlink" title="1 集合结构"></a>1 集合结构</h4><p>就是在一个数据中每个数据元素同属于一个集合外,他们彼此并没有关系.</p>
<h4 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2 线性结构"></a>2 线性结构</h4><p>数据元素之间是处于一对一的关系.</p>
<h4 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3. 树形结构"></a>3. 树形结构</h4><p>这就是所谓的一对多的层次关系</p>
<h4 id="4-图形结构"><a href="#4-图形结构" class="headerlink" title="4. 图形结构"></a>4. 图形结构</h4><p>图形结构的数据元素就是多对多的关系.</p>
<h4 id="—–物理结构"><a href="#—–物理结构" class="headerlink" title="—–物理结构"></a>—–物理结构</h4><h4 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1. 顺序存储"></a>1. 顺序存储</h4><p>我们这里可以理解成数组一样的存储方式.<br>这样存储方式的逻辑关系和物理关系是一致的.</p>
<h4 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2.链式存储"></a>2.链式存储</h4><p>使用指针进行指向下一个数据元素的底子,所以说物理层面上他们可以连续也可以不连续.</p>
<h3 id="1-3-数据的类型"><a href="#1-3-数据的类型" class="headerlink" title="1.3 数据的类型"></a>1.3 数据的类型</h3><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><p>数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<p>比如我们的 <code>int </code>  <code>float</code> 等等确定好的一类的性质相同的值.</p>
<p>比如在C语言中,数据类型可以分为两类:</p>
<ul>
<li>原子类型: 不可再分解的基本类型,包括整型,实型,字符型.</li>
<li>结构类型: 若干个类型组合而成,可以再分解.<ul>
<li>整型的数组就是由若干个整型数据组成.</li>
</ul>
</li>
</ul>
<h4 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2. 抽象数据类型"></a>2. 抽象数据类型</h4><p>抽象数据类型 (Abstract Dataη ADT ): 是指一个数学模型及定义该模型上的一组操作。</p>
<p>emm…<br>我觉得有点复杂就用我自己的理解讲一讲</p>
<p>在C语言中的结构体 struct类型<br>在JavaScript中的对象<br>在Java和C++语言中的类 等等都是这种抽象数据类型.</p>
<p>像那种的多种的类型的组合,并且像C语言中我们自己定位类型的<br>可以理解成首次按数据类型.</p>
<p>放一个博客的一段话,引用以下:</p>
<blockquote>
<p>抽象数据类型和数据类型在实质上是一个概念，只不过是对数据类型的进一步抽象，不仅限于各种不同的计算机处理器中已经实现的数据类型，还包括为解决更为复杂的问题而由用户自定义的复杂数据类型。</p>
<p>例如，在统计学生信息时，经常使用姓名、学号、成绩等信息，我们可以定义这样的一个抽象数据类型student,它封装了姓名、学号、成绩三个不同类型的变量，这样操作student的变量就能够很方便的知道这些信息了。<br>————————————————<br>版权声明：本文为CSDN博主「新海说」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Gnewocean/article/details/82388462">https://blog.csdn.net/Gnewocean/article/details/82388462</a></p>
</blockquote>
<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><blockquote>
<p>算法是解决特定问题求解步的描述，在计算机中表现为指令的有限序列，并且 每条指令表示一个或多个操作.</p>
</blockquote>
<p>one. 算法一定是具有以下五个特性</p>
<ol>
<li>输入</li>
<li>输出</li>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
</ol>
<p>two. 算法的要求</p>
<ul>
<li>正确性<ul>
<li>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、 能正确反映问题的需求、能够得到问题的正确答案</li>
</ul>
</li>
<li>可读性<ul>
<li>便于阅读,理解和交流.</li>
</ul>
</li>
<li>健壮性<ul>
<li>当输入数据不合法能够做出相关处理.</li>
</ul>
</li>
<li>时间效率高和存储量低<ul>
<li>时间效率 – 对于同一个问题,执行时间越短时间效率越高</li>
<li>存储量低 – 在运行的时候占用的内存和磁盘的存储空间少</li>
</ul>
</li>
</ul>
<h4 id="2-1-时间复杂度"><a href="#2-1-时间复杂度" class="headerlink" title="2.1 时间复杂度"></a>2.1 时间复杂度</h4><p>推到大O阶方法</p>
<ul>
<li>用参数 1 取代运行时间中所有的加法常数.</li>
<li>再修改后的运行次数函数中,只保留最高阶项.</li>
<li>如果高阶项存在且不是 1 ,则去除这个项相乘的参数.</li>
</ul>
<p>比如见如下代码:</p>
<p>我们比较熟悉的从1加到100</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j,x =<span class="number">0</span>,sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        x++;</span><br><span class="line">        sum = sum + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br></pre></td></tr></table></figure>



<p>以下为高斯算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , n = <span class="number">100</span>;</span><br><span class="line">sum = (<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br></pre></td></tr></table></figure>



<p>这两个计算同样的问题,高斯算法的时间复杂程度比上方的算法好多了.</p>
<p>可见解决问题的时候一个巧妙的算法能起到多大的帮助.</p>
<p><em>常数阶</em></p>
<ol>
<li><strong>首先我们说个简单的就是O(n)这个n如果是常数,不管是多大,都最后记作O(1);</strong></li>
</ol>
<p><em>线性阶</em></p>
<p>见如下代码,一个循环我们可以看作一个O(n)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j;    </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123; &#125;</span><br></pre></td></tr></table></figure>



<p><em>对数阶</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt; n)&#123;</span><br><span class="line">    count = count * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你会发现上面代码最后执行完成并没有执行n次,最后假设执行了x次<br>那么 2<sup>X</sup> = n , 那么  x = log<sub>2</sub>n , 所以这个时间复杂程度为O(n)</p>
<p><em>平方阶</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j,x =<span class="number">0</span>,sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        x++;</span><br><span class="line">        sum = sum + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>平方阶就像上面那样O(n<sup>2</sup>),循环套循环<br>那么同样你也知道了O(n<sup>3</sup>)也就是三个循环相嵌了.</p>
<p>好,那是因为两个循环的条件都是n,所以是n*n</p>
<p>如果像下面代码那样,那么时间复杂成都就是O(n*m)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>带有函数的时间复杂度</em></p>
<p>如果带有方法的算法,函数本身就看作O(1)<br>所以下面代码就是O(n)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果函数里面有循环呢?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">// balabal...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们这个先算这个函数是O(n) ,然后外面还有一个循环,那么就是O(n<sup>2</sup>)</p>
<p>比如我们见如下图:</p>
<p><img src="https://arcane-yaogui.oss-cn-beijing.aliyuncs.com/PHOTOS/image-20211105221416382.png" alt="image-20211105221416382"></p>
<h4 id="2-2-空间算法"><a href="#2-2-空间算法" class="headerlink" title="2.2 空间算法"></a>2.2 空间算法</h4><p>空间算法就是利用空间上的一点开销,来换取程序行起来的速度.<br>简单来说就是用空间来换取时间.</p>
<p>书中这个提及不多,但是相比起时间复杂度来说不是很重要.</p>
<h2 id="3-线性表-顺序表"><a href="#3-线性表-顺序表" class="headerlink" title="3. 线性表-顺序表"></a>3. 线性表-顺序表</h2><p>线性表的定义</p>
<blockquote>
<p>零个或者多个数据源函数的有限序列.</p>
</blockquote>
<p>一个元素节点中,它前面的叫<strong>前驱</strong>,后面的叫<strong>后继</strong>.</p>
<p>我们的顺序表需要实现以下几个函数功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个线性表</span></span><br><span class="line"><span class="function">ElemType <span class="title">initializeList</span><span class="params">(SqList *L)</span></span>;</span><br><span class="line"><span class="comment">// 清空一个线性表</span></span><br><span class="line"><span class="function">ElemType <span class="title">ClearList</span><span class="params">(SqList *L)</span></span>;</span><br><span class="line"><span class="comment">// 判断一个线性表是否为空</span></span><br><span class="line"><span class="function">ElemType <span class="title">IsEmpty</span><span class="params">(SqList *L)</span></span>;</span><br><span class="line"><span class="comment">// 查找一个元素,有则返回下标,没有则返回 0</span></span><br><span class="line"><span class="function">ElemType <span class="title">LocateElem</span><span class="params">(SqList *L, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">// 获取线性表一个元素并返回给 e</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span>;</span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function">ElemType <span class="title">InsertElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function">ElemType <span class="title">DeleteElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span>;</span><br></pre></td></tr></table></figure>





<h3 id="3-1-创建一个顺序表"><a href="#3-1-创建一个顺序表" class="headerlink" title="3.1 创建一个顺序表"></a>3.1 创建一个顺序表</h3><p>概念巨几把好懂,话不多说实现代码(<del>don’t BB show me code</del>)</p>
<p>首先我们在结构体中定义一个数组来实现线性表的连续存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initialize_size 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElemType *data;</span><br><span class="line">   <span class="keyword">int</span> max_size;</span><br><span class="line">   <span class="keyword">int</span> lenght;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>



<p>这里我们得区分一个数组长度和线性表长度,lenght在我们后续每一步添加和删除元素得时候都会随之改变,而这个数组长度是最大长度.</p>
<p>当然我们也可以使动态数组来创建数组,但是先从简单做起.</p>
<h3 id="3-2-顺序表的初始化"><a href="#3-2-顺序表的初始化" class="headerlink" title="3.2 顺序表的初始化"></a>3.2 顺序表的初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">initializeList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   L-&gt;data = (ElemType *)<span class="built_in">malloc</span>(initialize_size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">   <span class="keyword">if</span> ((*L).data == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(ERROR);</span><br><span class="line">   &#125;</span><br><span class="line">   L-&gt;lenght = <span class="number">0</span>;</span><br><span class="line">   L-&gt;max_size = initialize_size;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;线性表----初始化成功-----\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-顺序表的判断和清空"><a href="#3-3-顺序表的判断和清空" class="headerlink" title="3.3 顺序表的判断和清空"></a>3.3 顺序表的判断和清空</h3><p>这里我们判断线性表是否为空,和但线性表不为空时的清空操作.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">ClearList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!L-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   L-&gt;lenght = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">IsEmpty</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (L-&gt;lenght == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n线性表是空&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n线性表不为空&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-顺序表元素的查找"><a href="#3-4-顺序表元素的查找" class="headerlink" title="3.4 顺序表元素的查找"></a>3.4 顺序表元素的查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找一个元素,有则返回下标,没有则返回 0</span></span><br><span class="line"><span class="function">ElemType <span class="title">LocateElem</span><span class="params">(SqList *L, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">LocateElem</span><span class="params">(SqList *L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!L-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; L-&gt;lenght; h++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (L-&gt;data[h] == e)</span><br><span class="line">         <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-5-顺序表元素获取"><a href="#3-5-顺序表元素获取" class="headerlink" title="3.5 顺序表元素获取"></a>3.5 顺序表元素获取</h3><p>这里我提一嘴基础知识</p>
<p>下面这种静态初始化数组,可行.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>]= &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>但是下面这种就不可行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>因为定义好数组之后,arr[]就表示这个数组的地址<br>你怎么将这么大坨赋值给一个指针.</p>
<p><strong>所以在结构体中定义了数组后期需要循环来赋值</strong></p>
<p>回归正题,我们获取线性表中的元素代码如下:</p>
<ul>
<li>首先判断是否为空</li>
<li>下标 i 是否符合条件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将线性表中的第i位置的元素值返回给e</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;lenght || L-&gt;lenght == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-6-顺序表元素插入"><a href="#3-6-顺序表元素插入" class="headerlink" title="3.6 顺序表元素插入"></a>3.6 顺序表元素插入</h3><p>我们需要在意的三个点</p>
<ul>
<li>下标如果输入错误抛出异常</li>
<li>将所有元素后移一位插入元素</li>
<li>表长 +1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性表中插入元素</span></span><br><span class="line"><span class="function">ElemType <span class="title">ListInsert</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">InsertElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;lenght + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= L-&gt;lenght)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> h = L-&gt;lenght; h &gt;= i; h--)</span><br><span class="line">         L-&gt;data[h] = L-&gt;data[h - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   L-&gt;data[i - <span class="number">1</span>] = e;</span><br><span class="line">   L-&gt;lenght++;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-顺序表元素的删除"><a href="#3-7-顺序表元素的删除" class="headerlink" title="3.7 顺序表元素的删除"></a>3.7 顺序表元素的删除</h3><ul>
<li>注意下标问题</li>
<li>表长减一</li>
<li>在删除前赋值给第三变量,然后返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第i位置的值,并返回其值.</span></span><br><span class="line"><span class="function">ElemType <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">DeleteElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;lenght)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> h = i; h &lt;= L-&gt;lenght; h++)</span><br><span class="line">      L-&gt;data[h - <span class="number">1</span>] = L-&gt;data[h];</span><br><span class="line">   L-&gt;lenght--;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-顺序表全部代码"><a href="#3-8-顺序表全部代码" class="headerlink" title="3.8 顺序表全部代码"></a>3.8 顺序表全部代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initialize_size 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElemType *data;</span><br><span class="line">   <span class="keyword">int</span> max_size;</span><br><span class="line">   <span class="keyword">int</span> lenght;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个线性表</span></span><br><span class="line"><span class="function">ElemType <span class="title">initializeList</span><span class="params">(SqList *L)</span></span>;</span><br><span class="line"><span class="comment">// 清空一个线性表</span></span><br><span class="line"><span class="function">ElemType <span class="title">ClearList</span><span class="params">(SqList *L)</span></span>;</span><br><span class="line"><span class="comment">// 判断一个线性表是否为空</span></span><br><span class="line"><span class="function">ElemType <span class="title">IsEmpty</span><span class="params">(SqList *L)</span></span>;</span><br><span class="line"><span class="comment">// 查找一个元素,有则返回下标,没有则返回 0</span></span><br><span class="line"><span class="function">ElemType <span class="title">LocateElem</span><span class="params">(SqList *L, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">// 获取线性表一个元素并返回给 e</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span>;</span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function">ElemType <span class="title">InsertElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function">ElemType <span class="title">DeleteElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; L-&gt;lenght; h++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, L-&gt;data[h]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   SqList L;</span><br><span class="line">   <span class="comment">// 初始化线性表</span></span><br><span class="line">   initializeList(&amp;L);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 往顺序表中放数据</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">10</span>; h++)</span><br><span class="line">   &#123;</span><br><span class="line">      L.data[h] = h;</span><br><span class="line">      L.lenght++;</span><br><span class="line">   &#125;</span><br><span class="line">   print(&amp;L);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断是否为空</span></span><br><span class="line">   IsEmpty(&amp;L);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查找元素</span></span><br><span class="line">   <span class="keyword">int</span> Found_e = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line">   result = LocateElem(&amp;L, Found_e);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 插入元素</span></span><br><span class="line">   <span class="keyword">int</span> insert_e = <span class="number">100</span>;</span><br><span class="line">   InsertElem(&amp;L, Found_e, insert_e);</span><br><span class="line">   print(&amp;L);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除元素</span></span><br><span class="line">   <span class="keyword">int</span> delete_e = <span class="number">0</span>;</span><br><span class="line">   ElemType *back_e = &amp;delete_e;</span><br><span class="line">   DeleteElem(&amp;L, Found_e, back_e);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, delete_e);</span><br><span class="line">   print(&amp;L);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//清空线性表再判断</span></span><br><span class="line">   ClearList(&amp;L);</span><br><span class="line">   IsEmpty(&amp;L);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">initializeList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   L-&gt;data = (ElemType *)<span class="built_in">malloc</span>(initialize_size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">   <span class="keyword">if</span> ((*L).data == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(ERROR);</span><br><span class="line">   &#125;</span><br><span class="line">   L-&gt;lenght = <span class="number">0</span>;</span><br><span class="line">   L-&gt;max_size = initialize_size;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;线性表----初始化成功-----\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">ClearList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!L-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   L-&gt;lenght = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">IsEmpty</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (L-&gt;lenght == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n线性表是空&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n线性表不为空&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">LocateElem</span><span class="params">(SqList *L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!L-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; L-&gt;lenght; h++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (L-&gt;data[h] == e)</span><br><span class="line">         <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;lenght || L-&gt;lenght == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">InsertElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;lenght + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   <span class="keyword">if</span> (i &lt;= L-&gt;lenght)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> h = L-&gt;lenght; h &gt;= i; h--)</span><br><span class="line">         L-&gt;data[h] = L-&gt;data[h - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   L-&gt;data[i - <span class="number">1</span>] = e;</span><br><span class="line">   L-&gt;lenght++;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">DeleteElem</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;lenght)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> h = i; h &lt;= L-&gt;lenght; h++)</span><br><span class="line">      L-&gt;data[h - <span class="number">1</span>] = L-&gt;data[h];</span><br><span class="line">   L-&gt;lenght--;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后执行的结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线性表----初始化成功-----</span><br><span class="line">0  1  2  3  4  5  6  7  8  9       </span><br><span class="line">线性表不为空</span><br><span class="line">5</span><br><span class="line">0  1  2  3  100  4  5  6  7  8  9  </span><br><span class="line">100</span><br><span class="line">0  1  2  3  4  5  6  7  8  9       </span><br><span class="line">线性表是空</span><br></pre></td></tr></table></figure>





<p>OK! 至此线性表中的顺序表就先告一段落.</p>
<h2 id="4-线性表-链表"><a href="#4-线性表-链表" class="headerlink" title="4.线性表-链表"></a>4.线性表-链表</h2><p>顺序表有一个比较不好的就是需要自己分配大小.</p>
<p>哪怕使用动态分配内存,总归觉得不够自由(<del>艾伦 耶格尔</del>)</p>
<p>而且每一次的插入和删除的操作都时需要移动元素灰常的不方便啊</p>
<p>这个时候我们介绍介绍我们的链表</p>
<p>算了  , 不想介绍了,反正就是弥补顺序表的不足…..</p>
<h3 id="4-1-头指针和头节点"><a href="#4-1-头指针和头节点" class="headerlink" title="4.1 头指针和头节点"></a>4.1 头指针和头节点</h3><table>
<thead>
<tr>
<th align="left">头指针</th>
<th align="left">头节点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">头指针是指向链表的第一个结点的指针，若链表有头结点，则是指向头结点的指针</td>
<td align="left">头结点是为了操作和统一的方便而设立的，放在第一元素的节点之前,它的数据域一般无意义,但也可以用来存放链表长度之类的数据,可空可不空,无所谓.</td>
</tr>
<tr>
<td align="left">头指针具有标识作用,所以常常把头指针命名为链表的名字.</td>
<td align="left">因为有了头节点,对第一个元素的删除和插入等操作就能够和其他元素节点统一</td>
</tr>
<tr>
<td align="left">无论链表是否为空,头指针都不能为空,头指针时链表的必要元素.</td>
<td align="left">头节点不是链表必要的元素.</td>
</tr>
</tbody></table>
<h3 id="4-2单链表的读取"><a href="#4-2单链表的读取" class="headerlink" title="4.2单链表的读取"></a>4.2单链表的读取</h3><p>链表比较有意思,读取元素之前不需要判断长度.</p>
<p>建立一个变量作为计数器,如果这个变量没超过传过来的下标,就第 i 元素不存在.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YaoGui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/14/YG重工/">http://example.com/2021/11/14/YG重工/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">YAOGUI</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/shujujiegou/">shujujiegou</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/08/29/JavaScript%E7%AC%94%E8%AE%B0/"><span>JavaScript笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210620/wallhaven-mpmok9.40nviwlii5q0.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By YaoGui</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>