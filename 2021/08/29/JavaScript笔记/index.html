<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript笔记"><meta name="keywords" content="JavaScript"><meta name="author" content="YaoGui"><meta name="copyright" content="YaoGui"><title>JavaScript笔记 | YAOGUI</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">JavaScript简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E5%86%99%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">注释写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">a.语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">b.变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">let变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#let%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B8%8D%E6%8F%90%E5%8D%87"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">let声明变量不提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#let%E6%90%AD%E9%85%8Dfor%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">let搭配for实现遍历的好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">var声明变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">const声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">标识符命名规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%8C%BA%E5%9D%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">c.区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-%E6%A0%87%E7%AD%BE-%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.1.5.</span> <span class="toc-text">d.标签(跳转)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1. 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%A1%AE%E5%AE%9A%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1  确定值的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-typeof"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1.1 typeof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-null-and-undefined"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 null and undefined</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AFundefined"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">什么时候是undefined</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.3 布尔值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.3.1 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8C%96false"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">1.3.2 [自动转化false]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B4%E6%95%B0%E5%92%8C%E5%B0%8F%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.4 整数和小数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E6%95%B0%E5%80%BC%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.4.1 数值精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">1.4.2 数值范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">1.4.3 数值表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">1.4.4 特殊值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E8%B4%9F-0"><span class="toc-number">1.2.4.4.1.</span> <span class="toc-text">正负 0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NaN"><span class="toc-number">1.2.4.4.2.</span> <span class="toc-text">NaN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Infinity-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">1.2.4.4.3.</span> <span class="toc-text">Infinity 【重点】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-parselnt%EF%BC%88%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.5  parselnt（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-parseFloat"><span class="toc-number">1.2.6.</span> <span class="toc-text">1.6 parseFloat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-isNaN"><span class="toc-number">1.2.7.</span> <span class="toc-text">1.7 isNaN()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-Symbol%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">1.8 Symbol类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-symbol%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">a.symbol简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-symbol-for"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">b.symbol.for()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-Symbol-keyFor"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">c . Symbol.keyFor()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.</span> <span class="toc-text">2. 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%9A%E8%A1%8C%E6%98%BE%E7%A4%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 字符串多行显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BD%AC%E4%B9%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2   转义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 字符串与数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-length%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.4 length属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">2.5 字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-1"><span class="toc-number">1.3.6.</span> <span class="toc-text">【重点】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Base%E8%BD%AC%E7%A0%81"><span class="toc-number">1.3.7.</span> <span class="toc-text">2.6 Base转码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.8.</span> <span class="toc-text">2.7 操作字符串方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-concat-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">2.7.1  concat()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">2.7.2 提取字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">2.7.3 字符串位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.8.4.</span> <span class="toc-text">2.7.4 字符串包含方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-5-trim-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.8.5.</span> <span class="toc-text">2.7.5 trim()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-6-repeat-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.8.6.</span> <span class="toc-text">2.7.6 repeat()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-7-%E5%A4%8D%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.8.7.</span> <span class="toc-text">2.7.7 复制字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">1.3.8.8.</span> <span class="toc-text">2.7.8 字符串大小写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">3. 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 对象语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 对象的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-JavaScript%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3  JavaScript区分对象的表达式和语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4 属性的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.5.</span> <span class="toc-text">3.5 属性的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">1. 属性的查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">2. 属性的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">3. 属性是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-with%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">4.with语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">4. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 函数介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 变量声明函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Function%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3  Function构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%87%BD%E6%95%B0%E5%90%8D%E6%8F%90%E5%8D%87"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 函数名提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.5 函数属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-name%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">1. name属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-length%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">2. length属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-toString"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">3. toString()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">4.6 函数作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.7.</span> <span class="toc-text">4.7 函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">1. 函数参数简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">2. 函数参数传递方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">3. 同名函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-arguments-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.8.</span> <span class="toc-text">4.8 arguments 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E9%97%AD%E5%8C%85-%E9%9A%BE%E7%82%B9"><span class="toc-number">1.5.9.</span> <span class="toc-text">4.9 闭包[难点!]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%87%BD%E6%95%B0%E5%90%8E%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.10.</span> <span class="toc-text">创建完函数后立即调用函数的表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eval%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.11.</span> <span class="toc-text">eval命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84-array"><span class="toc-number">1.6.</span> <span class="toc-text">5. 数组(array)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1 数组的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-length%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.2 length属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-in%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.3.</span> <span class="toc-text">5.3   in运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">5.4 遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.5 数组的空位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E7%B1%BB%E4%BC%BC%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.6.</span> <span class="toc-text">5.6类似数组的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">6. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B8%83%E5%B0%94%E5%80%BC%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1  布尔值参与运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 字符串相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BD%99%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3 余数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%B4%9F%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.4.</span> <span class="toc-text">6.4  数值运算符,负值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">1. 数值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B4%9F%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">2. 负值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.5.</span> <span class="toc-text">6.5 指数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.6.</span> <span class="toc-text">6.6 比较运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">1.讲一讲字符串的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">2. 原始类型值比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">3. 对象的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="toc-number">1.7.7.</span> <span class="toc-text">6.7 相等和严格相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E4%B8%A5%E6%A0%BC%E4%B8%8D%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.8.</span> <span class="toc-text">6.8 严格不相等运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E4%B8%80%E8%88%AC%E4%B8%8D%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.9.</span> <span class="toc-text">6.9 一般不相等运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">7. 布尔运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 取反运算符（!）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%94%E8%BF%90%E7%AE%97%E7%AC%A6-amp-amp"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.且运算符(&amp;&amp;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 或运算符 ( || )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. 三元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">8.基本引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Date"><span class="toc-number">1.9.1.</span> <span class="toc-text">8.1 Date</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-Date-parse"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">8.1.1 Date.parse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-Date-UTC"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">8.1.2 Date.UTC()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-Date%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">8.1.3 Date类继承的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">8.1.4 格式化日期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-RegExp"><span class="toc-number">1.9.2.</span> <span class="toc-text">8.2 RegExp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">a.正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-RegExp%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">b.RegExp实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">8.3 原始值包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.9.2.3.1.</span> <span class="toc-text">a.简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-object%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85"><span class="toc-number">1.9.2.3.2.</span> <span class="toc-text">b.object类型包装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-Number%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85"><span class="toc-number">1.9.2.3.3.</span> <span class="toc-text">c Number类型包装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-Boolean%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85"><span class="toc-number">1.9.2.3.4.</span> <span class="toc-text">d. Boolean类型包装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%8D%95%E4%BE%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.3.</span> <span class="toc-text">8.3  单例内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-Global"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">8.3.1 Global</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E4%BA%BA%E7%BB%A7%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%E2%80%A6"><span class="toc-number">2.</span> <span class="toc-text">本人继续更新中….</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210618/touxiang.38cvdo15qh40.jpg"></div><div class="author-info__name text-center">YaoGui</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210620/wallhaven-mpmok9.40nviwlii5q0.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">YAOGUI</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">标签页</a><a class="site-page" href="/categories">文章类别</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JavaScript笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-29</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p><strong>重点掌握</strong></p>
<p>首先基础语法过一遍,掌握就好.</p>
<ol>
<li>this 用法，相关原理</li>
<li>原型/原型链</li>
<li>闭包</li>
<li>面向对象相关</li>
<li>同步异步/回调/promise/async、await</li>
<li>模块化 CommonJS, AMD</li>
</ol>
<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><ul>
<li>JavaScript可以直接插入HTML文件中.</li>
<li><strong>JavaScript是解释型语言,是一行一行的执行下去的.</strong></li>
<li><strong>在HTML中必须使用 &lt; script &gt; 标签包含JavaScript代码.</strong></li>
<li>JavaScript的三个组成部分<ul>
<li>ECMAScript 描述了该语言的语法和基本对象.</li>
<li>文档对象模型(DOM) 描述处理网页内容的方法和接口.</li>
<li>浏览器对象模型(BOM) 描述与浏览器进行交互的方法和接口.</li>
</ul>
</li>
</ul>
<h3 id="注释写法"><a href="#注释写法" class="headerlink" title="注释写法"></a>注释写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h3 id="a-语句"><a href="#a-语句" class="headerlink" title="a.语句"></a>a.语句</h3><p>JavaScript的语句需要用到分号结尾.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<p>多个语句可以写在一行之内</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">2</span>; <span class="keyword">var</span> b = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>分号前面没有任何内容,JavaScript就会视为空语句.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;;; <span class="comment">//这就是三个空语句</span></span><br></pre></td></tr></table></figure>



<p>表达式不需要分号结尾,一旦在表达式后面添加封号,JavaScript会视为语句,从而产生一些没有意义的语句.</p>
<h3 id="b-变量"><a href="#b-变量" class="headerlink" title="b.变量"></a>b.变量</h3><p>JavaScript区分大小写, A 和 a 是两个给不同的变量.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> A = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<p>如果只是声明但是没有赋值,那么这个变量的值就是undefined.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>



<p><strong>undefined表示无意义</strong></p>
<p>赋值的时候也可以不写  var</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用<code>var</code>命令声明变量。</p>
</blockquote>
<p>同时声明多个变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b;</span><br></pre></td></tr></table></figure>





<h4 id="【重点】"><a href="#【重点】" class="headerlink" title="【重点】"></a>【重点】</h4><p><strong>JavaScript是一种动态类型语言,变量可以随时更改类型.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p><strong>如果用var重新声明一个已近存在的值是无效的.</strong></p>
<p><strong>但是，第二次声明的时候进行了赋值，则会覆盖掉前面的值。</strong></p>
<h4 id="let变量声明"><a href="#let变量声明" class="headerlink" title="let变量声明"></a>let变量声明</h4><p><strong>使用let声明得变量,再作用域外不能被使用.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> Name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">   <span class="comment">// 输出 Matt</span></span><br><span class="line">   <span class="built_in">console</span>.log(Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样输出Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(Name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- let声明区块变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> let_name = <span class="string">&#x27;jeck&#x27;</span>;</span><br><span class="line">   <span class="comment">// 输出 jeck</span></span><br><span class="line">   <span class="built_in">console</span>.log(let_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未定义</span></span><br><span class="line"><span class="built_in">console</span>.log(let_name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>同意作用域中,let不能重复声明同一标识符</p>
<p>而var可以,但是不同作用域,但let在不同的作用域就可以声明同一标识符.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在作用域中,var可以重复声明同一表示符</span></span><br><span class="line"><span class="keyword">var</span> Name = <span class="string">&#x27;Tom2&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> Name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">   <span class="comment">// 输出 Matt</span></span><br><span class="line">   <span class="built_in">console</span>.log(Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样输出Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(Name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- let声明区块变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> let_name = <span class="string">&#x27;Jery&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(let_name);</span><br><span class="line"><span class="comment">// 报错,同一作用域,let不能重复声明同一标识符</span></span><br><span class="line"><span class="comment">// let let_name = &#x27;Jery&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> let_name = <span class="string">&#x27;jeck&#x27;</span>;</span><br><span class="line">   <span class="comment">// 输出 jeck</span></span><br><span class="line">   <span class="built_in">console</span>.log(let_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出Jery</span></span><br><span class="line"><span class="built_in">console</span>.log(let_name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="let声明变量不提升"><a href="#let声明变量不提升" class="headerlink" title="let声明变量不提升"></a>let声明变量不提升</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出undefined,说明Name对象被创建.</span></span><br><span class="line"><span class="built_in">console</span>.log(Name);</span><br><span class="line"><span class="keyword">var</span> Name = <span class="string">&#x27;Tom1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错,let_Name么有被创建</span></span><br><span class="line"><span class="built_in">console</span>.log(let_Name);</span><br><span class="line"><span class="keyword">let</span> let_Name = <span class="string">&#x27;Jery1&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h5 id="let搭配for实现遍历的好处"><a href="#let搭配for实现遍历的好处" class="headerlink" title="let搭配for实现遍历的好处"></a>let搭配for实现遍历的好处</h5><p>当for循环碰见setTimeout()函数的时候,你会发现,for循环是在<code>setTimeout()</code>函数之后运行的,这个时候使用<code>let</code> 和 使用 <code>var</code>声明变量最后输出结果是不一样的</p>
<p><code>在使用var时最常见得问题是最迭代变量得奇特声明和修改</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">设置三秒后弹出一个弹窗</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;对不起, 要你久候&#x27;)&quot;</span>, <span class="number">3000</span> )</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">   <span class="comment">// 用到了箭头函数</span></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;let&#x27;</span> + i), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问不到for循环括号里得 i 变量</span></span><br><span class="line"><span class="comment">// console.log(i);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">   <span class="comment">// 用到箭头函数</span></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;var&#x27;</span> + i), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问不到for循环括号里得 i 变量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;呵呵哒&#x27;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">呵呵哒5  //console居然最先输出</span></span><br><span class="line"><span class="comment"> let0</span></span><br><span class="line"><span class="comment"> let1</span></span><br><span class="line"><span class="comment"> let2</span></span><br><span class="line"><span class="comment"> let3</span></span><br><span class="line"><span class="comment"> let4</span></span><br><span class="line"><span class="comment"> var5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h4 id="var声明变量提升"><a href="#var声明变量提升" class="headerlink" title="var声明变量提升"></a><strong>var声明变量提升</strong></h4><blockquote>
<p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>
</blockquote>
<p>解释解释,就是JavaScript在所有代码运行中,会首先进行变量的声明;</p>
<p><em>比如我们有下面两个代码</em></p>
<p><strong>a. 变量声明在语句下方</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句不会报错,因为由于变量提升,他的实际执行顺序如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为输出语句,在 a的赋值语句之前运行,所以我们控制台上不会显示出a的值.</p>
<p><strong>b.变量声明在语句上方</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>这中语句赋值在输出语句上方的代码,就能够在控制台打印出a的值.</p>
<h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>C语言中也有const用来声明常量</p>
<p>JavaScript中const和let基本相同,既不允许同一作用域下重复声明,也是域内声明得话域外访问不到,当时有以下两点特点.</p>
<ul>
<li>声明变量得时候必须初始化变量</li>
<li>尝试修改const声明得变量会报错</li>
</ul>
<p>const如果声明对象,是可以修改其属性的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">   <span class="attr">Name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出 Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(person.Name);</span><br><span class="line">person.Name = <span class="string">&#x27;Jery&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出Jery</span></span><br><span class="line"><span class="built_in">console</span>.log(person.Name);</span><br></pre></td></tr></table></figure>



<p><strong>某种意义上来说,有了let 和 const,我们已经可以不使用var 来声明变量了.</strong></p>
<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><ul>
<li>第一个字符<strong>必须</strong>是任意字母(包括其他语言的字母),以及,美元符号($)和下划线( _ );</li>
<li>第二个字符出了任意字母,美元符号,下划线之外,还可以用数值0~9.</li>
</ul>
<h3 id="c-区块"><a href="#c-区块" class="headerlink" title="c.区块"></a>c.区块</h3><p>JavaScript使用大括号将许多相关的语句组合在一起,称为区块.</p>
<p>但是区块对 var 命令来说,JavaScript的区块不构成单独的作用域.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们在区块外依旧能够使用 a b</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>



<h3 id="d-标签-跳转"><a href="#d-标签-跳转" class="headerlink" title="d.标签(跳转)"></a>d.标签(跳转)</h3><p>在语句前加标签,相当于定位,可以跳转到该语句.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i-<span class="number">2</span>)===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 当i=2时,直接跳出循环.</span></span><br><span class="line">            <span class="keyword">break</span> top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>双层循环中使用标签</strong></p>
<p><strong>break</strong></p>
<p>下面代码为双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i===<span class="number">1</span> &amp;&amp; j===<span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span>+ i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>continue</strong></p>
<p>continue 同样和 break 一样可以配合标签使用</p>
<p>continue后面有标签时,满足条件则可以直接跳过循环进行下一次<strong>外循环</strong></p>
<p>continue后面没有标签的时候,则只能跳过此次循环,执行下一次<strong>内循环</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用标签跳出区块</strong></p>
<p>当使用break跳出区块时,并不是重新又从区块开始运行,而是<strong>直接运行区块下面的代码</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;本行不会输出&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>





<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul>
<li>数值(number)<ul>
<li>整数 和 小数</li>
</ul>
</li>
<li>字符串(string)<ul>
<li>‘ HOLLE WOURLD ‘</li>
</ul>
</li>
<li>布尔值(Boolean)<ul>
<li>true and  flase</li>
</ul>
</li>
<li>undefined<ul>
<li>表示 “未定义” 或者 “不存在”;</li>
</ul>
</li>
<li>null : 表示空值</li>
<li>对象(object) : 各种值得组成集合</li>
</ul>
<p>数值、字符串、布尔值这三种类型，合称为<strong>原始类型</strong>（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</p>
<p>对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。</p>
<p>至于<code>undefined</code>和<code>null</code>，一般将它们看成两个特殊值。</p>
<h3 id="1-1-确定值的类型"><a href="#1-1-确定值的类型" class="headerlink" title="1.1  确定值的类型"></a>1.1  确定值的类型</h3><p>确定值的类型有三种方式,分别是两种运算符和一种方法</p>
<ul>
<li>typeof 运算符</li>
<li>instanceof 运算符</li>
<li>Object.prototype.toString 方法</li>
</ul>
<h4 id="1-1-1-typeof"><a href="#1-1-1-typeof" class="headerlink" title="1.1.1 typeof"></a>1.1.1 typeof</h4><p>原始的数据类型分别返还他们的名称.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>       <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span>    <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>   <span class="comment">// &quot;boolean&quot;</span></span><br></pre></td></tr></table></figure>



<p>函数返回function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>



<p>返回undefined类型就时undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>



<p>typeof 返回 window {} [] 都是object;</p>
<p>这也就是说明在JavaScript中<strong>空数组</strong>的类型时object , JavaScript内部,数组的本质上只是一种特殊的对象.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>typeof 通常用于判断</strong></p>
<p><strong>用于检查一个变量是否存在值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-2-null-and-undefined"><a href="#1-2-null-and-undefined" class="headerlink" title="1.2 null and undefined"></a>1.2 null and undefined</h3><p>null 和 undefined 很相似,以下两个赋值语句写法产生的效果几乎等价.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>



<p>比如见如下代码, <strong>null 和 undefined 都会自动转化成false</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;undefined&gt;&gt;a is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码等价于此代码</span></span><br><span class="line"><span class="comment">if (!undefined) &#123;</span></span><br><span class="line"><span class="comment">   console.log(&#x27;undefined is false&#x27;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;null&gt;&gt;b is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码等价于此代码</span></span><br><span class="line"><span class="comment">if (!null) &#123;</span></span><br><span class="line"><span class="comment">   console.log(&#x27;null is false&#x27;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>但是为何会有这两个这么相似得值呢,根据文档得教学,是因为历史原因.</p>
<blockquote>
<p>1995年 JavaScript 诞生时，最初像 Java 一样，只设置了<code>null</code>表示”无”。根据 C 语言的传统，<code>null</code>可以自动转为<code>0</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Number(null) // 0</span><br><span class="line">&gt;5 + null // 5</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>null</code>转为数字时，自动变成0。</p>
<p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误。</p>
<p>因此，他又设计了一个<code>undefined</code>。区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Number(undefined) // NaN</span><br><span class="line">&gt;5 + undefined // NaN</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>做一个小小总结</strong></p>
<p><strong>关键就是 null转化数值是0 , undefined转化数值是NaN</strong></p>
<p>null正因为转化成数值是0 所以加一个数值他就是那个数值得本身,但是undefined加任何数值都是NaN.</p>
<blockquote>
<p>NaN 含义</p>
<blockquote>
<p><em>NaN</em>（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值</p>
</blockquote>
</blockquote>
<h4 id="什么时候是undefined"><a href="#什么时候是undefined" class="headerlink" title="什么时候是undefined"></a>什么时候是undefined</h4><p><em>1. 变量声明未赋值</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i;  <span class="comment">//此时 i 是 undefined</span></span><br></pre></td></tr></table></figure>



<p><em>2. 调用函数时,未提供该提供得参数</em></p>
<p>调用函数时,未提供该提供得参数,此时该<strong>参数</strong>等于undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = fun_name();</span><br><span class="line"><span class="built_in">console</span>.log(f);  <span class="comment">// 输出 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数被调用时,生成得形参,没有实际得值传入,这个生成得形参默认就会被赋值成undefined.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>3. 对象没有赋值属性</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<p><em>4. 函数没有返回值,默认返回undefined</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>





<h3 id="1-3-布尔值"><a href="#1-3-布尔值" class="headerlink" title="1.3 布尔值"></a>1.3 布尔值</h3><h4 id="1-3-1-逻辑运算符"><a href="#1-3-1-逻辑运算符" class="headerlink" title="1.3.1 逻辑运算符"></a>1.3.1 逻辑运算符</h4><ul>
<li>前置逻辑运算符： <code>!</code> (Not)</li>
<li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li>
<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
</ul>
<h4 id="1-3-2-自动转化false"><a href="#1-3-2-自动转化false" class="headerlink" title="1.3.2 [自动转化false]"></a>1.3.2 [自动转化false]</h4><p><strong>以下的六个值,都会自动转化成false,</strong></p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>见下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>



<p>但是空数组,和空对象都是 true </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>





<h3 id="1-4-整数和小数"><a href="#1-4-整数和小数" class="headerlink" title="1.4 整数和小数"></a>1.4 整数和小数</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<ul>
<li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li>
<li>第2位到第12位（共11位）：指数部分</li>
<li>第13位到第64位（共52位）：小数部分（即有效数字）</li>
</ul>
<h4 id="1-4-1-数值精度"><a href="#1-4-1-数值精度" class="headerlink" title="1.4.1 数值精度"></a>1.4.1 数值精度</h4><p>JavaScript中一个数得指数不能超过52位</p>
<p>超过这个位数,再进行运算会出错,不准确.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number_a = <span class="literal">null</span>;</span><br><span class="line">number_a = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>);</span><br><span class="line"><span class="built_in">console</span>.log(number_a); <span class="comment">//9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number_b = <span class="literal">null</span>;</span><br><span class="line">number_b = number_a + <span class="number">1</span>; <span class="comment">//9007199254740992</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">number_b = number_a + 2; //9007199254740994</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">number_b = number_a + 3; //9007199254740996</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(number_b);</span><br></pre></td></tr></table></figure>



<h4 id="1-4-2-数值范围"><a href="#1-4-2-数值范围" class="headerlink" title="1.4.2 数值范围"></a>1.4.2 数值范围</h4><p>因为64位的浮点指数部分长度是11的二进制位,所以做大表示数的值是2的2047次方(2的11次方减一),然后一半用来表示负数.</p>
<p>2<sup>1024</sup> ~ 2<sup>-1023</sup> (开区间) 就是JavaScript表示数的大小</p>
<p>当大于或者等于最大值的收,会返回 Infinity<br>当小于或者等于最小值的时候会返回 0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number_a, number_b;</span><br><span class="line"></span><br><span class="line">number_a = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(number_a)</span><br><span class="line"></span><br><span class="line">number_b = <span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(number_b)</span><br></pre></td></tr></table></figure>



<p>看看如下代码</p>
<p> <code>0.5</code>连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">  x = x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h4 id="1-4-3-数值表示"><a href="#1-4-3-数值表示" class="headerlink" title="1.4.3 数值表示"></a>1.4.3 数值表示</h4><p><strong>JavaScript 内部会自动将八进制、十六进制、二进制转为十进制</strong></p>
<ul>
<li>十进制：没有前导0的数值。</li>
<li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li>
<li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li>
</ul>
<p><strong>JavaScript自动将数值用科学计数法表示的两种情况</strong></p>
<ol>
<li> 小数点前的数字多于 21 位</li>
<li> 小数点后的 0 多余五个</li>
</ol>
<h4 id="1-4-4-特殊值"><a href="#1-4-4-特殊值" class="headerlink" title="1.4.4 特殊值"></a>1.4.4 特殊值</h4><h5 id="正负-0"><a href="#正负-0" class="headerlink" title="正负 0"></a>正负 0</h5><p>JavaScript有一位被当作符号位,也就是任何一个数都会有一个对应的负值,几乎所有情况 +0 和 -0 都会被当作是等价的,但是当这两个 0 作为分母的时候,返回值是不相同的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1 / +0) === (1 / -0) // false</span><br></pre></td></tr></table></figure>

<p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的</p>
<h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>0 除以 0 会得到 NaN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 / 0       //NaN</span><br></pre></td></tr></table></figure>



<p>将字符串解析成数字的时候会出现NaN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 - &#x27;x&#x27;      // NaN</span><br></pre></td></tr></table></figure>





<p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof NaN           // &#x27;number&#x27;</span><br></pre></td></tr></table></figure>





<p><strong>NaN不等于任何值,包括它本身</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NaN === NaN // false</span><br></pre></td></tr></table></figure>



<p><strong>NaN当作布尔值使用时是false</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean(NaN) // false</span><br></pre></td></tr></table></figure>



<p><strong>NaN与任何值进行运算,得到的结果都是NaN</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NaN + 32 // NaN</span><br><span class="line">NaN - 32 // NaN</span><br><span class="line">NaN * 32 // NaN</span><br><span class="line">NaN / 32 // NaN</span><br></pre></td></tr></table></figure>





<h5 id="Infinity-【重点】"><a href="#Infinity-【重点】" class="headerlink" title="Infinity 【重点】"></a>Infinity 【重点】</h5><p><strong>Infinity一般用来表示两个场景.</strong></p>
<ol>
<li>一个正值太大或者一个负值太小</li>
<li>非0数值 除以 0</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity</span><br></pre></td></tr></table></figure>





<p><strong>Infinity有正负之分</strong></p>
<p>正 Infinity 和 -Infinity 是不等价的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> === -<span class="literal">Infinity</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），</p>
<p><code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</p>
<p><strong>Infinity 表示正无穷, -Infinity表示负无穷.</strong></p>
<p>那么什么时候得到正负的 Infinity</p>
<ul>
<li>非 0 的正数除以 -0 得到负无穷.</li>
<li>负数 除以 -0 得到 正无穷.</li>
</ul>
<p>符号 和 0 相同的数,那么得到的就是Infinity , 如果这个数和 0 的符号相反,得到的数就是 -Infinity . </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Infinityconsole.log(1 / 0);// -Infinityconsole.log(-1 / 0);// -Infinityconsole.log(1 / -0);// Infinityconsole.log(-1 / -0);</span></span><br></pre></td></tr></table></figure>





<p><strong>Infinity 的运算规则</strong></p>
<p>Infinity 和 其他一般数值数运算符合计算规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span> 		<span class="comment">// Infinity5 - Infinity 		// -InfinityInfinity / 5 		// Infinity5 / Infinity 		// 0</span></span><br></pre></td></tr></table></figure>



<p>0乘以<code>Infinity</code>，返回<code>NaN</code>；</p>
<p>0除以<code>Infinity</code>，返回<code>0</code>；</p>
<p><code>Infinity</code>除以0，返回<code>Infinity</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span> 		<span class="comment">// NaN0 / Infinity 		// 0Infinity / 0 		// Infinity</span></span><br></pre></td></tr></table></figure>





<p><strong><code>Infinity</code>加上 或 乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span> 	<span class="comment">// InfinityInfinity * Infinity 	// Infinity</span></span><br></pre></td></tr></table></figure>



<p><strong><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> 	<span class="comment">// NaNInfinity / Infinity 	// NaN</span></span><br></pre></td></tr></table></figure>



<p><strong><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span> 	<span class="comment">// NaNnull / Infinity	 	// 0Infinity / null 	// Infinity</span></span><br></pre></td></tr></table></figure>



<p><strong><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="literal">Infinity</span> <span class="comment">// NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-parselnt（）"><a href="#1-5-parselnt（）" class="headerlink" title="1.5  parselnt（）"></a>1.5  parselnt（）</h3><p>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix);<span class="comment">/*string 必须填写得值,要被解析成数字得字符串radix 表示要解析数字得基数,该值介于2-36之间.如果该值超过36或者小于2,那么返回的值就是 NaN*/</span></span><br></pre></td></tr></table></figure>





<p>parseInt方法，用于将字符串转化成整数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;<span class="comment">// 将字符串转为数字a = parseInt(&#x27;110&#x27;);  // 110console.log(a);//当有空格,空格会被自动剔除a = parseInt(&#x27;       330&#x27;);console.log(a);// 遇到不能转为数字的符号停止转化// 直接返回已近转化好的数字a = parseInt(&#x27;1.10&#x27;);  // 1console.log(a);a = parseInt(&#x27;2*10&#x27;);  // 2console.log(a);//除非这个符号是 + - 号后面跟着数字a = parseInt(&#x27;+110&#x27;);console.log(a);a = parseInt(&#x27;-110&#x27;);console.log(a);//单纯的正负号依旧是返回NaNa = parseInt(&#x27;+&#x27;);console.log(a);a = parseInt(&#x27;-&#x27;);console.log(a);// 如果是0x开头,则会按照16进制解析a = parseInt(&#x27;0x10&#x27;) // 16console.log(a);// 如果是 0 开头 则按照 10进制解析a = parseInt(&#x27;0016&#x27;) // 16console.log(a);</span></span><br></pre></td></tr></table></figure>



<p>特殊情况,因为有些数字再特定情况下自动转为科学技术法.</p>
<ol>
<li> 小数点前的数字多于 21 位</li>
<li> 小数点后的 0 多余五个</li>
</ol>
<p>像这种情况,会<strong>按照科学技术法的写法</strong>来读取数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1// 等同于parseInt(&#x27;1e+21&#x27;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&#x27;8e-7&#x27;) // 8</span></span><br></pre></td></tr></table></figure>



<p><strong>parseInt 方法的进制属性</strong></p>
<p>我们可以在这个字符串后面设定这个数值按照何种进制输出.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">2</span>)    <span class="comment">//把读取的数按照2进制输出 &gt;&gt; 8</span></span><br></pre></td></tr></table></figure>

<p>同理,16进制,8进制都可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>





<h3 id="1-6-parseFloat"><a href="#1-6-parseFloat" class="headerlink" title="1.6 parseFloat()"></a>1.6 parseFloat()</h3><p>parse: 解析   float: 浮点,浮动</p>
<p>对比上方得parseInt()方法,我们基本就能够知道这个方法是针对将字符串解析成浮点型.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>)    <span class="comment">//3.14</span></span><br></pre></td></tr></table></figure>



<p>parseFloat() 这方法和parseInt()这方法不一样,它会对科学计数法进行正常的解析.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;314e-2&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;0.0314E+2&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>



<p>同样,如果字符串中有着不能够解析成浮点类型得字符串,那么这个函数就会停止解析,并且返回已近解析好的函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14aaabbb&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>



<p>同样,parseFloat会自动过滤掉前方的空格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;\t\v\r  12.34\n &#x27;</span>)   <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure>



<p>遇见第一个不能转化得字符,就直接返回NaN,有个特殊的可以看看,就是parseFloat会将空字符串转为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;FF2&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>





<h3 id="1-7-isNaN"><a href="#1-7-isNaN" class="headerlink" title="1.7 isNaN()"></a>1.7 isNaN()</h3><p>isNaN() 用来判断一个值是否是NaN,如果是就返回true,如果不是就返回false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">NaN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数值 -- false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a));</span><br><span class="line"><span class="comment">//判断表达式 -- false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(b - a));</span><br><span class="line"><span class="comment">// NaN和任何数运算都是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a + d));</span><br><span class="line"><span class="comment">//只要是字符串都会转成数值NaN,然后判断陈NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(c));</span><br></pre></td></tr></table></figure>



<p>isNaN()方法因为字符串都会转化成数值NaN,这种情况面对数组和对象同理.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>([<span class="string">&#x27;xzy&#x27;</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>但是对于空数组或者只有一个数值成员的数组,isNaN返回的是false.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;123&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p>所以使用isNaN()方法的时候,最好像判断以下类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);&#125;</span><br></pre></td></tr></table></figure>



<p>判断是不是NaN最可靠的值就是利用NaN不等同于自身这一点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;  <span class="keyword">return</span> value !== value;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-8-Symbol类型"><a href="#1-8-Symbol类型" class="headerlink" title="1.8 Symbol类型"></a>1.8 Symbol类型</h3><h4 id="a-symbol简介"><a href="#a-symbol简介" class="headerlink" title="a.symbol简介"></a>a.symbol简介</h4><p><code>Symbol()</code>是原始函数,所以typeof返回结果依旧是 Symbol</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();<span class="comment">// 返回 symbol console.log(typeof (sym));</span></span><br></pre></td></tr></table></figure>



<p>symbol()类型,相当于独自的id一样,每一个symbol类型都不会相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>();<span class="comment">// 两个都是falseconsole.log(sym1 === sym2);console.log(sym1 == sym2);</span></span><br></pre></td></tr></table></figure>



<p>声明`symbo类型的时候,可以传入一个参数作为对符号的描述.但是这个字符串和定义标识符而安全无关,具体看如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">// 两个都是falseconsole.log(sym1 === sym2);console.log(sym1 == sym2);</span></span><br></pre></td></tr></table></figure>



<h4 id="b-symbol-for"><a href="#b-symbol-for" class="headerlink" title="b.symbol.for()"></a>b.symbol.for()</h4><p>原理:</p>
<p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。</p>
<p>为此，需要使用Symbol.for()方法:</p>
<p>Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*symbol本来不会相等但是有需求用到时,想要他相等的时候可以使用symbol.for()*/</span><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">// 两个都是symbol类型console.log(typeof (sym1));console.log(typeof (sym2));// trueconsole.log(sym1 === sym2);// trueconsole.log(sym1 == sym2);</span></span><br></pre></td></tr></table></figure>





<h4 id="c-Symbol-keyFor"><a href="#c-Symbol-keyFor" class="headerlink" title="c . Symbol.keyFor()"></a>c . Symbol.keyFor()</h4><p>用来查询<strong>全局注册表</strong> , 这个方法接收符号,返回全局符号对应的字符串键.</p>
<p><strong>如果查询的不是全局符号,则返回undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>.for();<span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);<span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);<span class="comment">// undefinedconsole.log(Symbol.keyFor(sym1));// undefinedconsole.log(Symbol.keyFor(sym2));// undefinedconsole.log(Symbol.keyFor(sym3));</span></span><br></pre></td></tr></table></figure>



<p><strong>如果<code>Symbol.keyFor()</code>中,传入的不是字符串,则会抛出TypeError错误</strong></p>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><h3 id="2-1-字符串多行显示"><a href="#2-1-字符串多行显示" class="headerlink" title="2.1 字符串多行显示"></a>2.1 字符串多行显示</h3><p>字符串太长,可以进行多行书写,需要用到反斜杠配合.</p>
<p><strong>注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</strong></p>
<p>注意这个反斜杠后面的回车符号还只能是一个,否则也会报错.</p>
<p>说明白点就是反斜杠后面只能且必须有一个回车符号.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long \long \long \string&#x27;</span>;</span><br></pre></td></tr></table></figure>





<p>或者使用链接符号( + )来多行输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long &#x27;</span>  + <span class="string">&#x27;long &#x27;</span>  + <span class="string">&#x27;long &#x27;</span>  + <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-转义"><a href="#2-2-转义" class="headerlink" title="2.2   转义"></a>2.2   转义</h3><p>下列字符都需要用到转义字符.</p>
<ul>
<li><code>\0</code> ：null（<code>\u0000</code>）</li>
<li><code>\b</code> ：后退键（<code>\u0008</code>）</li>
<li><code>\f</code> ：换页符（<code>\u000C</code>）</li>
<li><code>\n</code> ：换行符（<code>\u000A</code>）</li>
<li><code>\r</code> ：回车键（<code>\u000D</code>）</li>
<li><code>\t</code> ：制表符（<code>\u0009</code>）</li>
<li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li>
<li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li>
<li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li>
<li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li>
</ul>
<p>反斜杠还有三种特殊用法。</p>
<p>（1）<code>\HHH</code></p>
<p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p>
<p>（2）<code>\xHH</code></p>
<p><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p>
<p>（3）<code>\uXXXX</code></p>
<p><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p>
<p>如果在正常的字符前面使用反斜杠,这个反斜杠则会被忽略.</p>
<h3 id="2-3-字符串与数组"><a href="#2-3-字符串与数组" class="headerlink" title="2.3 字符串与数组"></a>2.3 字符串与数组</h3><p>字符串某种意义上来说就可以被当作字符数组.</p>
<p>也就是说在JavaScript中,你可以用数组下面来使用字符串中的字符.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;helloworld&#x27;</span>;<span class="built_in">console</span>.log(str[<span class="number">5</span>]);<span class="built_in">console</span>.log(<span class="string">&#x27;helloworld&#x27;</span>[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>如果使用的下标超过字符串长度,则返回undefined.</p>
<h3 id="2-4-length属性"><a href="#2-4-length属性" class="headerlink" title="2.4 length属性"></a>2.4 length属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;helloworld&#x27;</span>;<span class="comment">// 输出字符串长度,有几个字母就有多长.console.log(str.length);</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5-字符集"><a href="#2-5-字符集" class="headerlink" title="2.5 字符集"></a>2.5 字符集</h3><p>JavaScript 内部使用的是 unicode字符集, 可以类比ASCII表 , 就是各种字符的另一种形式的写法.</p>
<p>举例几个Unicode形式的字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字母 Oconsole.log(&#x27;\u006F泡果奶,我要\u006F泡,我要\u006F泡&#x27;);// 结果: o泡果奶,我要o泡,我要o泡</span></span><br></pre></td></tr></table></figure>



<p>除了这样书写,还可以用来命名.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006Ft = <span class="string">&#x27;foot是脚的意思.&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>放心,JavaScript会自动识别Unicode形式和字面形式,不管何种形式,最后输出都是以字面形式输出的.</p>
<h3 id="【重点】-1"><a href="#【重点】-1" class="headerlink" title="【重点】"></a>【重点】</h3><blockquote>
<p>UTF-16 有两种长度：</p>
<p>对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）</p>
<p>对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节）,而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&#x27;𝌆&#x27;.length // 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p>
<p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p>
</blockquote>
<p>我觉得我看不太明白具体的原理,但是我好像清楚就是对于拥有四字节的字符的字符串,返回值不一定准确.</p>
<h3 id="2-6-Base转码"><a href="#2-6-Base转码" class="headerlink" title="2.6 Base转码"></a>2.6 Base转码</h3><p>比如ASCII中0-31的符号无法打印,就可以用到Base转码,或者以文本格式传递二进制数据.</p>
<blockquote>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
</blockquote>
<p>JavaScript 原生提供两个 Base64 相关的方法。</p>
<ul>
<li><code>btoa()</code>：任意值转为 Base64 编码</li>
<li><code>atob()</code>：Base64 编码转为原来的值</li>
</ul>
<p>使用Base转码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str_1 = <span class="string">&#x27;hello world!!!&#x27;</span>;<span class="comment">// 把str_1转化成Base编码格式var str_1_ma = btoa(str_1);// str_1对应的编码格式//  aGVsbG8gd29ybGQhISE=console.log(str_1_ma);var str_1_wen = atob(&#x27;aGVsbG8gd29ybGQhISE=&#x27;);// 输出了 hello world!!!console.log(str_1_wen);</span></span><br></pre></td></tr></table></figure>



<p>如果转码内容不是ASCII码表中的内容(比如中文),那么得先转码.</p>
<ol>
<li>先将encodeURIComponent()方法把中文文本进行 URI 编码</li>
<li>然后用btoa()方法将URI编码转化成Base64编码</li>
<li>用atob()方法转回原来得 URI 编码</li>
<li>然后用 decodeURIComponent() 对 encodeURIComponent()得 URI 的编码进行解码</li>
</ol>
<ul>
<li>encodeURIComponent( uri )<ul>
<li>可以把字符串作为 URI 组件进行编码</li>
<li>该方法不会对ASCII字母和数字进行编码,也不会对ASCII得标点符号进行编码.</li>
</ul>
</li>
<li>decodeURIComponent (URIstring)<ul>
<li>用于对 URI 码进行解析(还原)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;   <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));&#125;<span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;   <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));&#125;<span class="keyword">var</span> a = b64Encode(<span class="string">&#x27;你真的傻&#x27;</span>)<span class="built_in">console</span>.log(a);<span class="keyword">var</span> a = b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU3JTlDJTlGJUU3JTlBJTg0JUU1JTgyJUJC&#x27;</span>)<span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>



<h3 id="2-7-操作字符串方法"><a href="#2-7-操作字符串方法" class="headerlink" title="2.7 操作字符串方法"></a>2.7 操作字符串方法</h3><h4 id="2-7-1-concat-方法"><a href="#2-7-1-concat-方法" class="headerlink" title="2.7.1  concat()方法"></a>2.7.1  concat()方法</h4><p><em>将一个或多个字符拼接成一个新字符串.</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_one = <span class="string">&quot;hello&quot;</span>;<span class="keyword">let</span> result = str_one.concat(<span class="string">&quot;world&quot;</span>);<span class="comment">// helloworldconsole.log(result);// helloconsole.log(str_one);</span></span><br></pre></td></tr></table></figure>



<p>从上面可知,并不会对原字符串<code>str_one</code>有什么影响.</p>
<p>我们还可以多个字符串连续拼接,但是多数情况下,使用<code>+</code>号更加便捷.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_one = <span class="string">&quot;hello&quot;</span>;<span class="keyword">let</span> result = str_one.concat(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&#x27;我是刘英俊&#x27;</span>);<span class="comment">// helloworldconsole.log(result);// helloconsole.log(str_one);</span></span><br></pre></td></tr></table></figure>





<h4 id="2-7-2-提取字符串"><a href="#2-7-2-提取字符串" class="headerlink" title="2.7.2 提取字符串"></a>2.7.2 提取字符串</h4><p>提供了三个提取字符串的方法.</p>
<p>slice() , substr() , substring()</p>
<p>传入的参数是正数,这三个返回的结果没啥区别,直接去第三个字符串的前面部分.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld!!!&quot;</span>;<span class="comment">// 下面三个都是 oworld!!!// 说明字符串中第一个字母算 0console.log(str.slice(4));console.log(str.substr(4));console.log(str.substring(4));</span></span><br></pre></td></tr></table></figure>



<p>如果都传入 0 ,最后结果都是将字符串整个输出.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld!!!&quot;</span>;<span class="comment">// helloworld!!!console.log(str.slice(0));console.log(str.substr(0));console.log(str.substring(0));</span></span><br></pre></td></tr></table></figure>





<p><strong>当参数是负数的时候比较不一样</strong></p>
<p><code>slice()</code> 第一个参数为负的时候,是将总长度加上这个负数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld!!!&quot;</span>;<span class="comment">// 13console.log(str.length);// 13+(-5)=8,从0开始数到第八个开始截取// ld!!!console.log(str.slice(-5));//从第五位截取到第八位console.log(str.slice(5, -5));</span></span><br></pre></td></tr></table></figure>



<p>substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说白了就是第一个参数和slice()一样,长度加这个负数// 但是当第一个参数为负数,第二个只要不为正整数,都转成0let str = &quot;helloworld!!!&quot;;// 13console.log(str.length);// 空的 什么都不输出console.log(str.substr(-5, -2));// 空的 什么都不输出console.log(str.substr(-5, 0));// 从第八个字符开始截取两个字符console.log(str.substr(-5, 2));</span></span><br></pre></td></tr></table></figure>





<p><code>substring()</code>这个方法就比较极端,将所有负数都转化成0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld!!!&quot;</span>;<span class="comment">// 13console.log(str.length);// 都是从0 截取 到第五位之前console.log(str.substring(0, 5));console.log(str.substring(-5, 5));// 空的 啥都不输出console.log(str.substring(0, -5));/* 等价于str.substring(5, 0)等价于str.substring(5)*/console.log(str.substring(5, -5));</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-3-字符串位置"><a href="#2-7-3-字符串位置" class="headerlink" title="2.7.3 字符串位置"></a>2.7.3 字符串位置</h4><p>indexOf() 和 lastindexOf()</p>
<p><strong>前者默认是从开头搜索字符串,后者默认是从结尾搜索</strong></p>
<p><em>如果找到就立即返回位置不再寻找</em><br><em>如果没有找到就返回<code>-1</code></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld&quot;</span>;<span class="comment">// 4console.log(str.indexOf(&quot;o&quot;));// 6console.log(str.lastIndexOf(&quot;o&quot;));</span></span><br></pre></td></tr></table></figure>



<p>第二个参数就是自己设置找字符串的七点从哪里开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld&quot;</span>;<span class="comment">// 6console.log(str.indexOf(&quot;o&quot;, 5));// 4console.log(str.lastIndexOf(&quot;o&quot;, 5));</span></span><br></pre></td></tr></table></figure>





<h4 id="2-7-4-字符串包含方法"><a href="#2-7-4-字符串包含方法" class="headerlink" title="2.7.4 字符串包含方法"></a>2.7.4 字符串包含方法</h4><p>以下三个方法用来判断一个字符串中是否包含其他方法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// startsWith()检查开始于索引0的匹配项startsWith()// endsWith()检查开始于索引(string.length - substring.length)的匹配项// 说白了就是看结尾处字符串是不是和你要找的字符串一样endsWith() //检查整个字符串includes()</span></span><br></pre></td></tr></table></figure>



<p>startsWith()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;animalbeartigerlionsnake&quot;</span>;</span><br><span class="line"><span class="comment">// 从两个字符串的开头进行匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">&quot;bear&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">&quot;animal&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提供参数 自己设定查找位置 */</span></span><br><span class="line"><span class="comment">// 从提供位置的地方向字符串后面查找</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">&quot;bear&quot;</span>,<span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>endsWith() </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;animalbeartigerlionsnake&quot;</span>;</span><br><span class="line"><span class="comment">// 匹配结尾最后一点和参数相不相同</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;snake&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;nak&quot;</span>));   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提供参数 自己设定查找位置 */</span></span><br><span class="line"><span class="comment">// 把提供的参数当作字符串尾部</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;snake&quot;</span>, str.length - <span class="number">5</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;lion&quot;</span>, str.length - <span class="number">5</span>));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<p>includes()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;animalbeartigerlionsnake&quot;</span>;</span><br><span class="line"><span class="comment">// 对字符串整个进行查找</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;tiger&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;squirrel&quot;</span>));   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提供参数 自己设定查找位置 */</span></span><br><span class="line"><span class="comment">// 从提供位置的地方向字符串后面查找</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;tiger&quot;</span>,<span class="number">5</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-7-5-trim-方法"><a href="#2-7-5-trim-方法" class="headerlink" title="2.7.5 trim()方法"></a>2.7.5 trim()方法</h4><p>作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;    animal bear tiger lion  snake      &quot;</span>;<span class="built_in">console</span>.log(str);<span class="keyword">let</span> aaa = str.trim();<span class="comment">// 只能删除双引号距离字符串中间的空格,字符串内本身的空格不能删除.console.log(aaa);</span></span><br></pre></td></tr></table></figure>





<ul>
<li>trimLeft()<ul>
<li>清理字符串和左边双引号中间的空格</li>
</ul>
</li>
<li>trimRight()<ul>
<li>清理字符串和右边双引号之间的空格</li>
</ul>
</li>
</ul>
<h4 id="2-7-6-repeat-方法"><a href="#2-7-6-repeat-方法" class="headerlink" title="2.7.6 repeat()方法"></a>2.7.6 repeat()方法</h4><p>将这个字符串重复多遍(具体多少遍由你来决定),然后拼接.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot; very &quot;</span>;<span class="comment">// I am  very  very  very    prettyconsole.log(&quot;I am &quot; + str.repeat(3) + &quot;   pretty&quot;);</span></span><br></pre></td></tr></table></figure>





<h4 id="2-7-7-复制字符串"><a href="#2-7-7-复制字符串" class="headerlink" title="2.7.7 复制字符串"></a>2.7.7 复制字符串</h4><p><code>padStart()</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld&quot;</span>;<span class="comment">// 指定长度小于要复制的字符串长度// 就会无视指定长度,直接复制整个字符串// 输出 helloworldconsole.log(str.padStart(5));// 指定长度大于字符串长度// 那么就在开头默认填充空格// 输出                helloworld console.log(str.padStart(35));/* 可以指定填充符号 *///**********helloworldconsole.log(str.padStart(20),&quot;*&quot;);</span></span><br></pre></td></tr></table></figure>



<p><code>padEnd()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;helloworld&quot;</span>;<span class="comment">// 指定长度小于要复制的字符串长度// 就会无视指定长度,直接复制整个字符串// 输出 helloworldconsole.log(str.padEnd(5));// 指定长度大于字符串长度// 那么就在结尾默认填充空格// 输出helloworld                 console.log(str.padEnd(35));/* 可以指定填充符号 */// helloworld**********console.log(str.padEnd(20, &quot;*&quot;));</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-8-字符串大小写"><a href="#2-7-8-字符串大小写" class="headerlink" title="2.7.8 字符串大小写"></a>2.7.8 字符串大小写</h4><p>包括4个方法：</p>
<p>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</p>
<p>toLowerCase() 和 toUpperCase()方法是原来就有的方法，与java.lang.String中的方法同名。</p>
<p>toLocaleLowerCase()和toLocaleUpperCase()方法旨在基于特定地区实现。</p>
<p>在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语）,Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换</p>
<p>通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;aBc&quot;</span>;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(message.toLowerCase());</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(message.toLocaleLowerCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ABC</span></span><br><span class="line"><span class="built_in">console</span>.log(message.toUpperCase());</span><br><span class="line"><span class="comment">// ABC</span></span><br><span class="line"><span class="built_in">console</span>.log(message.toLocaleUpperCase());</span><br></pre></td></tr></table></figure>







<h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3. 对象"></a>3. 对象</h2><h3 id="3-1-对象语法"><a href="#3-1-对象语法" class="headerlink" title="3.1 对象语法"></a>3.1 对象语法</h3><p>我觉得对象有点点像C语言的结构体.</p>
<p>对象的创建:</p>
<p>成员(<strong>键值</strong>)之间逗号隔开,最后结尾不用逗号.</p>
<p><strong>所有成员名(也就是键名)书写时尽量符合标识符命名规则.</strong><br>如果不符合,比如 <code>11a</code> ,那么久必须用单引号包括起来才不会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> this_is_me = &#123;</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">168.00</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">166.00</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;中国第一丑男&#x27;</span>,</span><br><span class="line">    <span class="attr">salary</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;11a&#x27;</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所有的键名都是字符串,哪怕你写数值都会转化成字符串.</p>
<p>每一个键值除了时单纯的值之外,还可以是函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<p><strong>除了是函数外,还可以是另一个对象,这样就形成了链式引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj_1 = &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_2 = &#123;</span><br><span class="line">   <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">   <span class="attr">p</span>: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态创建属性,不必再对象中声明</span></span><br><span class="line">obj_1.foo_1 = obj_2;</span><br><span class="line"><span class="comment">// 输出指向的对象成员 &#123;bar: &quot;hello&quot;, p: 100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1.foo_1);</span><br><span class="line"></span><br><span class="line">obj_1.foo_2 = obj_2.bar;</span><br><span class="line"><span class="comment">// 输出指向的obj_2中bar的值 hello</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1.foo_2);</span><br></pre></td></tr></table></figure>



<h3 id="3-2-对象的引用"><a href="#3-2-对象的引用" class="headerlink" title="3.2 对象的引用"></a>3.2 对象的引用</h3><p>看下面代码,可以了解到如下知识点.</p>
<ul>
<li>不同变量名指向同一个对象,其中任何一个变量名修改对象成员的值,另一个对象都会被影响.</li>
<li>不同比变量名指向同一对象,其中一个取消对原对象的引用,不会影响到另一对象对原对象的引用.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj_1 = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;helloworld&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_2 = &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;name: &quot;helloworld&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1);</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将obj_2指向obj_1</span></span><br><span class="line">obj_2 = obj_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;name: &quot;helloworld&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1);</span><br><span class="line"><span class="comment">// &#123;name: &quot;helloworld&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_2);</span><br><span class="line"><span class="comment">/*--------------分割线--------------*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">obj_1和obj_2都指向同意地址,这时任何一个对象修改其值,</span></span><br><span class="line"><span class="comment">都会影响到另一个对象.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">obj_1.age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 输出 20</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_2.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   此时,取消一个变量对原对象的引用</span></span><br><span class="line"><span class="comment">   则不会影响到另一个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_3 = &#123;&#125;;</span><br><span class="line">obj_1 = obj_3;</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_1);</span><br><span class="line"><span class="comment">// &#123;name: &quot;helloworld&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj_2);</span><br></pre></td></tr></table></figure>



<h3 id="3-3-JavaScript区分对象的表达式和语句"><a href="#3-3-JavaScript区分对象的表达式和语句" class="headerlink" title="3.3  JavaScript区分对象的表达式和语句"></a>3.3  JavaScript区分对象的表达式和语句</h3><p>比如有下面代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">foo</span> : <span class="number">233</span>&#125;</span><br></pre></td></tr></table></figure>

<p>那么JavaScript如何知道这是一个带有大括号的语句还是对象的表达式呢?</p>
<p>所以<strong>JavaScript中像这种情况,它会一律视为带有代码块语句</strong>.</p>
<p>有时候我们想这么写,又想被JavaScript识别成对象的表达式,那我们怎么办?</p>
<p>我们想到一个 <code>()</code> ,原因很简单,<strong>小括号中只能是表达式</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;<span class="attr">foo</span>: <span class="number">233</span>&#125;)  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-属性的读取"><a href="#3-4-属性的读取" class="headerlink" title="3.4 属性的读取"></a>3.4 属性的读取</h3><ul>
<li>对象键名引用的两种方法</li>
<li>数值键名不能用小数点引用</li>
<li>符合标识符规范的键名,用方括号引用的时候需要加单引号,否则会被视为变量名使用.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hehe = <span class="string">&#x27;bar&#x27;</span>;<span class="keyword">var</span> obg = &#123;   <span class="number">111</span>: <span class="number">100</span>,   <span class="number">0.7</span>: <span class="number">700</span>,   <span class="attr">hehe</span>: <span class="number">10</span>,   <span class="attr">bar</span>: <span class="number">20</span>,&#125;<span class="comment">// 引用既可以用小数点也可以用方括号console.log(obg.hehe);  //10 console.log(obg[111]);  //100/* 符合标识符的键名,用方括号时,需要打单引号否则将会被视为变量来使用*/console.log(obg[hehe]);       // 20console.log(obg[&#x27;hehe&#x27;]);      // 10/*数值的键名使用方括号的时候可以不打单引号但是数值的键名不能使用小数点引用原因是数值会自动转化成字符串 */// console.log(obg.111);  &gt;&gt;&gt;  报错console.log(obg[111]);      // 10</span></span><br></pre></td></tr></table></figure>



<p><strong>使用小数点和方括号运算符,不仅仅可以用来读取数值,还可以用来赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hehe = <span class="string">&#x27;bar&#x27;</span>;<span class="keyword">var</span> obg = &#123;   <span class="number">111</span>: <span class="number">100</span>,   <span class="number">0.7</span>: <span class="number">700</span>,   <span class="attr">hehe</span>: <span class="number">10</span>,   <span class="attr">bar</span>: <span class="number">20</span>,&#125;<span class="comment">// &#123;111: 100, 0.7: 700, hehe: 10, bar: 20&#125;console.log(obg);obg.foo1 = &#x27;hello&#x27;;// &#123;111: 100, 0.7: 700, hehe: 10, bar: 20, foo1: &quot;hello&quot;&#125;console.log(obg);obg[&#x27;foo2&#x27;] = &#x27;world&#x27;;// &#123;111: 100, 0.7: 700, hehe: 10, bar: 20, foo1: &quot;hello&quot;, foo2: &quot;world&quot;&#125;console.log(obg);</span></span><br></pre></td></tr></table></figure>



<h3 id="3-5-属性的操作"><a href="#3-5-属性的操作" class="headerlink" title="3.5 属性的操作"></a>3.5 属性的操作</h3><h4 id="1-属性的查看"><a href="#1-属性的查看" class="headerlink" title="1. 属性的查看"></a>1. 属性的查看</h4><p>使用 <code>Object.keys()</code>方法可以查看一个对象的所有键名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obg = &#123;   <span class="number">111</span>: <span class="number">100</span>,   <span class="number">0.7</span>: <span class="number">700</span>,   <span class="attr">hehe</span>: <span class="number">10</span>,   <span class="attr">bar</span>: <span class="number">20</span>,&#125;<span class="comment">// (4) [&quot;111&quot;, &quot;0.7&quot;, &quot;hehe&quot;, &quot;bar&quot;]console.log(Object.keys(obg));</span></span><br></pre></td></tr></table></figure>





<h4 id="2-属性的删除"><a href="#2-属性的删除" class="headerlink" title="2. 属性的删除"></a>2. 属性的删除</h4><p>删除直接名delete命令,就可以删除,</p>
<p>使用delete命令删除成功后返回true</p>
<p><strong>删除成功后再访问被删除的属性,就会返回undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obg = &#123;   <span class="number">111</span>: <span class="number">100</span>,   <span class="number">0.7</span>: <span class="number">700</span>,   <span class="attr">hehe</span>: <span class="number">10</span>,   <span class="attr">bar</span>: <span class="number">20</span>,&#125;<span class="comment">// (4) [&quot;111&quot;, &quot;0.7&quot;, &quot;hehe&quot;, &quot;bar&quot;]console.log(Object.keys(obg));// trueconsole.log(delete obg.hehe);// (4) [&quot;111&quot;, &quot;0.7&quot;, &quot;bar&quot;]console.log(Object.keys(obg));//访问被删除的属性返回undefinedconsole.log(obg.hehe);</span></span><br></pre></td></tr></table></figure>



<p><strong>注意删除一个不存在的属性,delete不报错,同样返回true</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obg = &#123;   <span class="number">111</span>: <span class="number">100</span>,   <span class="number">0.7</span>: <span class="number">700</span>,   <span class="attr">hehe</span>: <span class="number">10</span>,   <span class="attr">bar</span>: <span class="number">20</span>,&#125;<span class="comment">// 删除不存在属性同样返回trueconsole.log(delete obg.aaa);</span></span><br></pre></td></tr></table></figure>



<p><strong>只有当删除某条属性时,这条属性不可被删除,则会返回false.</strong></p>
<p>delete命令只能删除属于当前对象或者数组的的属性,该属性的子类等等不属于被删除的对象或者数组的属性是不可以删除的.</p>
<p>同样,有时候特殊情况delete返回true,被删除的属性值依旧可以被调用.</p>
<h4 id="3-属性是否存在"><a href="#3-属性是否存在" class="headerlink" title="3. 属性是否存在"></a>3. 属性是否存在</h4><p>使用 <code>in运算符</code> 可以勘察对象中是否包含某一键名.</p>
<p>语法格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;键名&#x27;</span> <span class="keyword">in</span> 对象名<span class="comment">/*	如果包含就返回true	如果不包含就返回false*/</span></span><br></pre></td></tr></table></figure>



<p>但是<code>in运算符</code>有个问题,不能识别该属性时属于该对象的属性,还是该对象的属性的子属性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obg = &#123;   <span class="number">111</span>: <span class="number">100</span>,   <span class="number">0.7</span>: <span class="number">700</span>,   <span class="attr">hehe</span>: <span class="number">10</span>,   <span class="attr">bar</span>: <span class="number">20</span>,&#125;<span class="comment">// 返回 trueconsole.log(&#x27;toString&#x27; in obg);</span></span><br></pre></td></tr></table></figure>

<p><code>toString</code> 这个方法,是属于默认继承object对象,但是我们创建的obg对象本身并没有创建<code>toString</code>这个对象属性.</p>
<p>这个时候可以使用<code>hasOwnProperty</code>方法判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obg) &#123;   <span class="comment">// false   console.log(obg.hasOwnProperty(&#x27;toString&#x27;));&#125;</span></span><br></pre></td></tr></table></figure>



<p>当我们遍历一个对象时,for循环除了遍历该对象的属性,该对象属性的子属性再<strong>一些情况</strong>下也会遍历出来,我们可以搭配<code>hasOwnProperty</code>这个方法遍历出只属于该对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obg) &#123;   <span class="keyword">if</span> (obg.hasOwnProperty(key)) &#123;      <span class="built_in">console</span>.log(key);   &#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-with语句"><a href="#4-with语句" class="headerlink" title="4.with语句"></a>4.with语句</h4><p>with语句是操作同一个对象的多个属性提供便捷的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with(对象)&#123;	语句;&#125;</span><br></pre></td></tr></table></figure>

<p>看如下使用例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一var obj = &#123;  p1: 1,  p2: 2,&#125;;with (obj) &#123;  p1 = 4;  p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123;  console.log(href);  console.log(title);  console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style);</span></span><br></pre></td></tr></table></figure>



<p><strong>注意,使用with区块内部进行变量的赋值操作,必须是已经存在的对象属性,否则with会创建一个全局变量.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obg = &#123;   <span class="attr">targe</span>: <span class="number">10</span>,   <span class="attr">bear</span>: <span class="number">20</span>&#125;;<span class="keyword">with</span> (obg) &#123;   p1 = <span class="number">10</span>;   heheda = <span class="string">&#x27;hello&#x27;</span>;&#125;<span class="comment">//undefinedconsole.log(obg.p1);//  10console.log(p1);// undefinedconsole.log(obg[&#x27;heheda&#x27;]);// helloconsole.log(heheda);</span></span><br></pre></td></tr></table></figure>









<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="4-1-函数介绍"><a href="#4-1-函数介绍" class="headerlink" title="4.1 函数介绍"></a>4.1 函数介绍</h3><p>函数语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name</span>(<span class="params">parameter...</span>)</span>&#123;    balabala...    retune 返回值&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数多次声明</strong></p>
<p>当同意函数被多次声明,后面声明的函数会覆盖掉前面声明的函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_one</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;我是第一函数&#x27;</span>);&#125;<span class="function"><span class="keyword">function</span> <span class="title">fun_two</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;我是第二函数&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第一等公民</strong></p>
<p>JavaScript中将函数视作一种值而已,它和数值,字符串,布尔值地位效率沟通,也正是这样,像下文就有用变量声明函数,像对象里面可以有函数,像把函数作为参数传到另一个函数…等等</p>
<p>比如将函数作为参数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_one</span>(<span class="params">x, y</span>) </span>&#123;   <span class="keyword">return</span> x + y;&#125;<span class="function"><span class="keyword">function</span> <span class="title">fun_two</span>(<span class="params">result</span>) </span>&#123;   <span class="keyword">return</span> result;&#125;<span class="comment">// 将函数作为参数,并将返回值赋值给一个变量var print_result = fun_two(fun_one)(5, 20);// 输出 25 console.log(print_result);</span></span><br></pre></td></tr></table></figure>





<p><strong>return语句</strong></p>
<p>当函数运行到return语句的时候,便是返回,哪怕后面还有语句也将不会再执行.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_two</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;我再return之前&#x27;</span>);    <span class="keyword">return</span> <span class="number">0</span>;    <span class="built_in">console</span>.log(<span class="string">&#x27;我再return之后&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-变量声明函数"><a href="#4-2-变量声明函数" class="headerlink" title="4.2 变量声明函数"></a>4.2 变量声明函数</h3><p>如果使用变量声明函数,则该函数后面一般不带函数名,因为带了也不能使用该函数名而调用函数,倒是可以使用变量名来使用函数.</p>
<p>如下例fun_name就不能直接调用,但是它可以再函数中使用,代指的就是该函数本身.</p>
<p>注意,使用变量声明函数,结尾最好用分号结束.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> printf = <span class="function"><span class="keyword">function</span> <span class="title">fun_name</span>(<span class="params"></span>) </span>&#123;   <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);&#125;;<span class="comment">// 使用这个函数名调用报错.// fun_name();// 但是使用方法名却可以输出hello worldprintf();</span></span><br></pre></td></tr></table></figure>





<h3 id="4-3-Function构造函数"><a href="#4-3-Function构造函数" class="headerlink" title="4.3  Function构造函数"></a>4.3  Function构造函数</h3><p>第三种声明函数的方式是<code>Function</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(  <span class="string">&#x27;x&#x27;</span>,  <span class="string">&#x27;y&#x27;</span>,  <span class="string">&#x27;return x + y&#x27;</span>);<span class="comment">// 等同于function add(x, y) &#123;  return x + y;&#125;</span></span><br></pre></td></tr></table></figure>



<p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数。</p>
<p><strong>你可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Function</span>(  <span class="string">&#x27;return &quot;hello world&quot;;&#x27;</span>);<span class="comment">// 等同于function foo() &#123;  return &#x27;hello world&#x27;;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样。</p>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用。</p>
<h3 id="4-4-函数名提升"><a href="#4-4-函数名提升" class="headerlink" title="4.4 函数名提升"></a>4.4 函数名提升</h3><p>之前我们是又学到过变量名提升这一知识点,同样函数名和声明变量名一样会被提升.</p>
<p>以下代码不会报错,哪怕再函数声明前使用函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print_result = fun_one(<span class="number">5</span>, <span class="number">20</span>);<span class="built_in">console</span>.log(print_result);<span class="function"><span class="keyword">function</span> <span class="title">fun_one</span>(<span class="params">x, y</span>) </span>&#123;   <span class="keyword">return</span> x + y;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>变量函数声明和函数声明同时声明,将采用变量函数声明.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);&#125;<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);&#125;f() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>





<h3 id="4-5-函数属性和方法"><a href="#4-5-函数属性和方法" class="headerlink" title="4.5 函数属性和方法"></a>4.5 函数属性和方法</h3><h4 id="1-name属性"><a href="#1-name属性" class="headerlink" title="1. name属性"></a>1. name属性</h4><p>用来防护函数名的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name1</span>(<span class="params"></span>) </span>&#123; &#125;<span class="built_in">console</span>.log(fun_name1.name);<span class="keyword">var</span> fun_name2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;<span class="built_in">console</span>.log(fun_name2.name);</span><br></pre></td></tr></table></figure>



<p>特殊一点</p>
<p>以下情况虽然返回fake_name,但实际情况fun_name3才是这个函数的实际名字,使用时依旧是书写fun_name3这一函数名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun_name3 = <span class="function"><span class="keyword">function</span> <span class="title">fake_name</span>(<span class="params"></span>) </span>&#123; &#125;;<span class="built_in">console</span>.log(fun_name2.name);</span><br></pre></td></tr></table></figure>





<h4 id="2-length属性"><a href="#2-length属性" class="headerlink" title="2. length属性"></a>2. length属性</h4><p>用来返回函数参数个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b,c</span>)</span>&#123;&#125;;<span class="comment">// 3个参数fun.length;</span></span><br></pre></td></tr></table></figure>





<h4 id="3-toString"><a href="#3-toString" class="headerlink" title="3. toString()"></a>3. toString()</h4><p>返回一个字符串,内容是函数的源码,包括函数内部的注释和换行符.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun(x, y) &#123;   /*       这是让两个数相加的函数   */   return x + y;&#125;;console.log(fun.toString());</span><br></pre></td></tr></table></figure>





<h3 id="4-6-函数作用域"><a href="#4-6-函数作用域" class="headerlink" title="4.6 函数作用域"></a>4.6 函数作用域</h3><ul>
<li>全部作用域<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>ES6新增的块级作用域</li>
</ul>
</li>
</ul>
<p>在函数域中声明一个变量,外部访问不了.</p>
<p>所以局部变量一般是再函数累声明,我们前面学到了的,再块中用var声明量一律都是全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">100</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;   <span class="keyword">var</span> c = <span class="number">10</span>;   <span class="keyword">return</span> c;&#125;;<span class="keyword">var</span> b = fun();<span class="comment">// 输出100console.log(c);// 输出 10console.log(b);</span></span><br></pre></td></tr></table></figure>



<p>函数域内部依旧是拥有变量提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;  &#125;&#125;<span class="comment">// 等同于function foo(x) &#123;  var tmp;  if (x &gt; 100) &#123;    tmp = x - 100;  &#125;;&#125;</span></span><br></pre></td></tr></table></figure>



<p>同样下面例子证明函数域内部和外部一样,有着变量提升.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefinedvar a = 100;console.log(a);  //100function fun_b() &#123;   console.log(b);  //undefined   var b = 200;   console.log(b);  //200&#125;fun_b();</span></span><br></pre></td></tr></table></figure>



<h3 id="4-7-函数参数"><a href="#4-7-函数参数" class="headerlink" title="4.7 函数参数"></a>4.7 函数参数</h3><h4 id="1-函数参数简介"><a href="#1-函数参数简介" class="headerlink" title="1. 函数参数简介"></a>1. 函数参数简介</h4><p>JavaScript中函数明明规定了形参,但是使用时没有传入参数并不会报错.</p>
<p><strong>JavaScript中函数可以省略参数,没有写的参数子自动编程undefined.</strong></p>
<p>但是函数的length属性和实际传入的参数无关</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a , b , c</span>) </span>&#123;    <span class="built_in">console</span>.log(a);      <span class="built_in">console</span>.log(b);    <span class="built_in">console</span>.log(c);&#125;<span class="comment">// 输出 1 2 undefinedfunction(1,2);</span></span><br></pre></td></tr></table></figure>



<p>如果我们实在是想省略前面的参数,而传入后面的参数呢?</p>
<p>只能将前面的参数手动传入undefined,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a , b , c</span>) </span>&#123;    <span class="built_in">console</span>.log(a);      <span class="built_in">console</span>.log(b);    <span class="built_in">console</span>.log(c);&#125;<span class="comment">// 输出 undefined 1 2 function(undefined,1,2);</span></span><br></pre></td></tr></table></figure>



<h4 id="2-函数参数传递方式"><a href="#2-函数参数传递方式" class="headerlink" title="2. 函数参数传递方式"></a>2. 函数参数传递方式</h4><p><strong>如果是数值,字符串,布尔值这三个原始类型</strong>,那么传递方式就是<strong>传值传递</strong><br>表示着再函数内部修改这个值的数据不会影响到外部的值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;   a = a - <span class="number">80</span>;   <span class="built_in">console</span>.log(a);&#125;<span class="comment">// 输出 20fun(a);// 输出 100console.log(a);</span></span><br></pre></td></tr></table></figure>





<p><strong>如果函数的参数是符合类型的值(对象 函数 数组)</strong></p>
<p>那么传递的方式就是<strong>传址传递</strong>,就是直接指向其地址,正如C语言中我们就可以知道,如果直接指向其地址进行修改,修改的就是这个值的本身数据.</p>
<p><strong>当(对象 函数 数组)作为参数,针对其某一属性进行修改的时候会改变其值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="comment">// 输出(3)[1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 (3) [10, 2, 3]</span></span><br><span class="line">fun(a);</span><br><span class="line"><span class="comment">// 输出 (3) [10, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>





<p><strong>但是将这个参数(对象 函数 数组)整个替换掉时,这个时候就不影响原地址的值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="comment">// 输出(3)[1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">   a = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>];</span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 (3) [10, 11, 12]</span></span><br><span class="line">fun(a);</span><br><span class="line"><span class="comment">// 输出 (3) [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>



<h4 id="3-同名函数参数"><a href="#3-同名函数参数" class="headerlink" title="3. 同名函数参数"></a>3. 同名函数参数</h4><p>当一个函数参数中出现同名参数,那么就会选择<strong>后面</strong>的一个运行.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, a, c</span>) </span>&#123;   <span class="keyword">var</span> result = <span class="number">0</span>;   result = a + c;   <span class="built_in">console</span>.log(result);&#125;<span class="comment">// 输出 110fun(10, 100, 10);</span></span><br></pre></td></tr></table></figure>



<p>这里有个有趣的现象,同名的两个参数,传给前面一个值,后面一个不传值(也就是undefined)</p>
<p>实际运算起来依旧按照后面那个形参来.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, a</span>) </span>&#123;   <span class="built_in">console</span>.log(a);&#125;<span class="comment">// 输出 undefinedfun(10);</span></span><br></pre></td></tr></table></figure>

<p>上面代码,明明给前面的a穿了值10,但是实际代码运行的时候依旧输出了a为undefined.</p>
<p>这个时候如果想获取第一个a 的值运行,那就可以<strong>使用arguments对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>



<h3 id="4-8-arguments-对象"><a href="#4-8-arguments-对象" class="headerlink" title="4.8 arguments 对象"></a>4.8 arguments 对象</h3><p><strong>arguments对象 可以再函数内部读取多有参数</strong></p>
<p>也就是说arguments包含一个函数运行时的所有参数,arguments[0]就时第一个参数,arguments[1]则是第二个参数,以此类推.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a, b, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 10</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// 11</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// 12</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">3</span>]); <span class="comment">// 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>



<p>再调用arguments这个对象时,可以再运行时修改其值,但是开启<strong>严格模式</strong>后对于实际的参数值(可以理解为实际arguments地址上的值)不会有任何改变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 3 是因为没有开启严格模式</span></span><br><span class="line"><span class="built_in">console</span>.log(fun(<span class="number">10</span>, <span class="number">11</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------开启严格模式-----------//</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">   &#x27;use strict&#x27;</span>; <span class="comment">// 开启严格模式</span></span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个时候输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>



<p>一般可以对arguments对象使用length属性,来判断到底有多少参数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-9-闭包-难点"><a href="#4-9-闭包-难点" class="headerlink" title="4.9 闭包[难点!]"></a>4.9 闭包[难点!]</h3><p>首先我们得知道基本知识.</p>
<p>函数的内部可以访问外面得全局变量,但是外部访问不到函数内部得变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parameter = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> fun_parameter = <span class="number">100</span>;</span><br><span class="line">   <span class="comment">// 内部可以访问外部</span></span><br><span class="line">   <span class="built_in">console</span>.log(parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是外部不能够访问内部</span></span><br><span class="line"><span class="comment">// console.log(fun_parameter); 报错</span></span><br></pre></td></tr></table></figure>



<p>但是我们就是想访问函数内部的变量怎么办?</p>
<p>再函数内部再创建一个函数,把这个函数作为返回值,这样就可以访问某一函数内部的变量,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parameter = <span class="number">200</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;   <span class="keyword">var</span> fun_parameter = <span class="number">100</span>;   <span class="comment">// 内部可以访问外部   console.log(parameter);   function fun_son() &#123;      console.log(fun_parameter);   &#125;   // 将内部函数作为返回值 返回   return fun_son;&#125;var visit = fun();// 这样就可以得到fun_parameter的数据了visit();</span></span><br></pre></td></tr></table></figure>

<p>在上面这一段代码中,闭包的就是fun_son这一函数.</p>
<p>本质上闭包就是将一个函数内部和函数外部链接起来的一个桥梁.</p>
<p>闭包最大的用处</p>
<ol>
<li>可以从外部读取一个函数内部的变量.</li>
<li>让这些变量始终保存在内存中.</li>
</ol>
<p>这个始终保持在内存中可以看如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fun_son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> start++;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> visit = fun(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(visit()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(visit()); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(visit()); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(visit()); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(visit()); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>



<p><em><strong>封装对象私有属性.</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> _age;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      _age = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: name,</span><br><span class="line">      <span class="attr">getAge</span>: getAge,</span><br><span class="line">      <span class="attr">setAge</span>: setAge</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line"><span class="comment">// 输出 25</span></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="comment">// &#123;name: &quot;张三&quot;, getAge: ƒ, setAge: ƒ&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.getAge());</span><br></pre></td></tr></table></figure>



<h3 id="创建完函数后立即调用函数的表达式"><a href="#创建完函数后立即调用函数的表达式" class="headerlink" title="创建完函数后立即调用函数的表达式"></a>创建完函数后立即调用函数的表达式</h3><p>我们一般调用函数都是在函数创建完后,然后函数名+()进行调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">name</span>) </span>&#123;   <span class="built_in">console</span>.log(<span class="string">&#x27;你好啊&#x27;</span> + name);&#125;<span class="comment">// 形成调用fun();// 形成调用var a = fun();</span></span><br></pre></td></tr></table></figure>



<p><strong>上面代码第二个之所以能够调用,是因为JavaScript中function出现在行首才会被视为函数,如果不是在行首,就会被视为表达式.</strong></p>
<p>所以作为<strong>表达式</strong>的时候,可以直接<strong>末尾添加圆括号调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;   <span class="keyword">var</span> a = <span class="number">100</span>;   <span class="keyword">var</span> b = <span class="number">200</span>;   <span class="comment">// 输出表明这时候直接调用   console.log(&#x27;helloworld&#x27;);   return a + b;&#125;();console.log(f);</span></span><br></pre></td></tr></table></figure>



<p>同样基于上面的理解,只要函数被理解成表达式,那么就可以末尾加圆括号直接调用.</p>
<p><strong>那么不正好有圆括号里面一般只能放表达式嘛</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function f() &#123;   // 输出helloworld   console.log(&#x27;helloworld&#x27;);&#125;())</span><br></pre></td></tr></table></figure>

<p>除了使用圆括号不让function被理解成函数,还可以用以下方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();<span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();<span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();-<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>



<p>一般情况下支队匿名函数使用这种<strong>立即调用的方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二 避免污染全局变量(function () &#123;  var tmp = newData;  processData(tmp);  storeData(tmp);&#125;());</span></span><br></pre></td></tr></table></figure>







<h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>
<p><code>eval()</code> 解析的变量和函数都不会提升,因为他们本身是放在一个字符串中的,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a = 100;&#x27;</span>);<span class="comment">// 输出 100console.log(a);// 如果不能作为语句执行就会报错// eval(&#x27;ssa4654&#x27;);// 报错// 如果参数不是字符串,原样返回var b = eval(100000);// 输出 100000console.log(b);// eval没有自己作用域,就是在当前作用域运行// 所以可以修改当前作用域变量的值.var c = 10;eval(&#x27;c = 100;&#x27;);// 输出 100console.log(c);</span></span><br></pre></td></tr></table></figure>



<p>可以在一个函数域中使用严格模式,这样eval修改的值,就不会影响到外面.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">100</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 使用严格模式   &#x27;use strict&#x27;;   eval(&#x27;var foo = 123&#x27;);   // 输出 100   console.log(foo);&#125;fun();</span></span><br></pre></td></tr></table></figure>







<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">eval</span>;m(<span class="string">&#x27;var x = 1&#x27;</span>);x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令。</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">var</span> a = <span class="number">2</span>;  <span class="keyword">var</span> e = <span class="built_in">eval</span>;  e(<span class="string">&#x27;console.log(a)&#x27;</span>);&#125;f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。</p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用。</p>
<h2 id="5-数组-array"><a href="#5-数组-array" class="headerlink" title="5. 数组(array)"></a>5. 数组(array)</h2><p>创建数组并赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];arr[<span class="number">0</span>] = <span class="number">1</span>;arr[<span class="number">1</span>] = <span class="number">2</span>;arr[<span class="number">2</span>] = <span class="number">3</span>;<span class="comment">// 输出 3 console.log(arr.length);</span></span><br></pre></td></tr></table></figure>

<p><strong>如果我直接在那个中括号中写数组长度是没有用的.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>];arr[<span class="number">0</span>] = <span class="number">1</span>;arr[<span class="number">1</span>] = <span class="number">2</span>;arr[<span class="number">2</span>] = <span class="number">3</span>;<span class="comment">// 数组长度依旧是 3 console.log(arr.length);</span></span><br></pre></td></tr></table></figure>



<p><strong>数组中可以时任何类型的数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;];arr[<span class="number">0</span>] <span class="comment">// Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>如果数组元素依旧是数组,就形成多维数组.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];a[<span class="number">0</span>][<span class="number">1</span>] <span class="comment">// 2a[1][1] // 4</span></span><br></pre></td></tr></table></figure>



<h3 id="5-1-数组的本质"><a href="#5-1-数组的本质" class="headerlink" title="5.1 数组的本质"></a>5.1 数组的本质</h3><p><strong>数组的本质其实是一个特殊的对象.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];arr[<span class="number">0</span>] = <span class="number">1</span>;arr[<span class="number">1</span>] = <span class="number">2</span>;arr[<span class="number">2</span>] = <span class="number">3</span>;<span class="comment">// 返回objectconsole.log(typeof (arr));</span></span><br></pre></td></tr></table></figure>



<p>说明数组具有对象所有的特性,只不过数组的键名是固定的数字(0,1,2…).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];arr[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 依旧会转换字符串,所以可以.arr[1.00] = 2;// 直接打引号注明字符串arr[&#x27;2&#x27;] = 3;// 输出成功 (3) [1, 2, 3]console.log(arr);</span></span><br></pre></td></tr></table></figure>



<p>同样可以使用针对对象的 <code>Object.keys</code>方法来返回键名.来证明键名是固定的数字.<br>所以创建数组这个特殊对象的时候不用为数组创建每一个键名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];<span class="built_in">Object</span>.keys(arr)<span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>



<p>正因为数组是特殊对象,键名都是数字,所以如果使用<code>arr.0</code>的写法是错误的,所以只能够使用<code>arr[0]</code>带方括号的写法.</p>
<h3 id="5-2-length属性"><a href="#5-2-length属性" class="headerlink" title="5.2 length属性"></a>5.2 length属性</h3><p>和Java还有C语言一样,数组的长度总是比最大的键名的那个值大一.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// 输出数组长度 5console.log(arr.length);</span></span><br></pre></td></tr></table></figure>



<p>数组是动态的,可以不断添加元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// 输出数组长度 5console.log(arr.length);arr[5] = 6;// 输出数组长度为 6console.log(arr.length);</span></span><br></pre></td></tr></table></figure>



<p>同样我们可以定死length长度;</p>
<p>定死长度后,超出数组长度的数据就自动被删除了.</p>
<p>如果设定数组长度大于本身数组,那么多出来的数字下标对应的值就是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// 输出数组长度 5console.log(arr.length);arr[5] = 6;// 输出数组长度为 6console.log(arr.length);arr.length = 3;// 只有 [1, 2, 3]console.log(arr);arr.length = 10;// 控制台输出 (10) [1, 2, 3, empty × 7]console.log(arr);// 输出undefinedconsole.log(arr[9]);</span></span><br></pre></td></tr></table></figure>



<p>如果我们将length设置不适合的值,就会报错.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &#x27;abc&#x27;// RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>





<p><strong>我们如果想快速清空一个数组里面的数据,只用将数组长度定位0即可</strong></p>
<p>再次因为数组其实是对象,所以可以使用对象添加键名的方法来添加属性,但是添加的属性如果不是正整数是不会影响到数组length的值的.</p>
<p>见如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// 输出数组长度 5console.log(arr.length);arr[&#x27;pp&#x27;] = 100;// 输出数组长度 5console.log(arr.length);arr[2.1] = 200;// 输出数组长度 5console.log(arr.length);/*但是如果打印,会发现实际数据是添加进去了的(5) [1, 2, 3, 4, 5, pp: 100, 2.1: 200]*/console.log(arr);</span></span><br></pre></td></tr></table></figure>



<p>同样,添加的键名不合法,会被视为字符串被length忽视.<br>但是使用这些不是数字的键名调用依旧可以调出数据,充分证明数组下标在使用的时候是先转化成字符串的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// 输出数组长度 5console.log(arr.length);arr[-1] = 100;// 输出数组长度 5console.log(arr.length);arr[Math.pow(2, 32)] = 200;// 输出数组长度 5console.log(arr.length);/*但是如果打印,会发现实际数据是添加进去了的(5) [1, 2, 3, 4, 5, -1: 100, 4294967296: 200]*/// 输出 100console.log(arr[-1]);// 输出 200console.log(arr[Math.pow(2, 32)]);</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-in运算符"><a href="#5-3-in运算符" class="headerlink" title="5.3   in运算符"></a>5.3   in运算符</h3><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];<span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true&#x27;2&#x27; in arr // true4 in arr // false</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];arr[<span class="number">100</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="number">100</span> <span class="keyword">in</span> arr <span class="comment">// true1 in arr // false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p>
<h3 id="5-4-遍历数组"><a href="#5-4-遍历数组" class="headerlink" title="5.4 遍历数组"></a>5.4 遍历数组</h3><p><strong>下面是遍历数组三种简单写法.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">// for循环for(var i = 0; i &lt; a.length; i++) &#123;  console.log(a[i]);&#125;// for循环配合 in运算符var a = [1, 2, 3];a.foo = true;// 使用 in遍历还会遍历出键名是字符串的成员.for (var key in a) &#123;  console.log(key);&#125;// while循环var i = 0;while (i &lt; a.length) &#123;  console.log(a[i]);  i++;&#125;// 逆向遍历var l = a.length;while (l--) &#123;  console.log(a[l]);&#125;</span></span><br></pre></td></tr></table></figure>





<h3 id="5-5-数组的空位"><a href="#5-5-数组的空位" class="headerlink" title="5.5 数组的空位"></a>5.5 数组的空位</h3><p>数组中间的某一位置可以空出来,这叫做数组的空位</p>
<p>那么最后一个元素后面加一个逗号,会不会就是把最后一个位置空着在呢?<br>答案是 &gt;&gt; <strong>最后一个元素后面有逗号不影响数组长度</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 末尾加逗号var arr1 = [1, 2, , 4,];// 末尾不加逗号var arr2 = [1, 2, , 4];// 下面两个都是输出长度为 4 console.log(arr1.length);console.log(arr2.length);</span></span><br></pre></td></tr></table></figure>



<p>数组的空位是可以读取的,结果就是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>];<span class="comment">// 输出undefinedconsole.log(arr2[2]);</span></span><br></pre></td></tr></table></figure>



<p>使用delete命令删除一个数组元素会形成空位,但是不影响lengt的值<br>也就是说一个长度为3的数组,使用delete命令删除一个成员之后,形成空位,它的长度依旧是3</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="keyword">delete</span> arr2[<span class="number">0</span>];<span class="comment">// 空位 输出undefinedconsole.log(arr2[0]);// 依旧输出长度为 4console.log(arr2.length);</span></span><br></pre></td></tr></table></figure>





<p><strong>正因为length属性不会过滤掉空位,所以使用length属性遍历数组的时候一定小心</strong></p>
<p>一个数组的空位调用时候是undefined,一个数组的元素的值是undefined,这两个虽说都是undefined,但是实际运用中是不一样的,尤其是在遍历一个数组的时候.</p>
<p><strong>遍历时空位会被跳过,但是数值是undefined则不会被跳过.</strong></p>
<p>举个例子,见如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];<span class="comment">// 不会输出结果,跳过空位for (var i in a) &#123;   console.log(i);&#125;console.log(Object.keys(a));</span></span><br></pre></td></tr></table></figure>



<p><strong>但是如果值为undefined,则不会跳过</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];<span class="comment">// 输出 0 1 2 (下标)for (var i in a) &#123;   console.log(i);&#125;console.log(Object.keys(a));</span></span><br></pre></td></tr></table></figure>





<h3 id="5-6类似数组的对象"><a href="#5-6类似数组的对象" class="headerlink" title="5.6类似数组的对象"></a>5.6类似数组的对象</h3><p>既然数组本质上其实是一个特殊的对象<br>那么一个对象如果键名都是正整数或者0,那么是否表示这个对象就是数组?<br>答 : <strong>这个类似数组的对象并不是数组,因为它没有数组的一些特有的方法,比如push方法,数组调用就不会报错,但是对象调用就会报错.</strong></p>
<p>正因为它不能是数组,像这类的对象就称为<strong>类似数组的对象</strong>.</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;  <span class="attr">length</span>: <span class="number">0</span>&#125;;obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;obj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>





<p>如果想这个类似数组的对象使用数组特有的方法,除了上面先转为数组然后使用数组的方法,我们还可以使用<code>call()</code>把数组的方法放到对象上.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;  <span class="built_in">console</span>.log(index + <span class="string">&#x27; : &#x27;</span> + value);&#125;<span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>



<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 方法function logArgs() &#123;  Array.prototype.forEach.call(arguments, function (elem, i) &#123;    console.log(i + &#x27;. &#x27; + elem);  &#125;);&#125;// 等同于 for 循环function logArgs() &#123;  for (var i = 0; i &lt; arguments.length; i++) &#123;    console.log(i + &#x27;. &#x27; + arguments[i]);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>



<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">&#x27;abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;  <span class="built_in">console</span>.log(chr);&#125;);<span class="comment">// a// b// c</span></span><br></pre></td></tr></table></figure>





<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&#x27;abc&#x27;</span>);arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;  <span class="built_in">console</span>.log(chr);&#125;);<span class="comment">// a// b// c</span></span><br></pre></td></tr></table></figure>







<h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><p><strong>JavaScript基本运算符如下</strong></p>
<ul>
<li><strong>加法运算符</strong>：<code>x + y</code></li>
<li><strong>减法运算符</strong>： <code>x - y</code></li>
<li><strong>乘法运算符</strong>： <code>x * y</code></li>
<li><strong>除法运算符</strong>：<code>x / y</code></li>
<li><strong>指数运算符</strong>：<code>x ** y</code></li>
<li><strong>余数运算符</strong>：<code>x % y</code></li>
<li><strong>自增运算符</strong>：<code>++x</code> 或者 <code>x++</code></li>
<li><strong>自减运算符</strong>：<code>--x</code> 或者 <code>x--</code></li>
<li><strong>数值运算符</strong>： <code>+x</code></li>
<li><strong>负数值运算符</strong>：<code>-x</code></li>
</ul>
<h3 id="6-1-布尔值参与运算"><a href="#6-1-布尔值参与运算" class="headerlink" title="6.1  布尔值参与运算"></a>6.1  布尔值参与运算</h3><p><em>false &gt;&gt; 表示 0  true &gt;&gt; 表示 1</em></p>
<p><strong>当运算中有布尔值的时候,布尔值会先自动转成数值.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 4console.log(2 * (true + true));// 输出 0console.log(2 * false);</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-字符串相加"><a href="#6-2-字符串相加" class="headerlink" title="6.2 字符串相加"></a>6.2 字符串相加</h3><p><strong>当有字符串参与相加的时候,加号会被理解成链接符号</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abconsole.log(&#x27;a&#x27; + &#x27;b&#x27;);// a1console.log(&#x27;a&#x27; + 1);// flaseaconsole.log(false + &#x27;a&#x27;);// 1.22aconsole.log(1.22 + &#x27;a&#x27;);</span></span><br></pre></td></tr></table></figure>



<p>以上这种现象称为 ‘’重载’’(overload) , 由于<strong>只有加法存在这种现象</strong>,所以有时候你不知道它倒是是执行那种运算方法,</p>
<p><strong>比如会根据运算成员类型位置的不同而产生不同的结果.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a55console.log(&#x27;a&#x27; + 5 + 5);// 10aconsole.log(5 + 5 + &#x27;a&#x27;);</span></span><br></pre></td></tr></table></figure>



<p>其他运算符则不存在这种现象,因为他们的规则是所有参与运算的成员一律转化成数值之后再运算.</p>
<p>遇见纯字符串不能转数值的,转化成NaN,然后进行运算.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NaNconsole.log(&#x27;a&#x27; * 1);// NaNconsole.log(100 - &#x27;a&#x27;);// NaNconsole.log(100 / &#x27;a&#x27;);</span></span><br></pre></td></tr></table></figure>



<p><strong>遇见可以转为数值的,直接转为数值进行运算</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 7.5console.log(10 - &#x27;2.5&#x27;);// 25console.log(10 * &#x27;2.5&#x27;);// 4console.log(10 / &#x27;2.5&#x27;);</span></span><br></pre></td></tr></table></figure>



<h3 id="6-3-余数运算符"><a href="#6-3-余数运算符" class="headerlink" title="6.3 余数运算符"></a>6.3 余数运算符</h3><p>运算符的正负由第一个数字的符号决定</p>
<p>但是我有个疑虑,正常来说一个正数除以一个负数,或者一个负数除以一个正数,他们之间有余数这个概念嘛…..所以我还去百度了下</p>
<blockquote>
<p>其实从数学角度看,a=x<em>b+r (x为整数, 0=&lt;r&lt;b) 则 a%b=r<br>3=2</em>1+1 所以 3 % 2 = 1<br>-3=2*(-1)-1 所以-3 % 2 = -1 这里当然 也可以 -3=2*(-2)+1 也可以说-3 % 2 = 1 其实在 模 2 上,-1 可以认为是 +1 ,等效<br>3= -2*(-1)+1 所以 3 % -2 = 1<br>-3=-2<em>1-1 或者-3=-2</em>2+1 所以-3 % -2 = -1 或者-3 % -2 = 1<br>-2=3*(-1)+1 所以 -2%3=1 即3除-2的余数是 1<br>-2=-3*1+1 所以-2%-3=1 即-3除-2的余数是 1</p>
</blockquote>
<p>其实上面答案我也看不太懂,但是我觉得知道这个机制就行,开发中应该不常见.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2console.log(10 % -8);// -2console.log(-10 % 8);</span></span><br></pre></td></tr></table></figure>



<p>我们可以使用<code>Math.asb()</code>方法来得到绝对值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2console.log(10 % -8);// 使用绝对值方法输出 2console.log(Math.abs(-10 % 8));</span></span><br></pre></td></tr></table></figure>



<p><strong>余数运算符还可以用来计算浮点数,但是不精确</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">6.5</span> % <span class="number">2.1</span><span class="comment">// 0.19999999999999973</span></span><br></pre></td></tr></table></figure>





<h3 id="6-4-数值运算符-负值运算符"><a href="#6-4-数值运算符-负值运算符" class="headerlink" title="6.4  数值运算符,负值运算符"></a>6.4  数值运算符,负值运算符</h3><h4 id="1-数值运算符"><a href="#1-数值运算符" class="headerlink" title="1. 数值运算符"></a>1. 数值运算符</h4><p>数值运算符同样是一个加号( + ) ,但它是一元运算符(只需要一个操作数),而加法运算符是二元运算符,</p>
<p><strong>数值运算符的作用是可以将任何值转成数值(与Number函数作用相同).</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="literal">true</span> <span class="comment">// 1+[] // 0+&#123;&#125; // NaN</span></span><br></pre></td></tr></table></figure>



<h4 id="2-负值运算符"><a href="#2-负值运算符" class="headerlink" title="2. 负值运算符"></a>2. 负值运算符</h4><p>负值运算符的作用是将任何数值变成与它自身相反的符号,也就是说如果连续使用两个负值运算符那么就等同于数值运算符.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;-x <span class="comment">// -1-(-x) // 1</span></span><br></pre></td></tr></table></figure>



<h3 id="6-5-指数运算符"><a href="#6-5-指数运算符" class="headerlink" title="6.5 指数运算符"></a>6.5 指数运算符</h3><p>指数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">4</span> <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>注意，<strong>指数运算符是右结合，而不是左结合</strong>。即多个指数运算符连用时，先进行最右边的计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。</p>
<h3 id="6-6-比较运算符"><a href="#6-6-比较运算符" class="headerlink" title="6.6 比较运算符"></a>6.6 比较运算符</h3><ul>
<li><code>&gt;</code> 大于运算符</li>
<li><code>&lt;</code> 小于运算符</li>
<li><code>&lt;=</code> 小于或等于运算符</li>
<li><code>&gt;=</code> 大于或等于运算符</li>
<li><code>==</code> 相等运算符</li>
<li><code>===</code> 严格相等运算符</li>
<li><code>!=</code> 不相等运算符</li>
<li><code>!==</code> 严格不相等运算符</li>
</ul>
<h4 id="1-讲一讲字符串的比较"><a href="#1-讲一讲字符串的比较" class="headerlink" title="1.讲一讲字符串的比较"></a>1.讲一讲字符串的比较</h4><p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;dog&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;catalog&#x27;</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="string">&#x27;cat&#x27;</span> &gt; <span class="string">&#x27;Cat&#x27;</span> <span class="comment">// true&#x27;</span></span><br></pre></td></tr></table></figure>

<p>正因为比较的是Unicode码,所以汉字也是可以比较的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;大&#x27;</span> &gt; <span class="string">&#x27;小&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h4 id="2-原始类型值比较"><a href="#2-原始类型值比较" class="headerlink" title="2. 原始类型值比较"></a>2. 原始类型值比较</h4><p>字符串还有布尔值类型进行比较的时候,都会优先转化成数值(Number)然后再进行比较.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 falseconsole.log(5 &gt; &#x27;a&#x27;);// 输出 trueconsole.log(true &gt; false);// 输出 trueconsole.log(-1 &lt; false);</span></span><br></pre></td></tr></table></figure>



<p>如果是这种不能转化成一般字符的字符串<code>Number(&#39;a15&#39;)</code> 那么转化成NaN,然后和NaN进行比较.</p>
<p>上文中我有写到,NaN做布尔值的时候是false,我还以为NaN会被当做false然后在被当作0来进行比较,最后结果不是,<strong>实际是任何数和NaN比较都会返回false</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面和NaN作比较全是 falseconsole.log(5 &lt; &#x27;a15&#x27;);console.log(5 &gt; &#x27;a15&#x27;);console.log(5 == &#x27;a15&#x27;);console.log(5 === &#x27;a15&#x27;);</span></span><br></pre></td></tr></table></figure>



<p><strong>同样哪怕是NaN和NaN做比较也不行,因为NaN不等同于它本身.</strong></p>
<h4 id="3-对象的比较"><a href="#3-对象的比较" class="headerlink" title="3. 对象的比较"></a>3. 对象的比较</h4><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p>
<p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">2</span>];</span><br><span class="line">x &gt; <span class="string">&#x27;11&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">x.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> &#125;;</span><br><span class="line">x &gt; <span class="string">&#x27;11&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf() &gt; &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 即 &#x27;1&#x27; &gt; &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>



<p>两个对象之间的比较也是如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>] &gt; [<span class="number">1</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;1&#x27; </span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] &gt; [<span class="number">11</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">2</span> &#125; &gt;= &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 &#x27;[object Object]&#x27; &gt;= &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="6-7-相等和严格相等"><a href="#6-7-相等和严格相等" class="headerlink" title="6.7 相等和严格相等"></a>6.7 相等和严格相等</h3><p><code>==</code> 和 <code>===</code>的区别</p>
<blockquote>
<p>它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trueconsole.log(5 == &#x27;5&#x27;);// falseconsole.log(5 === &#x27;5&#x27;);// trueconsole.log(&#x27;1&#x27; == true);// falseconsole.log(&#x27;1&#x27; == &#x27;true&#x27;);// falseconsole.log(1 == &#x27;true&#x27;);// falseconsole.log(1 === true);</span></span><br></pre></td></tr></table></figure>



<p>值得注意的一点是 <code>+0</code> 等于 <code>-0</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trueconsole.log(+0 === -0);</span></span><br></pre></td></tr></table></figure>



<p>空字符串同样使用一般相等运算符比较是等于 0 的</p>
<p><strong>原始类型的值会转换成数值再进行比较。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === 0</span></span><br><span class="line"><span class="comment">// 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === Number(false)</span></span><br><span class="line"><span class="comment">// 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\n  123  \t&#x27;</span> == <span class="number">123</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 因为字符串转为数字时，省略前置和后置的空格</span></span><br></pre></td></tr></table></figure>





<p><strong>复合类型值使用严格等于符号比较</strong></p>
<p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false</span></span><br><span class="line">[] === [] <span class="comment">// false</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; === <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code>false</code>。</p>
<p>如果两个变量引用同一个对象，则它们相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> v2 = v1;</span><br><span class="line">v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;<span class="keyword">var</span> obj2 = &#123;&#125;;obj1 &gt; obj2 <span class="comment">// falseobj1 &lt; obj2 // falseobj1 === obj2 // false</span></span><br></pre></td></tr></table></figure>

<p>上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回<code>false</code>。</p>
<p><strong>undefined and null</strong></p>
<p><code>undefined</code>和<code>null</code>与自身严格相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span> <span class="comment">// truenull === null // true</span></span><br></pre></td></tr></table></figure>

<p>由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1;<span class="keyword">var</span> v2;v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p><code>undefined</code>和<code>null</code>只有与自身比较，或者互相比较时，才会返回<code>true</code>；与其他类型的值比较时，结果都为<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span> <span class="comment">// truenull == null // trueundefined == null // truefalse == null // falsefalse == undefined // false0 == null // false0 == undefined // false</span></span><br></pre></td></tr></table></figure>





<h3 id="6-8-严格不相等运算符"><a href="#6-8-严格不相等运算符" class="headerlink" title="6.8 严格不相等运算符"></a>6.8 严格不相等运算符</h3><p>严格相等运算符有一个对应的“严格不相等运算符”（<code>!==</code>），它的算法就是先求严格相等运算符的结果，然后返回相反值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> !== <span class="string">&#x27;1&#x27;</span> <span class="comment">// true// 等同于!(1 === &#x27;1&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，感叹号<code>!</code>是求出后面表达式的相反值。</p>
<h3 id="6-9-一般不相等运算符"><a href="#6-9-一般不相等运算符" class="headerlink" title="6.9 一般不相等运算符"></a>6.9 一般不相等运算符</h3><p>相等运算符有一个对应的“不相等运算符”（<code>!=</code>），它的算法就是先求相等运算符的结果，然后返回相反值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> != <span class="string">&#x27;1&#x27;</span> <span class="comment">// false// 等同于!(1 == &#x27;1&#x27;)</span></span><br></pre></td></tr></table></figure>





<h2 id="7-布尔运算符"><a href="#7-布尔运算符" class="headerlink" title="7. 布尔运算符"></a>7. 布尔运算符</h2><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符。</p>
<ul>
<li>取反运算符：<code>!</code></li>
<li>且运算符：<code>&amp;&amp;</code></li>
<li>或运算符：<code>||</code></li>
<li>三元运算符：<code>?:</code></li>
</ul>
<h3 id="1-取反运算符（-）"><a href="#1-取反运算符（-）" class="headerlink" title="1. 取反运算符（!）"></a>1. 取反运算符（!）</h3><p>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!true // false!false // true</span><br></pre></td></tr></table></figure>

<p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code>true</code>，其他值都为<code>false</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li>空字符串（<code>&#39;&#39;</code>）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="literal">undefined</span> <span class="comment">// true!null // true!0 // true!NaN // true!&quot;&quot; // true!54 // false!&#x27;hello&#x27; // false![] // false!&#123;&#125; // false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。</p>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同。这是一种常用的类型转换的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!!x<span class="comment">// 等同于Boolean(x)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，不管<code>x</code>是什么类型的值，经过两次取反运算后，变成了与<code>Boolean</code>函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。</p>
<h3 id="2-且运算符-amp-amp"><a href="#2-且运算符-amp-amp" class="headerlink" title="2.且运算符(&amp;&amp;)"></a>2.且运算符(&amp;&amp;)</h3><p><strong>用于返回多个表达式的求值.</strong></p>
<p><em>a.当只有两个表达式的时候</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表达式1 &amp;&amp; 表达式2</span><br></pre></td></tr></table></figure>

<p>如果表达式1 为真(true),<strong>则返回表达式2的值,而不是返回布尔值</strong>,</p>
<p>如果表达式1 为假(false),<strong>则直接返回 表达式1 的值,并且不对表达式2进行求值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 20console.log((5 + 5) &amp;&amp; (10 + 10));// 输出 0console.log(0 &amp;&amp; (10 + 10));</span></span><br></pre></td></tr></table></figure>



<p>表达式1为真则计算表达式2,如果表达式1为假则不计算表达式2</p>
<p><strong>这种跳过第二个表达式的计算称为短路</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;a = <span class="number">10</span>;b = <span class="number">1</span>;<span class="comment">// 输出 9console.log(b &amp;&amp; (b = a - 1));// 这时 变量b确实是 9 console.log(b);b = 1;// 输出 0console.log(0 &amp;&amp; (b = a - 5));// 这时 变量b依旧是1没变说明表达式2没计算console.log(b);</span></span><br></pre></td></tr></table></figure>



<p>有时候可以用它来代替if判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;<span class="keyword">if</span> (a === <span class="number">0</span>) &#123;   <span class="comment">// 输出了 helloworld   console.log(&#x27;helloworld&#x27;);&#125;// 等价于// 输出 helloworld(a === 0) &amp;&amp; console.log(&#x27;helloworld&#x27;);</span></span><br></pre></td></tr></table></figure>



<p><strong>且运算符多个连用的时候</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。*/</span><span class="literal">true</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="string">&#x27;foo&#x27;</span> &amp;&amp; <span class="literal">true</span><span class="comment">// &#x27;&#x27;1 &amp;&amp; 2 &amp;&amp; 3// 3/*上面代码中，例一里面，第一个布尔值为false的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是true，所以返回最后一个表达式的值3。*/</span></span><br></pre></td></tr></table></figure>



<h3 id="3-或运算符"><a href="#3-或运算符" class="headerlink" title="3. 或运算符 ( || )"></a>3. 或运算符 ( || )</h3><p>符号使用如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表达式1 || 表达式2</span><br></pre></td></tr></table></figure>

<p>如果第一个表达式1为真(true) , 直接返回表达式1的值,不对表达式2做任何计算.</p>
<p>如果表达式1为假(false) , 则返回第二个表达式的值.</p>
<p>同样具备短路</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;<span class="literal">true</span> || (x = <span class="number">2</span>) <span class="comment">// truex // 1</span></span><br></pre></td></tr></table></figure>



<p><strong>多个或运算符连用</strong></p>
<p>这时返回<strong>第一个布尔值为<code>true</code>的表达式的值</strong>。</p>
<p><strong>如果所有表达式都为<code>false</code>，则返回最后一个表达式的值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> || <span class="number">0</span> || <span class="string">&#x27;&#x27;</span> || <span class="number">4</span> || <span class="string">&#x27;foo&#x27;</span> || <span class="literal">true</span><span class="comment">// 4false || 0 || &#x27;&#x27;// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，例一里面，第一个布尔值为<code>true</code>的表达式是第四个表达式，所以得到数值4。例二里面，所有表达式的布尔值都为<code>false</code>，所以返回最后一个表达式的值。</p>
<h3 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4. 三元运算符"></a>4. 三元运算符</h3><p>总算有个布尔运算符和C语言中的一样了.(狗头)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表达式1 ? 表达式2 : 表达式3 ; </span><br></pre></td></tr></table></figure>



<p>表达式1为真,则返回表达式2的值<br>表达式1为假,则返回表达式3的值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;<span class="comment">// 输出a为5,说明表达式3没有计算console.log(1 ? a = a + 5 : a = a - 5);var a = 0;// 输出a为-5,说明表达式2没有计算console.log(0 ? a = a + 5 : a = a - 5);</span></span><br></pre></td></tr></table></figure>





<h2 id="8-基本引用类型"><a href="#8-基本引用类型" class="headerlink" title="8.基本引用类型"></a>8.基本引用类型</h2><h3 id="8-1-Date"><a href="#8-1-Date" class="headerlink" title="8.1 Date"></a>8.1 Date</h3><p>创建一个日期对象,就是用new操作嗲用Date构造函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>



<h4 id="8-1-1-Date-parse"><a href="#8-1-1-Date-parse" class="headerlink" title="8.1.1 Date.parse"></a>8.1.1 Date.parse</h4><p>比如创建一个表示 “2000年10月2号的日期对象”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mon Oct 02 2000 00:00:00 GMT+0800 (中国标准时间)let someDate = new Date(Date.parse(&quot;10/2/2000&quot;));console.log(someDate);/*书写格式1. --- &quot;10/2/2000&quot;2. --- &quot;Oct 2,2000&quot;3. --- &quot;Mon Oct 2 2000 00:00:00 GMT-0700 &quot;.....(还有其他,但这上面三种够用了)*/</span></span><br></pre></td></tr></table></figure>



<p>如果传入的不是日期,Date.parse() 方法会返回NaN</p>
<h4 id="8-1-2-Date-UTC"><a href="#8-1-2-Date-UTC" class="headerlink" title="8.1.2 Date.UTC()"></a>8.1.2 Date.UTC()</h4><p>这个方法同样是返回一个参数,表示时间,但是返回的参数和Date.parse()方法格式不一样而已.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Sat Jan 01 2000 08:00:00 GMT+0800 (中国标准时间)let mytime_one = new Date(Date.UTC(2000, 0));console.log(mytime_one);//Fri May 05 2000 08:55:55 GMT+0800 (中国标准时间)//Date.UTC(年, 月, 日, 小时, 分钟, 秒数)let mytime_two = new Date(Date.UTC(2000, 4, 5, 0, 55, 55));console.log(mytime_two);</span></span><br></pre></td></tr></table></figure>



<p>这里我发现一个谷歌浏览器有意思的地方,使用<code>Date.UTC()</code>输入的时间,有两个地方需要注意,一个是月份,一个是小时.</p>
<p>月份是从0开始(0表示一月,1表示二月…)</p>
<p>小时是可以使用的是24小时制  <strong>但是</strong> 我们这个谷歌浏览器小时是默认中国八点,所以如果小时写1,那么输出的小时就是就是九点(8+1=9)</p>
<h4 id="8-1-3-Date类继承的方法"><a href="#8-1-3-Date类继承的方法" class="headerlink" title="8.1.3 Date类继承的方法"></a>8.1.3 Date类继承的方法</h4><ul>
<li>toLocaleDateString()<ul>
<li>返回表示时间的字符串</li>
</ul>
</li>
<li>tostring()<ul>
<li>返回表示时间的字符串</li>
</ul>
</li>
<li>valueOf()<ul>
<li>返回日期的毫秒表示</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">// 2021/8/6console.log(someDate.toLocaleDateString());// Fri Aug 06 2021 14:59:58 GMT+0800 (中国标准时间)console.log(someDate.toString());</span></span><br></pre></td></tr></table></figure>



<p>偏心讲讲<code>valueOf</code><br>这个函数返回的是一串数字,日期约大,这串数字就越大<br>可以利用这个做日期得大小比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> time_one = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="keyword">let</span> time_two = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">// 1548864000000console.log(time_one.valueOf());// 1580400000000console.log(time_two.valueOf());// trueconsole.log(time_two &gt; time_one);</span></span><br></pre></td></tr></table></figure>



<h4 id="8-1-4-格式化日期"><a href="#8-1-4-格式化日期" class="headerlink" title="8.1.4 格式化日期"></a>8.1.4 格式化日期</h4><p>以下这些方法的输出与toLocaleString()和toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p>
<ul>
<li>toDateString</li>
<li>toTimeString</li>
<li>toLocaleDateString</li>
<li>toUTCString</li>
</ul>
<p>说白了下面方法就是显示时间得格式不一样而已.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> time_one = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">6</span>);<span class="comment">// Sun Sep 06 2020console.log(time_one.toDateString());// 00:00:00 GMT+0800 (中国标准时间)console.log(time_one.toTimeString());// 2020/9/6console.log(time_one.toLocaleDateString());// Sat, 05 Sep 2020 16:00:00 GMTconsole.log(time_one.toUTCString());</span></span><br></pre></td></tr></table></figure>





<h3 id="8-2-RegExp"><a href="#8-2-RegExp" class="headerlink" title="8.2 RegExp"></a>8.2 RegExp</h3><h4 id="a-正则表达式"><a href="#a-正则表达式" class="headerlink" title="a.正则表达式"></a>a.正则表达式</h4><ul>
<li>g：全局模式<ul>
<li> 表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li>
</ul>
</li>
<li>i：不区分大小写<ul>
<li> 表示在查找匹配时忽略pattern和字符串的大小写。</li>
</ul>
</li>
<li>m：多行模式<ul>
<li> 表示查找到一行文本末尾时会继续查找。</li>
</ul>
</li>
<li>y：粘附模式<ul>
<li> 表示只查找从lastIndex开始及之后的字符串。</li>
</ul>
</li>
<li>u: Unicode模式<ul>
<li> 启用Unicode匹配。</li>
</ul>
</li>
<li>s:dotAll模式<ul>
<li> 表示元字符．匹配任何字符（包括\n或\r）。</li>
</ul>
</li>
</ul>
<p><strong>RegExp支持正则表达式,配合上面标记的使用,可以达成许多搜索条件.</strong></p>
<p>语法</p>
<p>下面两个写法等价,<strong>只不多一个使用字面量定义,一个使用构造函数.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern(样式)/</span>flags(标识);<span class="comment">// 等价于⬇let expression = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</span></span><br></pre></td></tr></table></figure>



<p>元字符再模式中必须转义,包括下面字符</p>
<p><strong>一定要转义,切记,很重要</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ? * + . &#125; ] ) </span><br></pre></td></tr></table></figure>



<p><strong>例子</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配字符串中的所有&quot;at&quot;let pattern1 = /at/g;//匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写let pattern2=/[bc]at/i;//匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写let pattern3 = /.at/gi ;</span></span><br></pre></td></tr></table></figure>



<p><strong>选择性修改标记</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/cat/g</span>;<span class="comment">// 输出 /cat/gconsole.log(re1);const re2 = new RegExp(re1);// 输出 /cat/gconsole.log(re2);// 这里我们标识就被修改了const re3 = new RegExp(re1, &quot;i&quot;);// 输出 /cat/iconsole.log(re3);</span></span><br></pre></td></tr></table></figure>





<h4 id="b-RegExp实例属性"><a href="#b-RegExp实例属性" class="headerlink" title="b.RegExp实例属性"></a>b.RegExp实例属性</h4><ul>
<li>global：布尔值，表示是否设置了g标记。</li>
<li>ignoreCase：布尔值，表示是否设置了i标记。</li>
<li>unicode：布尔值，表示是否设置了u标记。</li>
<li>sticky：布尔值，表示是否设置了y标记。</li>
<li>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。</li>
<li>multiline：布尔值，表示是否设置了m标记。</li>
<li>dotAll：布尔值，表示是否设置了s标记。</li>
<li>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li>
<li>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。</li>
</ul>
<h4 id="8-3-原始值包装类型"><a href="#8-3-原始值包装类型" class="headerlink" title="8.3 原始值包装类型"></a>8.3 原始值包装类型</h4><p>扩展:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substring(start,stop)  //提取字符串函数</span><br><span class="line">start 起始位置</span><br><span class="line">stop  结束位置</span><br></pre></td></tr></table></figure>



<h5 id="a-简介"><a href="#a-简介" class="headerlink" title="a.简介"></a>a.简介</h5><p>下面代码中<code>str_one</code>是原始值,原始值不是对象,是没有方法的<br>但是下列代码依旧是成功运行,将<code>str_one</code>中的值用substring()方法给保存到<code>str_two</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_one = <span class="string">&#x27;helloworld&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str_two = str_one.substring(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// lloworld</span></span><br><span class="line"><span class="built_in">console</span>.log(str_two);</span><br><span class="line"><span class="comment">// helloworld</span></span><br><span class="line"><span class="built_in">console</span>.log(str_one);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str_one = <span class="string">&#x27;helloworld&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str_two = str_one.substring(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两行代码实际理解为下面三行,具体看下文文字理解</span></span><br><span class="line"><span class="keyword">let</span> str_one = <span class="keyword">new</span> <span class="built_in">String</span> (<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> str_two = str_one.substring(<span class="number">2</span>);</span><br><span class="line">str_ome = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<p><em>我对上面代码理解如下:</em></p>
<p><strong>原本 原始值 和 原始值包装类型的对象  是不一样的,</strong><br><strong>但是我们像上面代码那样直接用 原始值 使用 原始值包装类型的对象 才能用的方法的时候,后台就直接创建一个和这个原始值(str_one)相对应的原始包装类型的对象(暴露出各种方法),导致我们使用原始值直接调用原始包装类型的对象才拥有的方法也可以执行</strong></p>
<p>（1）创建一个String类型的实例；</p>
<p>（2）调用实例上的特定方法；</p>
<p>（3）销毁实例。</p>
<p><strong>这种行为,让原始值拥有对象的行为,同样 布尔值和数值都会像string一样,再后台发生.</strong></p>
<p>我们上面代码之所以能够执行时通过new关键字,new关键字实例化引用类型后,得到的实例摘离开作用域时被销毁,所以我们上面的实例可以使用方法.</p>
<p>而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> some = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">some.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(some.color);</span><br></pre></td></tr></table></figure>

<p>因为当第三行代码运行的时候,<code>some.color</code>这个属性就被销毁了.</p>
<h5 id="b-object类型包装"><a href="#b-object类型包装" class="headerlink" title="b.object类型包装"></a>b.object类型包装</h5><p>object对象,你输入哪一种类型的值,返回也返回同一类型.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some string&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 <span class="keyword">instanceof</span> <span class="built_in">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2 <span class="keyword">instanceof</span> <span class="built_in">Number</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3 <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 输出false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4 <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);</span><br></pre></td></tr></table></figure>



<p>但是我换成typeof就都返回的是object对象</p>
<p><code>typeof()</code> 判断任何引用类型返回的都是object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 都是输出object</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some string&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (obj1));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (obj2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (obj3));</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (obj4));</span><br></pre></td></tr></table></figure>



<h5 id="c-Number类型包装"><a href="#c-Number类型包装" class="headerlink" title="c Number类型包装"></a>c Number类型包装</h5><p>Number中<code>toString()</code> <code>valueof()</code> <code>toLocaleString()</code> 都被重写过</p>
<p>value() 返回Number对象的原始数值,另外两个重写得方法返回数值字符串.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mun = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 默认按照十进制输出</span></span><br><span class="line"><span class="built_in">console</span>.log(mun.toString());</span><br><span class="line"><span class="comment">// 二进制输出</span></span><br><span class="line"><span class="built_in">console</span>.log(mun.toString(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 八进制输出</span></span><br><span class="line"><span class="built_in">console</span>.log(mun.toString(<span class="number">8</span>));</span><br><span class="line"><span class="comment">// 16进制</span></span><br><span class="line"><span class="built_in">console</span>.log(mun.toString(<span class="number">16</span>));</span><br><span class="line"><span class="comment">// 10进制</span></span><br><span class="line"><span class="built_in">console</span>.log(mun.toString(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mun2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">console</span>.log(mun2.valueOf());</span><br></pre></td></tr></table></figure>



<p><strong>idinteger()方法和安全整数</strong></p>
<p><strong>isinteger()方法,用于辨别的一个数值是否位整数.</strong></p>
<p><strong>在阔括号中是运算的表达式也是可以的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">10</span> * <span class="number">3</span> - <span class="number">5</span> * <span class="number">0.3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1.2</span>;</span><br><span class="line"><span class="comment">// console.log(num.isInteger());  使用报错</span></span><br><span class="line"><span class="keyword">let</span> mun = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1.2</span>);</span><br><span class="line"><span class="comment">// console.log(mun.isInteger()); 使用报错</span></span><br></pre></td></tr></table></figure>





<p><strong>toFixed()返回包含小数点,括号传入位数</strong></p>
<p>如果这个数值本身的小数位多于传入的参数,那么多出来的将进行<strong>四舍五入</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.26635</span>;</span><br><span class="line"><span class="comment">// 输出10.27</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>



<p>再次提醒,浮点数的计算并不准确,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 0.1 + 0.2;</span><br><span class="line">// 输出0.30000000000000004</span><br><span class="line">console.log(num);</span><br></pre></td></tr></table></figure>



<p>同下文中的布尔值一样,<strong>Number对象是Number类型的实例，而原始数值不是</strong></p>
<h5 id="d-Boolean类型包装"><a href="#d-Boolean类型包装" class="headerlink" title="d. Boolean类型包装"></a>d. Boolean类型包装</h5><p><strong>我们重点区分一下,布尔类型的对象和布尔原始值是有区别的!!!</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bealoon_object = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> result_one = bealoon_object &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(result_one);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bealoon_value = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result_two = bealoon_value &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 输出 false</span></span><br><span class="line"><span class="built_in">console</span>.log(result_two);</span><br></pre></td></tr></table></figure>



<p>我们看上文的布尔运算符中就可知,<code>&amp;&amp;</code> 是属于  “”有假必要假”” , 所以我们第一个<code>bealoon_object</code> 属于布尔对象和布尔原始值<code>bealoon_value</code> 是有区别的,布尔类型对象,<strong>你把他值设置成假,但是它本身依旧表示真.</strong></p>
<p>我们使用<code>typeof</code> 对于原始值(boolean值)返回原始类型的的数据(Boolean),但是对于引用类型,也就是<code>bealoon_object</code> 属于布尔类型的实例,则返回的是object</p>
<p>同样，Boolean对象是Boolean类型的实例，在使用instaceof操作符时返回true，但对原始值则返回false. (因为instanceof一个作用是用来判断对象的具体类型.)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bealoon_object = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> result_one = bealoon_object &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(result_one);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bealoon_value = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result_two = bealoon_value &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 输出 false</span></span><br><span class="line"><span class="built_in">console</span>.log(result_two);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的是object类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bealoon_object);</span><br><span class="line"><span class="comment">// 输出的是bealoon类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bealoon_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的是true</span></span><br><span class="line"><span class="built_in">console</span>.log(bealoon_object <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);</span><br><span class="line"><span class="comment">// 输出的是false</span></span><br><span class="line"><span class="built_in">console</span>.log(bealoon_value <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);</span><br></pre></td></tr></table></figure>



<h3 id="8-3-单例内置对象"><a href="#8-3-单例内置对象" class="headerlink" title="8.3  单例内置对象"></a>8.3  单例内置对象</h3><p>Object , Array , String 都是属于内置对象,可以笼统得理解成JavaScript本来就带有这些类得,</p>
<h4 id="8-3-1-Global"><a href="#8-3-1-Global" class="headerlink" title="8.3.1 Global"></a>8.3.1 Global</h4><p>Golbal对象,是再ECMAScript中最特别的对象,它属于兜底对象,就是说除了某个对象或某些个对象独有的属性和方法外,一些公共的属性和方法都是属于这个Golbal对象的,比如<code>isNaN()</code> <code> parseInt()</code> …等等.</p>
<p>本质上没有全局变量和全局函数,因对那些公共的变量和函数相当于属于Golbal内置对象.</p>
<h1 id="本人继续更新中…"><a href="#本人继续更新中…" class="headerlink" title="本人继续更新中…."></a>本人继续更新中….</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YaoGui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/29/JavaScript笔记/">http://example.com/2021/08/29/JavaScript笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">YAOGUI</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/11/14/YG%E9%87%8D%E5%B7%A5/"><i class="fa fa-chevron-left">  </i><span>YG重工</span></a></div><div class="next-post pull-right"><a href="/2021/06/20/C-language-one/"><span>C语言学习笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210620/wallhaven-mpmok9.40nviwlii5q0.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By YaoGui</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>