<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C语言学习笔记"><meta name="keywords" content="C语言"><meta name="author" content="YaoGui"><meta name="copyright" content="YaoGui"><title>C语言学习笔记 | YaoGui's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">第一章 初识C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90"><span class="toc-number">1.1.</span> <span class="toc-text">C语言起源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%85%AD%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">C语言六大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.设计特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E6%95%88%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.高效性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.可移植性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%BA%E5%A4%A7%E8%80%8C%E7%81%B5%E6%B4%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.强大而灵活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%A2%E5%90%91%E7%A8%8B%E5%BA%8F%E5%91%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.面向程序员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.设计程序步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.</span> <span class="toc-text">C语言运行步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text">C语言程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">第一章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-C%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">第二章 C语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A"><span class="toc-number">2.0.1.</span> <span class="toc-text">C语言中的注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.0.2.</span> <span class="toc-text">C语言的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%9C%89%E6%95%88%E5%91%BD%E5%90%8D"><span class="toc-number">2.0.3.</span> <span class="toc-text">C语言有效命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.4.</span> <span class="toc-text">多个函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.0.5.</span> <span class="toc-text">C语言中的关键字和保留标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%A6%82%E5%BF%B5%E5%B0%8F%E7%BB%93"><span class="toc-number">2.0.6.</span> <span class="toc-text">C语言第二章概念小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BB%83%E4%B9%A0"><span class="toc-number">2.0.7.</span> <span class="toc-text">C语言第二章练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%92%8CC%E8%AF%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">第三章 数据和C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getchar-putchar-and-scanf"><span class="toc-number">3.2.</span> <span class="toc-text">getchar  putchar  and  scanf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.3.</span> <span class="toc-text">C语言数据类型关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6-%E5%85%AB%E8%BF%9B%E5%88%B6-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">3.3.3.</span> <span class="toc-text">十进制 八进制 十六进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">3.3.4.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D-bit-%E5%AD%97%E8%8A%82-byte-%E5%92%8C-%E5%AD%97-word"><span class="toc-number">3.3.5.</span> <span class="toc-text">位(bit)  字节(byte) 和  字(word)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.6.</span> <span class="toc-text">int类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0short%E3%80%81long%E3%80%81long-long%E5%92%8Cunsigned%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.7.</span> <span class="toc-text">打印short、long、long long和unsigned类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">3.3.8.</span> <span class="toc-text">整数溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%BD%AC%E6%8D%A2-%E2%80%93-%E9%87%8D%E7%82%B9-%E6%88%AA%E6%96%AD"><span class="toc-number">3.3.9.</span> <span class="toc-text">使用正确的转换   –    重点:  截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.10.</span> <span class="toc-text">char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">3.3.11.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bool"><span class="toc-number">3.3.12.</span> <span class="toc-text">_Bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.13.</span> <span class="toc-text">可移植头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E4%B8%80%E7%82%B9%E6%89%A9%E5%85%85"><span class="toc-number">3.3.14.</span> <span class="toc-text">浮点型的一点扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%80%BC%E7%9A%84%E4%B8%8A%E6%BA%A2%E5%92%8C%E4%B8%8B%E6%BA%A2"><span class="toc-number">3.3.14.1.</span> <span class="toc-text">浮点值的上溢和下溢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%95%B0%E5%92%8C%E5%A4%8D%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.15.</span> <span class="toc-text">虚数和复数类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text">第四章 字符串 格式化输入\输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">字符串和字符的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E9%A2%84%E5%A4%84%E7%90%86-%E5%92%8C-%E5%B8%B8%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">const 预处理 和 常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#limit-h-float-h-%E6%98%8E%E7%A4%BA%E5%B8%B8%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">limit.h  float.h  明示常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printf-%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">4.4.</span> <span class="toc-text">printf()函数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scanf%EF%BC%88%EF%BC%89%E8%AF%B4%E6%98%8E"><span class="toc-number">4.5.</span> <span class="toc-text">scanf（）说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printf-%EF%BC%88%EF%BC%89and-scanf%EF%BC%88%EF%BC%89-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.6.</span> <span class="toc-text">printf （）and scanf（）  修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">第四章习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-printf-%E2%80%9CThe-double-type-is-z-bytes%E2%80%A6-n%E2%80%9D-sizeof-double-%E8%BF%99%E4%B8%AA%E8%AF%AD%E5%8F%A5%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%AD%A3%EF%BC%9F"><span class="toc-number">4.7.0.1.</span> <span class="toc-text">3.printf(“The double type is %z bytes…\n”, sizeof(double));这个语句有什么问题？如何修正？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">5.</span> <span class="toc-text">第五章 控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E6%8C%87%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">C语言计算指数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">5.2.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.4.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E4%B8%BA%E7%9C%9F%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">什么为真？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-%E2%80%9C%E7%9C%9F%E5%80%BC%E2%80%9D"><span class="toc-number">5.5.1.</span> <span class="toc-text">其他 “真值”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.6.</span> <span class="toc-text">优先级 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.6.1.</span> <span class="toc-text">逗号运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%92%8C-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">5.7.</span> <span class="toc-text">字符串 和 字符数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">带返回值函数（方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.9.</span> <span class="toc-text">分支和跳转控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-lt-ctype-h-gt"><span class="toc-number">5.10.</span> <span class="toc-text">#include&lt;ctype . h&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-lt-iso646-h-gt"><span class="toc-number">5.11.</span> <span class="toc-text">#include&lt;iso646.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.11.1.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%AF%B7%E5%8A%A1%E5%BF%85%E7%94%A8-amp-amp-%E7%AC%A6%E5%8F%B7%EF%BC%9B"><span class="toc-number">5.11.1.1.</span> <span class="toc-text">范围请务必用   &amp;&amp;  符号；</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.12.</span> <span class="toc-text">三元运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-%E5%92%8C-%E5%AD%97%E7%AC%A6%E9%AA%8C%E8%AF%81"><span class="toc-number">6.</span> <span class="toc-text">第六章     字符输入  &#x2F;  输出 和   字符验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%B2%A1%E6%9C%89%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">6.0.1.</span> <span class="toc-text">有缓冲区和没有缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putchar-and-getchar"><span class="toc-number">6.1.</span> <span class="toc-text">putchar and getchar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getchar%EF%BC%88%EF%BC%89"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">getchar（）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8EFO%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E7%BB%93%E5%B0%BE"><span class="toc-number">6.1.0.2.</span> <span class="toc-text">如何使用EFO判断文件是否结尾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">重定向和文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84-array"><span class="toc-number">7.</span> <span class="toc-text">第七章 数组 (array)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-number">7.0.1.</span> <span class="toc-text">数组的下标:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">7.0.2.</span> <span class="toc-text">指定初始化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.</span> <span class="toc-text">一维数组 :</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.1.</span> <span class="toc-text">创建只读数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.</span> <span class="toc-text">变长数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">7.4.</span> <span class="toc-text">复合字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum-%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.5.</span> <span class="toc-text">enum(枚举)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.5.1.</span> <span class="toc-text">遍历枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%9E%9A%E4%B8%BE%E8%B5%8B%E5%80%BC"><span class="toc-number">7.5.2.</span> <span class="toc-text">对枚举赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8C%87%E9%92%88-pointer"><span class="toc-number">8.</span> <span class="toc-text">第八章 指针(pointer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84-%E5%92%8C-%E6%8C%87%E9%92%88"><span class="toc-number">8.0.1.</span> <span class="toc-text">函数 数组 和 指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">8.1.</span> <span class="toc-text">保护数组中的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E8%BF%90%E7%94%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">const 运用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E6%8C%87%E5%90%91%E5%88%AB%E5%A4%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">const关键字可以声明并初始化一个不能指向别处的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%8C%87%E9%92%88"><span class="toc-number">8.2.</span> <span class="toc-text">指针和多维指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.3.</span> <span class="toc-text">指向多维数组的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">8.4.</span> <span class="toc-text">数组的兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84-1"><span class="toc-number">8.5.</span> <span class="toc-text">变长数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F-1"><span class="toc-number">8.6.</span> <span class="toc-text">复合字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%A4%8D%E4%B9%A0%E9%A2%98-%E5%92%8C%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="toc-number">8.7.</span> <span class="toc-text">指针复习题 和编程题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">第九章 字符串 和字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.1.</span> <span class="toc-text">关于字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%B7%E4%B8%AA%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="toc-number">9.1.1.</span> <span class="toc-text">使用刷个双引号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5"><span class="toc-number">9.2.</span> <span class="toc-text">字符串输出和输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gets"><span class="toc-number">9.2.1.</span> <span class="toc-text">gets()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fgets"><span class="toc-number">9.2.2.</span> <span class="toc-text">fgets()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fgets-%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">fgets()简单用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fgets-%E7%94%A8%E5%BE%AA%E7%8E%AF-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">fgets()用循环,缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#puts"><span class="toc-number">9.2.3.</span> <span class="toc-text">puts()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fput"><span class="toc-number">9.2.4.</span> <span class="toc-text">fput()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf"><span class="toc-number">9.2.5.</span> <span class="toc-text">printf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gets-s"><span class="toc-number">9.2.6.</span> <span class="toc-text">gets_s()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.7.</span> <span class="toc-text">scanf()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.8.</span> <span class="toc-text">strlen()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcat-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.9.</span> <span class="toc-text">strcat()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncat-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.10.</span> <span class="toc-text">strncat() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcmp-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.11.</span> <span class="toc-text">strcmp() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncmp-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.12.</span> <span class="toc-text">strncmp()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.13.</span> <span class="toc-text">strcpy() 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-%E5%87%BD%E6%95%B0%E4%B8%A4%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">9.2.13.1.</span> <span class="toc-text">strcpy()函数两个属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.2.13.1.1.</span> <span class="toc-text">返回值类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%BF%85%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-number">9.2.13.1.2.</span> <span class="toc-text">不必是数组的开始</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncpy-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.14.</span> <span class="toc-text">strncpy()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sprintf-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.14.0.1.</span> <span class="toc-text">sprintf()函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.15.</span> <span class="toc-text">总结字符串函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88-and-%E7%A9%BA%E5%AD%97%E7%AC%A6"><span class="toc-number">9.3.</span> <span class="toc-text">空指针 and 空字符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB-%E9%93%BE%E6%8E%A5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">第十章 储存类别 链接 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%B7%A6%E5%80%BC%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3"><span class="toc-number">10.0.1.</span> <span class="toc-text">关于左值的基本了解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.1.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">10.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">10.2.1.</span> <span class="toc-text">外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">10.2.2.</span> <span class="toc-text">内部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="toc-number">10.2.3.</span> <span class="toc-text">无连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">10.3.</span> <span class="toc-text">存储期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">10.3.1.</span> <span class="toc-text">静态存储期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">10.3.2.</span> <span class="toc-text">线程存储期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">10.3.3.</span> <span class="toc-text">自动存储期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">10.3.4.</span> <span class="toc-text">动态分配存储期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">10.3.5.</span> <span class="toc-text">存储类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0static"><span class="toc-number">10.4.</span> <span class="toc-text">函数添加static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">10.5.</span> <span class="toc-text">动态内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANSI-C%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">ANSI C类型限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">10.6.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">10.6.2.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restrict"><span class="toc-number">10.6.3.</span> <span class="toc-text">restrict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic"><span class="toc-number">10.6.4.</span> <span class="toc-text">_Atomic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">10.7.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">10.7.1.</span> <span class="toc-text">结构体的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%82%E7%B3%85"><span class="toc-number">10.7.2.</span> <span class="toc-text">结构体杂糅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">10.7.3.</span> <span class="toc-text">结构体作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">10.7.4.</span> <span class="toc-text">使用指针操作结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-number">10.8.</span> <span class="toc-text">位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">10.9.</span> <span class="toc-text">共用体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%88%E7%AB%A0-C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">11.</span> <span class="toc-text">终章 &#x2F;  C语言文件流 &#x2F;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">11.0.1.</span> <span class="toc-text">打开文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fopen-%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.</span> <span class="toc-text">fopen()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getc-and-putc"><span class="toc-number">11.2.</span> <span class="toc-text">getc()   and  putc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fclose-%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">fclose()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">11.4.</span> <span class="toc-text">指向标准文件的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ferror-%E5%87%BD%E6%95%B0"><span class="toc-number">11.5.</span> <span class="toc-text">ferror()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.6.</span> <span class="toc-text">简单文件读写程序</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210618/touxiang.38cvdo15qh40.jpg"></div><div class="author-info__name text-center">YaoGui</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210618/wallhaven-0w6j7q.67qv3jyz5zs0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">YaoGui's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">标签页</a><a class="site-page" href="/categories">文章类别</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">C语言学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-20</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>自己学习《C primer plus》语言的时候做的一点带你小小C语言笔记。<br>一直存着在，虽说过了这么久忘的差不多了，但是完全可以作为我这个博客的一点小小点缀。</p>
<p><strong>我们学习c语言,关键就是学习它的函数库该如何使用.</strong></p>
<p>C 语言能够让用户更轻松完成自顶向下，结构化编程 和 模块化设计<br>C 拥有具有汇编能力才具有的微调控能力</p>
<p>​     main函数总是第一个被调用的函数<br>​     函数是C语言的构造块</p>
<p>// 声明两个变量可以一起声明,但是再Java中这样不推荐.<br>     int feet,fathoms;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-------  目前学过的头文件 ------</span><br><span class="line"><span class="comment">//_Bool 头文件：</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span>  </span></span><br><span class="line"><span class="comment">// 可移植头文件</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"> <span class="comment">// 提供strlen();</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"> <span class="comment">// 提供数学计算等</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">//    头文件提供的字符分析函数系列</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">//  提供rand()随机数等函数</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>    </span></span><br><span class="line">    ASCII码:</span><br><span class="line">    A -- <span class="number">65</span>  a -- <span class="number">97</span>  <span class="number">0</span> -- <span class="number">48</span>    </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="第一章-初识C语言"><a href="#第一章-初识C语言" class="headerlink" title="第一章 初识C语言"></a>第一章 初识C语言</h1><h2 id="C语言起源"><a href="#C语言起源" class="headerlink" title="C语言起源"></a>C语言起源</h2><p>1972年，贝尔实验室的丹尼斯·里奇（Dennis Ritch）和肯·汤普逊（Ken Thompson）在开发UNIX操作系统时设计了C语言</p>
<h2 id="C语言六大特性"><a href="#C语言六大特性" class="headerlink" title="C语言六大特性"></a>C语言六大特性</h2><h3 id="1-设计特性"><a href="#1-设计特性" class="headerlink" title="1.设计特性"></a>1.设计特性</h3><p>C语言的设计理念让用户能轻松地完成自顶向下的规划、结构化编程和模块化设计</p>
<h3 id="2-高效性"><a href="#2-高效性" class="headerlink" title="2.高效性"></a>2.高效性</h3><ul>
<li>强大的控制结构</li>
<li>快速</li>
<li>代码紧凑 —–代表程序更小 </li>
<li>可以移植到其他计算机 </li>
</ul>
<p>在设计上，它充分利用了当前计算机的优势，因此 C程序相对更紧凑，而且运行速度很快。实际上，C 语言具有通常是汇编语言才具有的微调控制能力</p>
<h3 id="3-可移植性"><a href="#3-可移植性" class="headerlink" title="3.可移植性"></a>3.可移植性</h3><p>各种平台都可以找到合适的C语言编译器，可以直接运行或者简单修改后就可以运行。</p>
<h3 id="4-强大而灵活"><a href="#4-强大而灵活" class="headerlink" title="4.强大而灵活"></a>4.强大而灵活</h3><p>例如 UNIX操作系统大部分都是由C语言写的</p>
<p>C程序还可以用于解决物理学和工程学问题，甚至可以用于制作电影的动画特效。</p>
<h3 id="5-面向程序员"><a href="#5-面向程序员" class="headerlink" title="5.面向程序员"></a>5.面向程序员</h3><p>程序员利用C语言可以访问硬件，操作内存中的位。</p>
<p>C语言还具有非常丰富的位运算符和众多C函数供程序员使用。</p>
<h3 id="6-设计程序步骤"><a href="#6-设计程序步骤" class="headerlink" title="6.设计程序步骤"></a>6.设计程序步骤</h3><ul>
<li>定义程序目标</li>
<li>设计程序</li>
<li>编写代码</li>
<li>编译</li>
<li>运行程序</li>
<li>测试和调试程序</li>
<li>维护和修改代码</li>
</ul>
<h2 id="C语言运行步骤"><a href="#C语言运行步骤" class="headerlink" title="C语言运行步骤"></a>C语言运行步骤</h2><p><img src="https://i.loli.net/2021/06/20/TOfzBnkVlRAGIei.png" alt="image-20201223222203549"></p>
<p>一个文件名为concrete后缀为 .c 的c语言文件,经过编译器编译后编程后缀为 .obj 的目标代码文件,</p>
<p>然后衔接器在库代码(调用的函数库)和启动代码(系统标准启动代码)的作用下</p>
<p><strong>链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这 3 部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来</strong></p>
<h2 id="C语言程序设计"><a href="#C语言程序设计" class="headerlink" title="C语言程序设计"></a>C语言程序设计</h2><ol>
<li><p>什么是计算机程序?</p>
<p>答 : 所谓<strong>程序</strong>就是一组计算机能够识别和执行的<strong>指令</strong> .</p>
</li>
<li><p>什么是计算机语言?</p>
<p>答 : 首先 计算机能够识别和接收的二进制代码被称为<strong>机器指令</strong>.</p>
<pre><code>    **机器指令的集合**就是该计算机的**机器语言**.
</code></pre>
<ul>
<li><strong>非机构语言</strong>  : <ul>
<li>BASIC ALGOL 等都是非结构语言</li>
<li>没有严格规范要求,随意跳转,难以阅读和维护</li>
</ul>
</li>
<li><strong>结构化语言</strong> : <ul>
<li>如: C语言 FORTRAN 77  等都是属于结构化语言.</li>
<li>规定程序需要具有良好的基本结构(顺序结构  基本结构  循环结构)</li>
</ul>
</li>
<li><strong>面向对象语言</strong> :<ul>
<li>如: Java  C++  C#  等等</li>
<li>对于处理规模较大的问题时使用更加方便.</li>
</ul>
</li>
</ul>
</li>
<li><p>C语言有以下一些特点:</p>
<ul>
<li>语言简洁 使用方便灵活</li>
<li>运算符丰富</li>
<li>数据类型丰富</li>
<li>具有结构化的控制语句</li>
<li>语法限制不太严格</li>
<li>C语言允许直接访问物理地址</li>
<li>C语言移植性好</li>
<li>生成目标代码质量高,程序执行效率高</li>
</ul>
</li>
</ol>
<h2 id="第一章习题"><a href="#第一章习题" class="headerlink" title="第一章习题"></a>第一章习题</h2><p>1.对编程而言，可移植性意味着什么？</p>
<p>源代码不需要任何修改就可以在不同计算机系统中成功编译的程序。</p>
<p>2.解释源代码文件、目标代码文件和可执行文件有什么区别？</p>
<ul>
<li>源代码文件：包含程序员使用的任何编码语言编写的代码</li>
<li>目标代码：包含机器语言 不必是完整的程序代码</li>
<li>可执行文件：包含组成可执行程序的完整机器语言代码。</li>
</ul>
<p>3.编程的7个主要步骤是什么？</p>
<ul>
<li>定义程序目标</li>
<li>设计程序</li>
<li>编写代码</li>
<li>编译</li>
<li>运行程序</li>
<li>测试和调试程序</li>
<li>维护和修改代码</li>
</ul>
<p>4.编译器的任务是什么？</p>
<p>把源代码翻译成等价的机器语言代码（目标代码）。</p>
<p>5.链接器的任务是什么？</p>
<p><strong>链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这 3 部分合并成一个文件，即可执行文件。</strong></p>
<h1 id="第二章-C语言概述"><a href="#第二章-C语言概述" class="headerlink" title="第二章 C语言概述"></a>第二章 C语言概述</h1><p><img src="https://i.loli.net/2021/06/20/xi5lBYNAv8gsQRC.png" alt="C代码理解图"></p>
<ol>
<li><strong>main（） 函数总是第一个被调用的函数</strong> </li>
<li>函数是C语言的构造块</li>
<li>C语言中的六种语句<ol>
<li>标识语句</li>
<li>复合语句</li>
<li>表达式语句</li>
<li>选择语句</li>
<li>迭代语句</li>
<li>跳转语句</li>
</ol>
</li>
<li>&lt; stdio.h &gt;  是C编译器软件包的标准部分，它提供键盘输入和屏幕输出的支持。</li>
<li>int表明main()函数返回一个整数，void表明main()不带任何参数。</li>
<li>#include这行代码是一条C预处理器指令,通常，C编译器在编译前会对源代码做一些准备工作，即预处理</li>
</ol>
<h3 id="C语言中的注释"><a href="#C语言中的注释" class="headerlink" title="C语言中的注释"></a>C语言中的注释</h3><ol>
<li>/* 第一种注释 */</li>
<li>// 像这种的单行注释</li>
</ol>
<h3 id="C语言的声明"><a href="#C语言的声明" class="headerlink" title="C语言的声明"></a>C语言的声明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num；  		<span class="comment">// 这代码叫做声明</span></span><br><span class="line"><span class="keyword">int</span> num2,num3; 	  <span class="comment">// 也可以像这样一次性声明几个</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    int 是C语言中的数据类型</span></span><br><span class="line"><span class="comment">    num 叫做标识符</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>声明完成两件事情</p>
<p><strong>声明就是特定的标识符和计算机内存中的特定位置联系起来，同时也确定了储存在某位置的信息类型或数据类型。</strong></p>
<ol>
<li>C语言中的所有变量必须先声明才能够使用</li>
<li>在函数中有一个名为num的变量 </li>
<li>int 表明 num 变量是一个整数 </li>
</ol>
<h3 id="C语言有效命名"><a href="#C语言有效命名" class="headerlink" title="C语言有效命名"></a>C语言有效命名</h3><p><strong>用小写字母、大写字母、数字和下划线 “_” 来命名。</strong></p>
<p><strong>而且，名称的第1个字符必须是字符或下划线，不能是数字。</strong></p>
<p>在C语言中，实际参数（简称实参）是传递给函数的特定值，形式参数（简称形参）是函数中用于储存值的变量</p>
<ul>
<li>C语言得名称时区分大小写的</li>
<li>name             // 纯英文</li>
<li>name2           // 英文后面接数字    </li>
<li>name_three   // 英文下划线接英文</li>
</ul>
<h3 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a>多个函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;我说我好不好?\n&quot;</span>);</span><br><span class="line">     butler();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;原来我真的折磨好\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">butler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;你好啊\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C语言中的关键字和保留标识符"><a href="#C语言中的关键字和保留标识符" class="headerlink" title="C语言中的关键字和保留标识符"></a>C语言中的关键字和保留标识符</h3><p><img src="https://i.loli.net/2021/06/20/5A6gfuDN3Oyabrs.png" alt="image-20201231150148625"></p>
<p><img src="https://i.loli.net/2021/06/20/Q29RAdUfPL1K8cz.png" alt="image-20201231150206193"></p>
<p><img src="https://i.loli.net/2021/06/20/AIaMLQD5lFX8iOd.png" alt="image-20201231212539024"></p>
<h3 id="C语言第二章概念小结"><a href="#C语言第二章概念小结" class="headerlink" title="C语言第二章概念小结"></a>C语言第二章概念小结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">	\t 表示Tab键 </span></span><br><span class="line"><span class="comment">	\b BAck pace 键( 退格键 )</span></span><br><span class="line"><span class="comment">	\n 表示换行</span></span><br><span class="line"><span class="comment">	%d相当于是一个占位符，其作用是指明输出变量值的位置.</span></span><br><span class="line"><span class="comment">	% 提醒程序要在该处打印一个变量，d表明把变量作为十进制整数打印.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（&#125;）时会返回0。因此，可以省略	main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	程序由一个或多个函数组成，必须有 main()函数。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	#include&lt;stdio.h&gt; // 这个库提供键盘输入和屏幕输出的支持。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     #include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">     int main(void)		-- 函数头</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">     // 以下为函数体</span></span><br><span class="line"><span class="comment">          语句; //语句一般都用 ; 结尾</span></span><br><span class="line"><span class="comment">          return 0;  -- main()方法以return结束.</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     查错题细节:</span></span><br><span class="line"><span class="comment">     1.变量声明错误  如 int a,int b;  // 这种申明时错误的 </span></span><br><span class="line"><span class="comment">     2.用 ( 代替 &#123; 括号 </span></span><br><span class="line"><span class="comment">     3.语句后面没有写分号</span></span><br><span class="line"><span class="comment">     4.注释是否写错 </span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      C程序由一个或多个C函数组成。每个C程序必须包含一个main()函数，这是C程序要调用的第1个函数。简单的函数由函数头和后面的一对花括号组成，花括号中是由声明、语句组成的函数体。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在C语言中，大部分语句都以分号结尾。声明为变量创建变量名和标识该变量中储存的数据类型。变量名是一种标识符。赋值表达式语句把值赋给变量，或者更一般地说，把值赋给存储空间。函数表达式语句用于调用指定的已命名函数。调用函数执行完毕后，程序会返回到函数调用后面的语句继续执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf()函数用于输出想要表达的内容和变量的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一门语言的语法是一套规则，用于管理语言中各有效语句组合在一起的方式。语句的语义是语句要表达的意思。编译器可以检测出语法错误，但是程序里的语义错误只有在编译完之后才能从程序的行为中表现出来。检查程序是否有语义错误要跟踪程序的状态，即程序每执行一步后所有变量的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后，关键字是C语言的词汇。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return 在C语言中是一种跳转语句</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">*/</span>  </span><br></pre></td></tr></table></figure>



<h3 id="C语言第二章练习"><a href="#C语言第二章练习" class="headerlink" title="C语言第二章练习"></a>C语言第二章练习</h3><ol>
<li>C语言的基本模块是什么？</li>
</ol>
<p>​    函数头   函数体</p>
<p>​    2.什么是语法错误？什么是语义错误？</p>
<p><strong>语法错误</strong> 可以看作是编码出现了违反C语言规则的错误.</p>
<p><strong>语义错误</strong> ,也可以叫逻辑错误.它符合C语言编写规则,但是逻辑上会问题.</p>
<p>3.在main、int、function、char、=中，哪些是C语言的关键字？</p>
<p>​        答 : int 和 char </p>
<h1 id="第三章-数据和C语言"><a href="#第三章-数据和C语言" class="headerlink" title="第三章 数据和C语言"></a>第三章 数据和C语言</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>int 、short、long、unsigned、char、float、double、</strong></p>
<p>_ Bool、_ Complex、_Imaginary</p>
<p>本章新学 :</p>
<p>运算符 :  sizeof();     函数 : scanf();</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">%d占一个位置,十进制输出  </span></span><br><span class="line"><span class="comment">%f占一个位置 , 然后小数形式输出 .</span></span><br><span class="line"><span class="comment">%.2f  中的 .2 用于精确控制输出 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="getchar-putchar-and-scanf"><a href="#getchar-putchar-and-scanf" class="headerlink" title="getchar  putchar  and  scanf()"></a>getchar  putchar  and  scanf()</h2><p><strong>scanf()在读取数字时会跳过空格、制表符(Tab)和换行符(Enter)！</strong></p>
<p>scanf（）函数是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量中。</p>
<p>在scanf（）语句的格式串中由于没有非格式字符在“%d%d%d”之间作为输入时的间隔，因此在输入时要用一个以上的空格或回车符作为每两个输入数之间的间隔。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;=============================================================&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">float</span> high;</span><br><span class="line">     <span class="keyword">double</span> weight;</span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;请依次填写你的年龄,身高,体重,名字&quot;</span>);</span><br><span class="line">     <span class="comment">/* scanf()输入double时要用%lf不能用%f 但是输出可以,因为编译器自动double转float了 */</span></span><br><span class="line">     <span class="comment">// 变量前需要加 &amp; 符号 , 并且接受多个变量时自动跳过空格和回车.</span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%f%lf%s&quot;</span>,&amp;age,&amp;high,&amp;weight,&amp;name);      </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;你的名字是:%s\n 体重是:%lf\n 身高是:%.2f\n 年龄:%d&quot;</span>,name,weight,high,age);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;=============================================================&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;你最喜欢哪些字符? -- #号结束输入&quot;</span>);</span><br><span class="line">     <span class="keyword">char</span> sign;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    getchar() 有缓冲区回车结束接收字符, 空格和回车都会被算作符号.</span></span><br><span class="line"><span class="comment">	    putchar() 用来显示参数所需表示的字符 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">while</span> ((sign = getchar())!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">          <span class="built_in">putchar</span>(sign);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言数据类型关键字"><a href="#C语言数据类型关键字" class="headerlink" title="C语言数据类型关键字"></a>C语言数据类型关键字</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;please enter your first name \n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>,&amp;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;please enter your age: \n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;your name is : %s \n&quot;</span>,name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;your age: %d\n&quot;</span>,age);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接受和输出都要对应好，比如%s接受的数组用%c输出就会使 ？ 号</span></span><br><span class="line">    <span class="comment">// 用%f 接收整数 %d输出就会是0.000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><img src="https://i.loli.net/2021/06/20/AIaMLQD5lFX8iOd.png" alt="image-20201231212539024"></p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>; <span class="comment">/* 全局变量 都可以使用这个 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emm</span><span class="params">(<span class="keyword">int</span> hisage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myage = age - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hisage;     </span><br><span class="line">    hisage = emm(myage);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my age : %d , his age : %d&quot;</span>,myage,hisage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emm</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hisage = age + <span class="number">5</span>;  <span class="comment">// 局部变量 只能在函数块中使用 </span></span><br><span class="line">    <span class="keyword">return</span> hisage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul>
<li>整数<ul>
<li>long , short , int , unsigned , signed(用于提供基本整数类型的变式).</li>
<li>float , double , long double.表示带小数的数</li>
<li>_Bool 类型表示布尔类型</li>
<li>_complex 和 _imaginary 分别表示复数和虚数.</li>
<li><strong>char关键字用于指定其他字符,也可表示较小的整数.</strong></li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/20/abw9rPRko8cmN23.png" alt="image-20201231215548255"></p>
<h3 id="十进制-八进制-十六进制"><a href="#十进制-八进制-十六进制" class="headerlink" title="十进制 八进制 十六进制"></a>十进制 八进制 十六进制</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// %d 十进制输出 %o 8进制输出  %x 16进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%o,%x \n&quot;</span>,i,i,i);</span><br><span class="line">    <span class="comment">// 带格式输出 就是数字头有表明他是那个进制得符号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%#o,%#x \n&quot;</span>,i,i,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">20</span>,<span class="number">24</span>,<span class="number">14</span>    </span><br><span class="line"><span class="number">20</span>,<span class="number">024</span>,<span class="number">0x14</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h3 id="位-bit-字节-byte-和-字-word"><a href="#位-bit-字节-byte-和-字-word" class="headerlink" title="位(bit)  字节(byte) 和  字(word)"></a>位(bit)  字节(byte) 和  字(word)</h3><p>位(bit)  计算机最小储存单位,可以储存 0 或 1, 是计算机内存的基本构建块.</p>
<p>字节(byte)  一字节为8位 如 :  00000001 </p>
<p>字(word) : 是设计计算机时给定的自然储存单位,个人计算机从 最开始8位–16位–32位–到现在的64位,计算机的子长越大,其数据转移越快,允许内存访问也更多.</p>
<p><img src="https://i.loli.net/2021/06/20/FbmMLPrwR3O7SVI.png" alt="image-20201231215644776"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">double</span> a = <span class="number">2.348898</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%2.2f&quot;</span>,a);   <span class="comment">// 限定小数点未熟后，会有个四舍五入的结果。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %d 10进制显示  %o 8进制显示  %x 16进制显示</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也就是说，无论把数字写成16、	 020或0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 那么后面两个%d由于没有对应的变量,输出的就是内存中的任意数据.</span></span><br><span class="line"><span class="comment">printf(&quot;%d minus %d is %d\n&quot;, ten);　// 遗漏2个参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>在C语言中，用特定的前缀表示使用哪种进制。0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制</strong></p>
<p>C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。应记住以下几点。</p>
<p>short int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。</p>
<p>long int或long占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是有符号类型。</p>
<p>long long int或long long（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。</p>
<p><strong>unsigned int或unsigned只用于非负值的场合。</strong>这种类型与有符号类型表示的范围不同。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。</p>
<p>在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。</p>
<p>在任何有<strong>符号类型</strong>前面添加关键字signed，<strong>可强调使用有符号类型的意图</strong>。例如，short、short int、signed short、signed short int都表示同一种类型。</p>
<p>可以在整数后面加L后缀表示是long类型  <strong>variablename – 变量名的意思</strong>  </p>
<p>long　int     variablename;  long　variablename;  short　int　variablename;   short　variablename;</p>
<p>unsigned　int　variablename;   unsigned　variablename;   unsigned　long　variablename;</p>
<p>unsigned　short　variablename;    long　long　variablename (为了储存64位引进)  – 后缀 LL;</p>
<p><img src="https://i.loli.net/2021/06/20/3Dp6YLaJNxicjXe.jpg" alt="img"></p>
<h3 id="打印short、long、long-long和unsigned类型"><a href="#打印short、long、long-long和unsigned类型" class="headerlink" title="打印short、long、long long和unsigned类型"></a>打印short、long、long long和unsigned类型</h3><p><strong>打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行</strong></p>
<p><strong>%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。</strong></p>
<p><strong>对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印unsigned long类型的值。</strong></p>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>有符号类型整数溢出  是从最小复数从新开始.</p>
<p>无符号整数溢出,则是从 0 从新开始.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i　=　<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">unsigned</span>　<span class="keyword">int</span>　j　=　<span class="number">4294967295</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d　%d　%d\n&quot;</span>,　i,　i+<span class="number">1</span>,　i+<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u　%u　%u\n&quot;</span>,　j,　j+<span class="number">1</span>,　j+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在我们的系统下输出的结果是：</span></span><br><span class="line"><span class="comment">    2147483647　　　-2147483648　 -2147483647</span></span><br><span class="line"><span class="comment">    4294967295　　　0　　 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="使用正确的转换-–-重点-截断"><a href="#使用正确的转换-–-重点-截断" class="headerlink" title="使用正确的转换   –    重点:  截断"></a>使用正确的转换   –    重点:  截断</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="number">3000000000</span>; <span class="comment">/* int为32位和short为16位的系统 */</span></span><br><span class="line"><span class="keyword">short</span>　end　=　<span class="number">200</span>;</span><br><span class="line"><span class="keyword">long</span>　big　=　<span class="number">65537</span>;</span><br><span class="line"><span class="keyword">long</span>　<span class="keyword">long</span>　verybig　=　<span class="number">12345678908642</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;un　=　%u　and　not　%d\n&quot;</span>,　un,　un);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end　=　%hd　and　%d\n&quot;</span>,　end,　end);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big　=　%ld　and　not　%hd\n&quot;</span>,　big,　big);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;verybig=　%lld　and　not　%ld\n&quot;</span>,　verybig,　verybig);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在特定的系统中输出如下（不同系统输出的结果可能不同）：</span></span><br><span class="line"><span class="comment">    un = 3000000000 and not -1294967296</span></span><br><span class="line"><span class="comment">    end = 200 and 200</span></span><br><span class="line"><span class="comment">    big = 65537 and not 1</span></span><br><span class="line"><span class="comment">    verybig= 12345678908642 and not 1942899938</span></span><br><span class="line"><span class="comment">    该例仅仅表明，使用错误的转换说明会得到意想不到的结果。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        使用h修饰符可以显示较大整数被截断成 short 类型值的情况。第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd，printf()只会查看后 16 位，所以显示的值是 1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>程序员必须确保转换说明的数量和待打印值的数量相同。以上内容也提醒读者，程序员还必须根据待打印值的类型使用正确的转换说明。</strong></p>
<p><strong>在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。</strong></p>
<h3 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h3><p>通常，char类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余</p>
<p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char<strong>类型实际上储存的是整数而不是字符</strong></p>
<p>给char 赋值字符串的时候要打  ‘  ‘  , 不然他会以为式变量 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> broiled;　　 <span class="comment">/* 声明一个char类型的变量 */</span></span><br><span class="line">broiled = <span class="string">&#x27;T&#x27;</span>;　　<span class="comment">/* 为其赋值，正确 */</span></span><br><span class="line">broiled = T;　　　<span class="comment">/* 错误！此时T是一个变量 */</span></span><br><span class="line">broiled = <span class="string">&quot;T&quot;</span>;　　<span class="comment">/* 错误！此时&quot;T&quot;是一个字符串 */</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// char一般为一个字符， 往后面加他会存最后一个字符。</span></span><br><span class="line">     <span class="keyword">char</span> name =<span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">     <span class="comment">// char name =&#x27;name&#x27;;  如这个最后输出的字符是 e </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;我的名字:%c or %d&quot;</span>,name,name);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。请查阅相应的编译器手册，确定正在使用的编译器如何实现char类型</p>
<p>那么考试时因为编译器不同，结果也是不同的？以考试教材为主。</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p><img src="https://i.loli.net/2021/06/20/FDK8YHsUAyTSgzJ.png" alt="image-20210103161032557"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\v2&quot;</span>)  <span class="comment">// \v垂直制表符</span></span><br><span class="line"><span class="comment">/*    输出结果 </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment"> 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;nihao \r wobuhao&quot;</span>);</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">wobuhao</span></span><br><span class="line"><span class="comment">// 因为\r回到首行居然会把前面的覆盖掉.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">float</span> salary;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\aEnter your desired monthly salary:&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用\b 我可以在下划线哪里输入,哪怕换成其他东西</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;$_______\b\b\b\b\b\b\b&quot;</span>);  </span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;salary);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n\t$%.2f a month is $%.2f a year&quot;</span>,salary,salary*<span class="number">12.0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\rGood!\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第4条printf()语句以\r开始。这使得光标回到当前行的起始处。然后打印Gee!，接着\n		使光标移至下一行的起始处。屏幕最后显示的内容应该是：</span></span><br><span class="line"><span class="comment">        Enter　your　desired　monthly　salary:　$4000.00</span></span><br><span class="line"><span class="comment">        Gee!　$4000.00　a　month　is　$48000.00　a　year.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Bool"><a href="#Bool" class="headerlink" title="_Bool"></a>_Bool</h3><p><strong>C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。但原则上它仅占用1位存储空间，因为对0和1而言，1位的存储空间足够了。</strong></p>
<p><strong>把其他非零数值赋给_Bool类型的变量，该变量会被设置为1。这反映了C把所有的非零值都视为真。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span>  <span class="comment">// 可以把_Bool 写成 bool false true变成关键字。</span></span></span><br></pre></td></tr></table></figure>





<h3 id="可移植头文件"><a href="#可移植头文件" class="headerlink" title="可移植头文件"></a>可移植头文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*C 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头文件中。例如，int32_t表示32位的有符号整数类型。在使用32位int的系统中，头文件会把int32_t作为int的别名。不同的系统也可以定义相同的类型名。例如，int为16位、long为32位的系统会把int32_t作为long的别名。然后，使用int32_t类型编写程序，并包含stdint.h头文件时，编译器会把int或long替换成与当前系统匹配的类型。*/</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点型的一点扩充"><a href="#浮点型的一点扩充" class="headerlink" title="浮点型的一点扩充"></a>浮点型的一点扩充</h3><p>C标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是10-37～10+37。</p>
<p><img src="https://i.loli.net/2021/06/20/Ywtiof1jeB3P4Hu.png" alt="image-20210103165129869"></p>
<p>C语言提供的另一种浮点类型是double（意为双精度）。double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double类型的值至少有13位有效数字，超过了标准的最低位数规定。</p>
<p>-1.56E+12    =  - 1.56 乘 10 的正12次方  = -1.56E12 (E和12的正号可以省去)</p>
<p>  2.87e-3   =  正数 2.87 乘以 10 的负的3次方  = 2.87e-3  (但是如果时负号就不能够省略 )</p>
<p><strong>E 和 e 都是一样的,但是E/e与后面的数字之间不能有空格 !!!</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a1 = <span class="number">-1.5E+12</span>;  <span class="comment">// float a1 = -1.5E12; 正号可省略 </span></span><br><span class="line"><span class="keyword">float</span> a2 = <span class="number">.5E-12</span>;	<span class="comment">// .5E 表示 0.5E 那个0省略了</span></span><br><span class="line"><span class="keyword">float</span> a3 = <span class="number">4e16</span>;</span><br><span class="line"><span class="keyword">float</span> a4 = <span class="number">100.</span>; <span class="comment">// 小数点后买你的0可省略  100.000000</span></span><br><span class="line"><span class="comment">// C语言只保证了float类型小数的前六位精度</span></span><br><span class="line"><span class="comment">// 和Java一样 没有后缀f/F 或者 l/L 一般默认double 和 int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0xa.1fp10</span></span><br><span class="line"><span class="comment">十六进制a等于十进制10，.1f是1/16加上15/256（十六进制f等于十进制15），p10是210或1024。0xa.1fp10表示的值是(10 + 1/16 + 15/256)×1024（即，十进制10364.0）。</span></span><br><span class="line"><span class="comment">注意，并非所有的编译器都支持C99的这一特性。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点值的上溢和下溢"><a href="#浮点值的上溢和下溢" class="headerlink" title="浮点值的上溢和下溢"></a>浮点值的上溢和下溢</h4><p><strong>– 这个都不太懂 , 先放一放 . 后面百度理解理解.</strong></p>
<h3 id="虚数和复数类型"><a href="#虚数和复数类型" class="headerlink" title="虚数和复数类型"></a>虚数和复数类型</h3><p>简而言之，C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型是float _Imaginary、double _Imaginary和long double _Imaginary。</p>
<p>如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。</p>
<p>第三章小结 </p>
<p><strong>基本数据类型由11个关键字组成：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。</strong></p>
<p>有符号整型可用于表示正整数和负整数。</p>
<p>int ——系统给定的基本整数类型。C语言规定int类型不小于16位。</p>
<p>short或short int ——最大的short类型整数小于或等于最大的int类型整数。C语言规定short类型至少占16位。</p>
<p>long或long int ——该类型可表示的整数大于或等于最大的int类型整数。C语言规定long类型至少占32位。</p>
<p>long long或long long int ——该类型可表示的整数大于或等于最大的long类型整数。Long long类型至少占64位。</p>
<p>一般而言，long类型占用的内存比short类型大，int类型的宽度要么和long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供16位的short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long。就是说int 和short相同就不会和long相同 , 反之亦然.</p>
<p>无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。<strong>在整型类型前加上关键字unsigned表明该类型是无符号整型</strong>：unsignedint、unsigned long、unsigned short。<strong>单独的unsigned相当于unsignedint。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这个例子中的a,明明时100.但是我们声明是float,整数输出程序认为是float类型的值,并不会帮我们转化成int 类型 , 它最后输出的数字是其他的错误输出结果.*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span>  <span class="comment">// 支持可移植类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">float</span> aa = <span class="number">.1E1</span>;</span><br><span class="line">     <span class="keyword">float</span> a = <span class="number">100.</span>;</span><br><span class="line">     <span class="keyword">float</span> b = <span class="number">2.87e-3</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot; %d, %f , %f&quot;</span> ,a,b,aa);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="第四章-字符串-格式化输入-输出"><a href="#第四章-字符串-格式化输入-输出" class="headerlink" title="第四章 字符串 格式化输入\输出"></a>第四章 字符串 格式化输入\输出</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">// 提供strlen()函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DENSITY 62.4 <span class="comment">// 用C预处理器把字符常量DENSITY定义为62.4。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">float</span> weight,volume;</span><br><span class="line">     <span class="keyword">int</span> size,letters;</span><br><span class="line">     <span class="keyword">char</span> name [<span class="number">50</span>];  <span class="comment">// 不能像java char [] name , 会报错</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;hi what&#x27;s your first name ? \n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s what&#x27;s your weight in pounds?\n&quot;</span>,name);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;weight);</span><br><span class="line">     size = <span class="keyword">sizeof</span> name;      <span class="comment">//计算这个数组有多少个字节</span></span><br><span class="line">     letters = <span class="built_in">strlen</span>(name);  <span class="comment">// 用C函数strlen()获取字符串的长度。</span></span><br><span class="line">     volume = weight/DENSITY;</span><br><span class="line">     <span class="comment">// %2.2f 这两个2分别代之整数有效数和小数有效数.</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;well,%s,your volume is %2.2f cubic feet,\n&quot;</span>,name,volume);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Also, your first name has %d letters,\n&quot;</span>,letters);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;and we have %d bytes to store it.\n&quot;</span>,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言中的null不是没有字符,它是非打印字符.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">// 提供strlen();</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAISE <span class="meta-string">&quot; You are an extraordinary begin. &quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> namebyte;</span><br><span class="line">     <span class="keyword">int</span> namelenght;</span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;what&#x27;s your name ?\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 当scanf只接受一个变量字符时,遇见空格 回车 制表符就不会在读取</span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name); </span><br><span class="line">     namelenght = <span class="keyword">sizeof</span> name;</span><br><span class="line">     namebyte = <span class="built_in">strlen</span>(name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;hello , %s.%s\n&quot;</span>,name,PRAISE);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;it are %d words for your name.\n&quot;</span>, namelenght);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\t\t we store your name consume %d bytes&quot;</span>, namebyte);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\rGood a name!!!&quot;</span>);  <span class="comment">//这个在上面一句前面,并且把它的\t覆盖了.</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  -----------输出结果如下----------------------------------</span></span><br><span class="line"><span class="comment">//    what&#x27;s your name ?</span></span><br><span class="line"><span class="comment">//    111</span></span><br><span class="line"><span class="comment">//    hello , 111. You are an extraordinary begin.</span></span><br><span class="line"><span class="comment">//    it are 40 words for your name.</span></span><br><span class="line"><span class="comment">//    Good a name!!!   we store your name consume 3 bytes</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串和字符的区别"><a href="#字符串和字符的区别" class="headerlink" title="字符串和字符的区别"></a>字符串和字符的区别</h2><p><img src="https://i.loli.net/2021/06/20/DjOVqNe3AE9GYs8.png" alt="image-20210103234215232"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件不以分号结尾 emmm....</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAISE <span class="meta-string">&quot;You are an extraordinary begin.&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name? &quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s.%s\n&quot;</span>, name, PRAISE);</span><br><span class="line">     <span class="comment">// %zd  格式符z和整数转换说明符一起使用，表示对应数字是一个size_t值。属于C99</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Your name of %zd letters occupies %zd memory cells.\n&quot;</span>,<span class="built_in">strlen</span>(name), <span class="keyword">sizeof</span> name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The phrase of praise has %zd letters &quot;</span>,<span class="built_in">strlen</span>(PRAISE));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;and occupies %zd memory cells.\n&quot;</span>, <span class="keyword">sizeof</span> PRAISE);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     What&#x27;s your name?</span></span><br><span class="line"><span class="comment">     LYG  ggg            // 忽略了 ggg 因为scanf只接受一个变量,所以遇见空格会停止.</span></span><br><span class="line"><span class="comment">     Hello, LYG.You are an extraordinary begin.</span></span><br><span class="line"><span class="comment">     Your name of 3 letters occupies 40 memory cells.</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     // 不一样是因为sizeof将字符串最为的空字符串也计算了,而strlen()只是计算数组个数.</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     The phrase of praise has 31 letters and occupies 32 memory cells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-预处理-和-常量"><a href="#const-预处理-和-常量" class="headerlink" title="const 预处理 和 常量"></a>const 预处理 和 常量</h2><p>在程序中，最好用#define 定义数值常量，用 const 关键字声明的<strong>变量</strong>为只读变量。在程序中使用符号常量（明示常量），提高了程序的可读性和可维护性。</p>
<p><strong>注意，在C语言中，用const类型限定符声明的是变量，不是常量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159       <span class="comment">// 使用预处理定义一个常量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">float</span> area,circum,radius;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;What is the radius os your pizza?\n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;radius);</span><br><span class="line">     area = PI * radius*radius;    <span class="comment">// 面积</span></span><br><span class="line">     circum = <span class="number">2.0</span>*PI*radius;       <span class="comment">// 周长</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;your basic pizza parameters（参数） are as follow: \n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;circumference = %1.2f,area = %1.2f\n&quot;</span>,circum,area);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    const int MONTHS = 12; // MONTHS在程序中不可更改，值为12</span></span><br><span class="line"><span class="comment">    这使得MONTHS成为一个只读值。也就是说，可以在计算中使用MONTHS，可以打印MONTHS，但是	  不能更改MONTHS的值。const用起来比#define更灵活</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="limit-h-float-h-明示常量"><a href="#limit-h-float-h-明示常量" class="headerlink" title="limit.h  float.h  明示常量"></a>limit.h  float.h  明示常量</h2><p><strong>C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息。每个头文件都定义了一系列供实现使用的明示常量</strong></p>
<p><strong>#include&lt;limits.h&gt;</strong></p>
<p><img src="https://i.loli.net/2021/06/20/2iqNu6MV1I5LbBo.png" alt="image-20210104194128020"></p>
<p><strong>#include&lt;float.h&gt;</strong></p>
<p><img src="https://i.loli.net/2021/06/20/szruNqnPjl2ELhX.png" alt="image-20210104194142478"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span>       <span class="comment">//整数限行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;float.h&gt;</span>        <span class="comment">//浮点限行</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Some number limits for this system:\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Biggest int: %d\n&quot;</span>, INT_MAX);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Smallest long long: %lld\n&quot;</span>, LLONG_MIN);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;One byte = %d bits on this system.\n&quot;</span>, CHAR_BIT);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Largest double: %e\n&quot;</span>, DBL_MAX);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Smallest normal float: %e\n&quot;</span>, FLT_MIN);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;float precision = %d digits\n&quot;</span>, FLT_DIG);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;float epsilon = %e\n&quot;</span>, FLT_EPSILON);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  -- 输出结果如下:</span></span><br><span class="line"><span class="comment">    Some number limits for this system:</span></span><br><span class="line"><span class="comment">    Biggest int: 2147483647</span></span><br><span class="line"><span class="comment">    Smallest long long: -9223372036854775808</span></span><br><span class="line"><span class="comment">    One byte = 8 bits on this system.</span></span><br><span class="line"><span class="comment">    Largest double: 1.797693e+308</span></span><br><span class="line"><span class="comment">    Smallest normal float: 1.175494e-038</span></span><br><span class="line"><span class="comment">    float precision = 6 digits</span></span><br><span class="line"><span class="comment">    float epsilon = 1.192093e-007</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="printf-函数说明"><a href="#printf-函数说明" class="headerlink" title="printf()函数说明"></a>printf()函数说明</h2><p><strong>printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值</strong></p>
<p><strong>像 %d  %c 这些符号被称为 转换说明</strong></p>
<img src="https://i.loli.net/2021/06/20/uI1A5HWyxYjpeTh.png" alt="image-20210104194610971" style="zoom: 200%;" />



<p>如果编译器不支持C99,那么就对下列所有项不支持.</p>
<p><img src="https://i.loli.net/2021/06/20/XC8o7hFmnkq9OyT.png" alt="image-20210104195246149"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGES -100</span></span><br><span class="line"><span class="comment">// blure-模糊的  Authentic(真实的) imitation(模仿) - 真实的模仿</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLURE <span class="meta-string">&quot;Authentic imitation!&quot;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%+d*\n&quot;</span>, PAGES);    <span class="comment">// %+d 中的 + 表示显示数字正负符号           </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%2d*\n&quot;</span>, PAGES);     <span class="comment">//只用两个字段宽打印,但是打印的常量有三个,自动扩大符合打印长度.</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%10d*\n&quot;</span>, PAGES);    <span class="comment">//有10个,但是这是默认把数字位于右边</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%-10d*\n&quot;</span>, PAGES);   <span class="comment">// 这个 - 号表示数值位于左边</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;=========================================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">double</span> RENT = <span class="number">3852.99</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%f*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%e*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%4.2f*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="comment">// 结果进行了四舍五入, . 左边如若实际小于,它会自动扩充.</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%3.1f*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%10.3f*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="comment">//结果进行了四舍五入,小数点左边对10代表10个位置用来答应,长度没有10个就会空着.</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%10.3E*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%+4.2f*\n&quot;</span>, RENT);</span><br><span class="line">     <span class="comment">//%010.2f  这个10 前面的0表示以0填充多出来的</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*%010.2f*\n&quot;</span>, RENT);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;=========================================\n&quot;</span>);</span><br><span class="line">     <span class="comment">// 只给两个打印,但是打印的东西大于两个就会扩充</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%2s]\n&quot;</span>,BLURE);</span><br><span class="line">     <span class="comment">// 给24个空位给你打印</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%24s]\n&quot;</span>,BLURE);</span><br><span class="line">     <span class="comment">// give you 24 blank and limit five lenght to printf </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%24.5s]\n&quot;</span>,BLURE);</span><br><span class="line">     <span class="comment">// give you 24 blank and limit five lenght to printf ,&quot;-&quot; left printf. </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%-24.5s]\n&quot;</span>,BLURE);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="scanf（）说明"><a href="#scanf（）说明" class="headerlink" title="scanf（）说明"></a>scanf（）说明</h2><p><strong>scanf()函数返回输入正确变量得个数,遇到文件结束就返回EOF.</strong></p>
<p><strong>scanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符</strong></p>
<p><img src="https://i.loli.net/2021/06/20/uk6A9OboQSCnDZM.png" alt="image-20210107143942024"></p>
<p><img src="https://i.loli.net/2021/06/20/MPg9k1e8HKcvOdL.png" alt="image-20210107143959267"></p>
<p><img src="https://i.loli.net/2021/06/20/JwuhLcPis7DHBR9.png" alt="image-20210107144015271"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;%d,%d&quot; 那么你输入字符时也需要打中间得逗号</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,num1,num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printf-（）and-scanf（）-修饰符"><a href="#printf-（）and-scanf（）-修饰符" class="headerlink" title="printf （）and scanf（）  修饰符"></a>printf （）and scanf（）  修饰符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// printf 中的 * 号 是待自己设置.--------------------------小重点</span></span><br><span class="line">     <span class="keyword">unsigned</span> width,precision;</span><br><span class="line">     <span class="keyword">int</span> number = <span class="number">256</span>;</span><br><span class="line">     <span class="keyword">double</span> weight = <span class="number">242.5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Enter a field width :\n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;width);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;the number is:%*d\n &quot;</span>,width,number);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Now enter a width and a percision:\n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;width,&amp;precision);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;weidth = %*.*f\n&quot;</span>,width,precision,weight);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> n1,n2,n3;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Please enter three integers:\n&quot;</span>);</span><br><span class="line">     <span class="comment">// * 跳过输入的类容</span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span>,&amp;n1,&amp;n2,&amp;n3);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The last integer was %d %d %d\n&quot;</span>, n1,n2,n3);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*、</span></span><br><span class="line"><span class="comment">    Enter a field width :</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    the number is:256</span></span><br><span class="line"><span class="comment">     Now enter a width and a percision:</span></span><br><span class="line"><span class="comment">    8 3</span></span><br><span class="line"><span class="comment">    weidth =  242.500</span></span><br><span class="line"><span class="comment">    Please enter three integers:</span></span><br><span class="line"><span class="comment">    2011 2012 2013 2014 2015</span></span><br><span class="line"><span class="comment">    The last integer was 2013 2014 2015 // 因为2011 2012 被跳过了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>‘’ -13.45e12# 0” // 注意 最前面有个空格</p>
<p>如果其对应的转换说明是%d，scanf()会读取3个字符（-13）并停在小数点处，小数点将被留在输入中作为下一次输入的首字符。如果其对应的转换说明是%f，scanf()会读取-13.45e12，并停在#符号处，而#将被留在输入中作为下一次输入的首字符；然后，scanf()把读取的字符序列-13.45e12转换成相应的浮点值，并储存在float类型的目标变量中。如果其对应的转换说明是%s，scanf()会读取-13.45e12#，并停在空格处，空格将被留在输入中作为下一次输入的首字符；然后，scanf()把这 10个字符的字符码储存在目标字符数组中，并在末尾加上一个空字符。如果其对应的转换说明是%c，scanf()只会读取并储存第1个字符，该例中是一个空格</p>
<p>空格在ASCII表中是 0 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">// strlen() 需要映入头文件.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q <span class="meta-string">&quot;His Hamlet was funny without being vulgar.&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">double</span> a = <span class="number">2.348898</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#x27;\41&#x27;是八进制&#x27;\041&#x27;的一种写法，转换成10进制是（4*8^1+1*8^0）就是33，</span></span><br><span class="line"><span class="comment">	‘\41’即 33，33是字符‘!’所对应的ASCII码。所以printf( &quot;%c &quot;, &#x27;\41 &#x27;)等于				printf( &quot;%c &quot;,33)，那么最后输出的就是字符 &#x27;! &#x27; 。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c\n&quot;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="number">105</span>,<span class="string">&#x27;\41&#x27;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\nhas %d characters.\n&quot;</span>, Q, <span class="built_in">strlen</span>(Q));</span><br><span class="line">     <span class="comment">// %2.3e用科学计数法输出小数</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Is %2.3e the same as %2.2f?\n&quot;</span>, <span class="number">1201.0</span>, <span class="number">1201.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果将Q输出想带有双引号该如何输出</span></span><br><span class="line">    <span class="comment">/* 用转义符号或者把 ” 作为字符输出。</span></span><br><span class="line"><span class="comment">    1.printf(&quot;%c%s%c \nhas %d characters.\n&quot;,&#x27;&quot;&#x27;, Q , &#x27;&quot;&#x27;,strlen(Q));</span></span><br><span class="line"><span class="comment">    2.printf(&quot;  \&quot; %s \&quot;  \n has %d characters.\n&quot;, Q , strlen(Q));</span></span><br><span class="line"><span class="comment">    3.&quot;  \&quot;His Hamlet was funny without being vulgar.\&quot;  &quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\40--空格  表示八进制 还有\41 --&quot;!&quot;等等... 自己去试试. </span><br></pre></td></tr></table></figure>









<h2 id="第四章习题"><a href="#第四章习题" class="headerlink" title="第四章习题"></a>第四章习题</h2><p><strong>1.打印下列各项内容要分别使用什么转换说明？</strong></p>
<p>a.一个字段宽度与位数相同的十进制整数            – %d</p>
<p>b.一个形如8A、字段宽度为4的十六进制整数      –<strong>%4x</strong></p>
<p>c.一个形如232.346、字段宽度为10的浮点数       –%10.3f</p>
<p>d.一个形如2.33e+002、字段宽度为12的浮点数   –%12.2e</p>
<p>e.一个字段宽度为30、左对齐的字符串                 –%-30s </p>
<p>a.字段宽度为15的unsigned long类型的整数                                –%15ul</p>
<p>b.一个形如0x8a、字段宽度为4的十六进制整数                            –%4x</p>
<p>c.一个形如2.33E+02、字段宽度为12、左对齐的浮点数                –<strong>%-12.2E</strong></p>
<p>d.一个形如+232.346、字段宽度为10的浮点数                               –%+10.3f</p>
<p>e.一个字段宽度为8的字符串的前8个字符                                        –%8.8s</p>
<p>a.一个字段宽度为6、最少有4位数字的十进制整数                    –<strong>%6.4d</strong></p>
<p>b.一个在参数列表中给定字段宽度的八进制整数                        –**%<em>o</em>*</p>
<p>c.一个字段宽度为2的字符                                                          –%2c</p>
<p>d.一个形如+3.13、字段宽度等于数字中字符数的浮点数           –<strong>%+0.2f</strong></p>
<p>e.一个字段宽度为7、左对齐字符串中的前5个字符                    –%-7.5s</p>
<p><strong>2.分别写出读取下列各输入行的scanf()语句，并声明语句中用到变量和数组。</strong></p>
<p>a.101        </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-- <span class="keyword">int</span> a ; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure>



<p>b.22.32      8.34E−09    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-- <span class="keyword">float</span> b1,b2; <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>,&amp;b1,&amp;b2);</span><br></pre></td></tr></table></figure>



<p>c.linguini    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-- <span class="keyword">char</span> c [ <span class="number">10</span> ]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;c);</span><br></pre></td></tr></table></figure>



<p>d.catch 22(跳过catch)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">char</span> arr[<span class="number">10</span>];	<span class="comment">//我的</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%*c %*c %*c %*c %*c %s&quot;</span>,&amp;arr);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value;	<span class="comment">//网络</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%*s %d&quot;</span>, &amp;value);</span><br></pre></td></tr></table></figure>



<p>e.catch 22 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> zifu[<span class="number">20</span>]; <span class="comment">//网络</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, zifu, &amp;d);     </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>];	<span class="comment">// 我的 </span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;arr);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br></pre></td></tr></table></figure>



<h4 id="3-printf-“The-double-type-is-z-bytes…-n”-sizeof-double-这个语句有什么问题？如何修正？"><a href="#3-printf-“The-double-type-is-z-bytes…-n”-sizeof-double-这个语句有什么问题？如何修正？" class="headerlink" title="3.printf(“The double type is %z bytes…\n”, sizeof(double));这个语句有什么问题？如何修正？"></a>3.printf(“The double type is %z bytes…\n”, sizeof(double));这个语句有什么问题？如何修正？</h4><p>​    答：</p>
<ol>
<li><p>%z是修饰符，需要后面加转换字符。如%zd  %zx</p>
<p>扩充：sizeof() 是一个获取数据类型 或者 表达式长度的运算符。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sizeof(double) 获取double长度  sizeof(arr) -- 显示 100 byte（字节）</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">100</span>];  <span class="comment">// [] 有多少数字 就占多少字节</span></span><br></pre></td></tr></table></figure>

<p><strong>4.假设要在程序中用圆括号代替花括号，以下方法是否可行？</strong></p>
<p>#define ( {</p>
<p>#define ) }</p>
<p><em>可以，但编译器无法识别哪些该换哪些不该换，所有的()都会被替换为{}</em></p>
<p><img src="E:\霍格沃兹图书馆\笔记\Java_note\Java_Img\image-20210107192831529.png" alt="image-20210107192831529"></p>
<p>虽然我不知道网上说的可以是不是编译器不一样，我的编译器这样些直接报错。</p>
<h1 id="第五章-控制流"><a href="#第五章-控制流" class="headerlink" title="第五章 控制流"></a>第五章 控制流</h1><h2 id="C语言计算指数"><a href="#C语言计算指数" class="headerlink" title="C语言计算指数"></a>C语言计算指数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 有一个函数pow（3.5，2.2）  返回3.5的2.2次幂</span><br></pre></td></tr></table></figure>

<p>  dozen = +12; 编译器不会报错。但是在以前，这样做是不允许的</p>
<p>  整数除法最后结果如果带有小数，小数位会被截断。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x<em>y++表示的是(x)</em>(y++)，而不是(x+y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值</p>
<p><strong>C 表达式的一个最重要的特性是，每个表达式都有一个值。</strong></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x , y ,z;</span><br><span class="line">x = y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);    <span class="comment">// 输出结果为 10 ，居然可以这样复制</span></span><br><span class="line"></span><br><span class="line">x = (<span class="keyword">int</span>)<span class="number">3.8</span> + <span class="number">3.3</span>;  <span class="comment">//输出6</span></span><br><span class="line">x = (<span class="number">2</span> + <span class="number">3</span>) * <span class="number">10.5</span>;  <span class="comment">//输出52</span></span><br><span class="line">x = <span class="number">3</span>/<span class="number">5</span> * <span class="number">22.0</span>;     <span class="comment">// 0</span></span><br><span class="line">y = <span class="number">22.0</span> * <span class="number">3</span>/<span class="number">5</span>;     <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">&quot;%s! C is cool!\n&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(FORMAT,FORMAT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出结果如下：</span></span><br><span class="line"><span class="comment">    %s! C is cool!</span></span><br><span class="line"><span class="comment">    ! C is cool!</span></span><br><span class="line"><span class="comment">     说前一个变量中的%s对于后一个变量时生效的，直接打印出来了*/</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(FORMAT,FORMAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,++num);   <span class="comment">//11</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num++);   <span class="comment">//11</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num--);   <span class="comment">//12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);     <span class="comment">//11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while 出口循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* condition */</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//do while 入口循环，就它最后有个分号。</span></span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">     &#125; <span class="keyword">while</span> (<span class="comment">/* condition */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果scanf()成功读取一个整数，就把该数存入num并返回1</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)==<span class="number">0</span></span><br><span class="line"><span class="comment">// 值先被存入num中，然后然后1，这个1存入status</span></span><br><span class="line">     status　=　<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,　&amp;num);    </span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="什么为真？"><a href="#什么为真？" class="headerlink" title="什么为真？"></a>什么为真？</h2><p>对C而言，表达式为真的值是1，表达式为假的值是0</p>
<h3 id="其他-“真值”"><a href="#其他-“真值”" class="headerlink" title="其他 “真值”"></a>其他 “真值”</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下可见 其实数值不为0的都可算作是真（1）</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d　is　true\n&quot;</span>,　n--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">        3　is　true</span></span><br><span class="line"><span class="comment">        2　is　true</span></span><br><span class="line"><span class="comment">        1　is　true</span></span><br><span class="line"><span class="comment">        0　is　false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="优先级-运算符"><a href="#优先级-运算符" class="headerlink" title="优先级 运算符"></a>优先级 运算符</h2><p>关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。</p>
<p>关系运算符比赋值运算符的优先级高，因此，x_bigger = x &gt; y;相当于x_bigger = (x &gt; y);。</p>
<p>关系运算符之间有两种不同的优先级。</p>
<p>高优先级组： &lt;    &lt;=     &gt;    &gt;=</p>
<p>低优先级组： ==  !=</p>
<p>与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：</p>
<p>ex != wye == zee与(ex != wye) == zee相同</p>
<p>首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。</p>
<p><img src="https://i.loli.net/2021/06/20/J1H59Cia7rlOqR8.png" alt="image-20210108155621914"></p>
<p>**+=    -=     <em>=     /=     %=</em>* </p>
<p>例如 X+=20；  等价于  X = X+20;    </p>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p><strong>逗号运算符的优先级是所有运算符中最低的</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：表达式1，表达式2</span><br></pre></td></tr></table></figure>



<p>逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果。左操作数只是为了副作用需要而被计算，它其值会被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 2.7, sqrt( 2*x )</span><br></pre></td></tr></table></figure>

<p>在上述表达式中，在 sqrt（）函数被调用之前，赋值运算会首先发生。整个表达式的值是此函数的返回值。</p>
<p>逗号运算符的优先级是所有运算符中最低的。因此，前述例子中的表达式 x=2.7 不需要括号。然而，如果希望逗号运算的结果用于另一个赋值运算中，就需要使用括号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = ( x = 2.7, sqrt( 2*x ));  //把 5.4 的平方根赋值给 y。</span><br></pre></td></tr></table></figure>





<p>在初始化列表或函数参数列表中的逗号是列表元素的分隔符，它不是逗号运算符。在这些地方，也可以使用逗号运算符，但必须使用括号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = sqrt( (x=2.7, 2*x) );</span><br></pre></td></tr></table></figure>


<p>这个语句等效于前面例子的语句。逗号运算符允许将多个表达式组合成为一个表达式。这个特点使得它适用于在 for 循环头部初始化或递增多个变量，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i; float fArray[10], val;</span><br><span class="line">for ( i=0, val=0.25; i &lt; 10; ++i, val *= 2.0 )   </span><br><span class="line">	fArray[i] = val;</span><br></pre></td></tr></table></figure>



<h2 id="字符串-和-字符数组"><a href="#字符串-和-字符数组" class="headerlink" title="字符串 和 字符数组"></a>字符串 和 字符数组</h2><p><strong>如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> arr [] = <span class="string">&quot;ninini&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> arr2 [] = <span class="string">&quot;mamama\0&quot;</span>;			</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s , %s&quot;</span>,arr,arr2);	<span class="comment">//结果： ninini , mamama </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<h2 id="带返回值函数（方法）"><a href="#带返回值函数（方法）" class="headerlink" title="带返回值函数（方法）"></a>带返回值函数（方法）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> n,<span class="keyword">int</span> p)</span>  <span class="comment">// 返回值类型为double</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">double</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> i ;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++) <span class="built_in">pow</span>*= n;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">pow</span>;	<span class="comment">// 返回double类型的pow的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分支和跳转控制语句"><a href="#分支和跳转控制语句" class="headerlink" title="分支和跳转控制语句"></a>分支和跳转控制语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">关键字：<span class="keyword">if</span>、<span class="keyword">else</span>、<span class="keyword">switch</span>、<span class="keyword">continue</span>、<span class="keyword">break</span>、<span class="keyword">case</span>、<span class="keyword">default</span>、<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">if</span>  ， <span class="keyword">else</span></span><br><span class="line"><span class="keyword">else</span> 如果没有花括号，<span class="keyword">else</span> 与它上面最近的一个匹配</span><br><span class="line">	<span class="number">1.</span><span class="keyword">continue</span>、<span class="number">2.b</span>reak、</span><br><span class="line"><span class="number">1.</span>跳出此次循环执行下一次循环，<span class="number">2.</span>跳出包含自身的循环。</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ， <span class="keyword">case</span> ， <span class="keyword">default</span></span><br><span class="line"><span class="comment">// switch开关条件不是布尔值！！！</span></span><br><span class="line"><span class="keyword">switch</span> (number)  <span class="comment">//switch(开关语句)的case不一定要求是break，也可以是return</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a good choice.\n&quot;</span>);</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a fair choice.\n&quot;</span>);</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a poor choice.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> 我们思考一个问题!</span><br><span class="line">   	<span class="comment">/*我们每一个case里面都会加一个break或者return</span></span><br><span class="line"><span class="comment">   	但是如果我们不加的话,case会执行表达式锁匹配的case以及这个case下面所有的语句.*/</span></span><br><span class="line">    </span><br><span class="line">    在<span class="keyword">case</span>后的各常量表达式的值不能相同，否则会出现错误。</span><br><span class="line">    在<span class="keyword">case</span>后，允许有多个语句，可以不用&#123;&#125;括起来。</span><br><span class="line">    各<span class="keyword">case</span>和<span class="keyword">default</span>子句的先后顺序可以变动，而不会影响程序执行结果。</span><br><span class="line">    <span class="keyword">default</span>子句可以省略不用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>语句：</span><br><span class="line">跳过此次循环 执行下一次循环.</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span>：</span><br><span class="line">    <span class="keyword">goto</span> label ;</span><br><span class="line">	label : statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运算符：&amp;&amp;、||、?:</span><br><span class="line"></span><br><span class="line">函数：getchar()、<span class="built_in">putchar</span>()、ctype.h系列</span><br><span class="line"></span><br><span class="line">使用C的字符I/O函数：getchar()和<span class="built_in">putchar</span>()</span><br><span class="line"></span><br><span class="line">ctype.h头文件提供的字符分析函数系列</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">&#x27; &#x27;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 	此题的putchar用法很具有新手参考性</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> ch;</span><br><span class="line">     ch = getchar();<span class="comment">// 读取一个字符</span></span><br><span class="line">     <span class="keyword">while</span> (ch != <span class="string">&#x27;\n&#x27;</span>)<span class="comment">// 当一行未结束时</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch==SPACE)<span class="comment">// 留下空格</span></span><br><span class="line">          <span class="built_in">putchar</span>(ch);<span class="comment">// 该字符不变</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">putchar</span>(ch + <span class="number">1</span>);<span class="comment">// 改变其他字符</span></span><br><span class="line">          ch = getchar();<span class="comment">// 获取下一个字符</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">putchar</span>(ch);<span class="comment">// 打印换行符</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="include-lt-ctype-h-gt"><a href="#include-lt-ctype-h-gt" class="headerlink" title="#include&lt;ctype . h&gt;"></a>#include&lt;ctype . h&gt;</h2><p><img src="https://i.loli.net/2021/06/20/r2PSafBoVwUqQGv.png" alt="image-20210112144943937"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> ch;</span><br><span class="line">     <span class="keyword">while</span> ((ch=getchar())!= <span class="string">&#x27;\n&#x27;</span>)<span class="comment">// 当一行未结束时</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch))<span class="comment">// 留下空格</span></span><br><span class="line">          <span class="built_in">putchar</span>(ch+<span class="number">1</span>);<span class="comment">// 该字符不变</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">putchar</span>(ch);<span class="comment">// 改变其他字符</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">putchar</span>(ch);<span class="comment">// 打印换行符</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="include-lt-iso646-h-gt"><a href="#include-lt-iso646-h-gt" class="headerlink" title="#include&lt;iso646.h&gt;"></a>#include&lt;iso646.h&gt;</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果在程序中包含该头文件，便可用<span class="keyword">and</span>代替&amp;&amp;、<span class="keyword">or</span>代替||、<span class="keyword">not</span>代替!。</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>C保证逻辑表达式的求值顺序是从左往右。&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。</strong></p>
<p>！（非） 的优先级比括号低，比乘法等运算符都高，与递增运算符优先级相同。</p>
<p><strong>&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!(<span class="number">6</span> &gt; <span class="number">2</span> &amp;&amp; <span class="number">3</span> == <span class="number">3</span>)　　　<span class="comment">// 假 ！（非） 还可以这样写 不一定就是 ！= 这样写。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">90</span> &lt;= range &lt;= <span class="number">100</span>)　　<span class="comment">// 千万不要这样写！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good show!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题（虽然可能会给出警告）。由于&lt;=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(90 &lt;= range) &lt;= 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子表达式90 &lt;= range的值要么是1（为真），要么是0（为假）。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&amp;&amp;。*/</span></span><br></pre></td></tr></table></figure>

<h4 id="范围请务必用-amp-amp-符号；"><a href="#范围请务必用-amp-amp-符号；" class="headerlink" title="范围请务必用   &amp;&amp;  符号；"></a><strong>范围请务必用   &amp;&amp;  符号；</strong></h4><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = (y &lt; <span class="number">0</span>) ? -y : y;   <span class="comment">// expression1 ? expression2 : expression3;</span></span><br></pre></td></tr></table></figure>





<h1 id="第六章-字符输入-输出-和-字符验证"><a href="#第六章-字符输入-输出-和-字符验证" class="headerlink" title="第六章     字符输入  /  输出 和   字符验证"></a>第六章     字符输入  /  输出 和   字符验证</h1><h3 id="有缓冲区和没有缓冲区"><a href="#有缓冲区和没有缓冲区" class="headerlink" title="有缓冲区和没有缓冲区"></a>有缓冲区和没有缓冲区</h3><p>有缓冲区又分为  行缓冲 和  完全缓冲</p>
<p>完全缓冲就是缓冲区被填满在刷新缓冲区，缓冲区的大小取决于系统。</p>
<p>行缓冲就是出现换行符时刷新缓冲区。</p>
<h2 id="putchar-and-getchar"><a href="#putchar-and-getchar" class="headerlink" title="putchar and getchar"></a>putchar and getchar</h2><p>在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值</p>
<p>即EOF（end of file的缩写）。</p>
<p>scanf()函数检测到文件结尾时也返回EOF。</p>
<h4 id="getchar（）"><a href="#getchar（）" class="headerlink" title="getchar（）"></a>getchar（）</h4><p>通常getchar（）函数返回值在0-127之间，这些值对应标准的字符集。</p>
<p>如果系统能够实别扩展字符集的话，getchar（）返回值范围可以时0-255之间。</p>
<p>所以我们getchar（）标记文章结尾返回值定义为  -1( #define EOF (-1) )，因为不属于以上区间。</p>
<p>getchar()函数实际返回值的类型是int，所以它可以读取EOF字符。</p>
<p>EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。</p>
<h4 id="如何使用EFO判断文件是否结尾"><a href="#如何使用EFO判断文件是否结尾" class="headerlink" title="如何使用EFO判断文件是否结尾"></a>如何使用EFO判断文件是否结尾</h4><p>我们看如下代码:<br>我们自定义一个  ‘#’ 来结束输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> ch;</span><br><span class="line">     <span class="keyword">while</span> (( ch = getchar() ) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">         <span class="built_in">putchar</span>(ch);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果你和我一样是windows系统,按下ctrl+z就可以结束输入.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ch;</span><br><span class="line">     <span class="keyword">while</span> (( ch = getchar() ) != EOF)</span><br><span class="line">         <span class="built_in">putchar</span>(ch);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个程序和文件之间</span><br><span class="line">$　echo_eof　&lt;　words</span><br><span class="line"></span><br><span class="line">$　echo_eof　&gt;　mywords</span><br><span class="line"></span><br><span class="line">命令与重定向顺序无关,文件名不能相同.</span><br><span class="line">echo_eof &lt; mywords &gt; savewords  echo_eof &gt; savewords &lt; mywords</span><br><span class="line"></span><br><span class="line">还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输入。</span><br></pre></td></tr></table></figure>



<h1 id="第七章-数组-array"><a href="#第七章-数组-array" class="headerlink" title="第七章 数组 (array)"></a>第七章 数组 (array)</h1><p>如果flizy是一个数组</p>
<p>那么 array == &amp; array [ 0 ];<br>每一个数组的数组名就是该数组首元素的地址.</p>
<p><strong>使用数组尽量像下面这样去使用数组长度,这样就不会因为脑袋一抽而下标越界.</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.........</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>　arr[SIZE];</span><br><span class="line">    <span class="keyword">for</span>　(i　=　<span class="number">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class="line">        ............</span><br><span class="line">        ............</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span> bbb [<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">// 可以像这样</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">// 但是下面这个样子是错误的</span></span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	int aaa [10];</span></span><br><span class="line"><span class="comment">     aaa[10] = &#123;1,2,3,4,5&#125;; 或 aaa[] = &#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">     这样赋值是不起作用的.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="数组的下标"><a href="#数组的下标" class="headerlink" title="数组的下标:"></a>数组的下标:</h3><p>数组下标必须大于 0 而且必须是整数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">5</span>,n = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">array</span> [<span class="number">5</span>*<span class="number">2</span>+<span class="number">1</span>]        		<span class="comment">//可以 </span></span><br><span class="line">	<span class="built_in">array</span> [<span class="keyword">sizeof</span>(<span class="keyword">int</span>)+<span class="number">1</span>]        <span class="comment">//可以 </span></span><br><span class="line">     <span class="built_in">array</span> [(<span class="keyword">int</span>)<span class="number">2.5</span>]     		<span class="comment">//可以 </span></span><br><span class="line">    <span class="built_in">array</span> [m] <span class="keyword">or</span> <span class="built_in">array</span>[n]  <span class="comment">//C之前不行,现在可以 </span></span><br></pre></td></tr></table></figure>





<p>与变量一样,使用数组之前应该首先初始化它.</p>
<p><strong>当初始化不完全时,编译器会把剩余没有初始化的数组元素自动初始化为0</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 直接打印未初始化的数组,内容是内存里的垃圾数据.</span></span><br><span class="line">     <span class="keyword">int</span> a [size];	</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%2s%14s\n&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;a[i]&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,a[i]);</span><br><span class="line">    <span class="comment">// 如下面这样单独有针对性的初始化两个数组原属后,未初始化的依旧是内存哪里数据</span></span><br><span class="line">     a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">     a[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*******************************\n&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 但是如下再声明时初始化后,未被初始化的元素将自动被编译器初始化为 0</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*******************************\n&quot;</span>);   </span><br><span class="line">     <span class="keyword">int</span> b [size] = &#123;<span class="number">10</span>,<span class="number">11</span>&#125;; </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,b[i]);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为:</span></span><br><span class="line"></span><br><span class="line">     i          a[i]</span><br><span class="line">     <span class="number">0</span>             <span class="number">8</span></span><br><span class="line">     <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">     <span class="number">2</span>            <span class="number">60</span></span><br><span class="line">     <span class="number">3</span>             <span class="number">0</span></span><br><span class="line">    *******************************</span><br><span class="line">     <span class="number">0</span>            <span class="number">10</span></span><br><span class="line">     <span class="number">1</span>            <span class="number">11</span></span><br><span class="line">     <span class="number">2</span>            <span class="number">60</span></span><br><span class="line">     <span class="number">3</span>             <span class="number">0</span></span><br><span class="line">    *******************************</span><br><span class="line">     <span class="number">0</span>            <span class="number">10</span></span><br><span class="line">     <span class="number">1</span>            <span class="number">11</span></span><br><span class="line">     <span class="number">2</span>             <span class="number">0</span></span><br><span class="line">     <span class="number">3</span>             <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>那初始化多于数组长度呢?</p>
<p>书上说会报错,但是我没有报错耶…(迷惑,难道是我理解错了?</p>
<p>以下为书中原话:</p>
<p><strong>如上所示，编译器做得很好。当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。</strong></p>
<p><strong>如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会毫不留情地将其视为错误。但是，没必要因此嘲笑编译器。其实，可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数</strong></p>
<p>我的C语言环境是:</p>
<p> <strong>MinGW-w64</strong>(编译器)  +  vscode(编辑器)  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,<span class="built_in">array</span>[i]);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出结果如下:</span></span><br><span class="line"><span class="comment"> 0             1</span></span><br><span class="line"><span class="comment"> 1             2</span></span><br><span class="line"><span class="comment"> 2             3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">212</span>&#125;; <span class="comment">// 传统的语法</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">6</span>] = &#123;[<span class="number">5</span>] = <span class="number">212</span>&#125;; <span class="comment">// 把arr[5]初始化为212</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>]=<span class="number">13</span>&#125;;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,<span class="built_in">array</span>[i]);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">     0             1</span></span><br><span class="line"><span class="comment">     1             2</span></span><br><span class="line"><span class="comment">     2            13    //原本是3 但是被后面这样</span></span><br><span class="line"><span class="comment">     3             0</span></span><br><span class="line"><span class="comment">     4             0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我们再看看下面代码:</p>
<p>当用初始化器时给第几个数组元素初始化后, 初始化列表中其后面赋值将从这个被初始化器复制的元素下标开始再依次往后赋值.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;[<span class="number">4</span>] =  <span class="number">40</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,[<span class="number">2</span>]=<span class="number">13</span>&#125;;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,<span class="built_in">array</span>[i]);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     0             0</span></span><br><span class="line"><span class="comment">     1             0</span></span><br><span class="line"><span class="comment">     2            13</span></span><br><span class="line"><span class="comment">     3             0</span></span><br><span class="line"><span class="comment">     4            40  </span></span><br><span class="line"><span class="comment">     5             5</span></span><br><span class="line"><span class="comment">     6             6</span></span><br><span class="line"><span class="comment">     7             7</span></span><br><span class="line"><span class="comment">     8             0</span></span><br><span class="line"><span class="comment">     9             0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组 :"></a>一维数组 :</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名 [数组长度]  <span class="comment">//其中数组长度要大于0</span></span><br><span class="line">    <span class="keyword">double</span> balance [<span class="number">5</span>];   <span class="comment">// 现在balance是一个可用数组 , 长度为 5</span></span><br><span class="line">	<span class="comment">// 声明数组元素</span></span><br><span class="line">	<span class="keyword">double</span> apple[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2.5</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="comment">// 不填确定长度的话数组长度就会默认是元素个数.</span></span><br><span class="line">	<span class="keyword">double</span> banana[] = &#123;<span class="number">1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h3 id="创建只读数组"><a href="#创建只读数组" class="headerlink" title="创建只读数组"></a>创建只读数组</h3><p>一但声明为 const 就不能再给这个数组赋值.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面这样是可以的</span></span><br><span class="line"><span class="keyword">int</span> lenght = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[lenght];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是这样却有问题,试了试.</span></span><br><span class="line"><span class="keyword">int</span> lenght;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;lenght);</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[lenght];</span><br><span class="line"></span><br><span class="line">所以为了能够应付接收长度作为数组长度</span><br><span class="line">    <span class="comment">// 就需要使用到malloc()函数来动态分配内存</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(lenght * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>







<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>C语言中二维数组作为参数时必须至少指定第二维长度</strong></p>
<p>1、可以同时指定第一维和第二维的长度；</p>
<p>2、可以只指定第二维的长度；</p>
<p>3、不可以只指定第一维的长度；</p>
<p>4、不可以第一维和第二维的长度都不指定。</p>
<p>综上所述，至少指定第二维的长度。</p>
<p>原因：一维数组存放在一段连续的内存中，二维数组的维度是逻辑上的概念，而实际上，二维数组在内存中也是一段连续的空间，与一维数组相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span> [<span class="number">3</span>] [<span class="number">5</span>] ; <span class="comment">// 有三个int类型数组,这三个数组长度都是5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">     &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line">     &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line">     &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写也可以,但是不如上面那样美观,不推荐.</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>C语言中的多维数组不允许包含长度不一的数组<br>但是创建一个指针数组,然后指针数组里的每一个指针都指向一个数组,这样就可以相当于一个多维数组,并且里面这个多维数组里面的数组的长度可以不一样.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* Array[<span class="number">3</span>];  <span class="comment">// 创建指针数组.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array01 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> array02 = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> array03 = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line"></span><br><span class="line">Array[<span class="number">0</span>] = array01;</span><br><span class="line">Array[<span class="number">1</span>] = array02;</span><br><span class="line">Array[<span class="number">2</span>] = array03;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>* Array[<span class="number">3</span>];  <span class="comment">// 创建指针数组.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array01 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> array02 = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> array03 = &#123;<span class="number">22</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line"></span><br><span class="line">     Array[<span class="number">0</span>] = array01;</span><br><span class="line">     Array[<span class="number">1</span>] = array02;</span><br><span class="line">     Array[<span class="number">2</span>] = array03;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Array[0] = array01 :%d\n&quot;</span>,Array[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Array[1] = array02 :%d\n&quot;</span>,Array[<span class="number">1</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Array[2] = array03 :%d\n&quot;</span>,Array[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p><strong>变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern存储类别说明符</strong></p>
<p><strong>double sales[regions] [quarters];</strong></p>
<p><strong>int sum2d(int rows, int cols, int ar[rows][cols]);</strong></p>
<h2 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h2><p>因为复合字面量是匿名的,所以必须<strong>在创建的同时在使用它</strong>;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// 正常数组声明</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> [<span class="number">3</span>]) = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 复合字面量 &gt;&gt; 相当于数组的常量  int [3]&gt;&gt;即是复合字面量的类型名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化复合字面量同样可以省略自定义长度 计算机会自动计算</span></span><br><span class="line">(<span class="keyword">double</span> []) = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;   <span class="comment">// 会自动自己算长度 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针 指向复合字面量</span></span><br><span class="line"><span class="keyword">int</span> * pt1;</span><br><span class="line">pt1 = (<span class="keyword">int</span> [<span class="number">2</span>]) &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把复合字面量做参数,传给带有匹配形式参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum</span><span class="params">(<span class="keyword">const</span>　<span class="keyword">int</span>　ar[],　<span class="keyword">int</span>　n)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> total3;</span><br><span class="line">total3 = sum((<span class="keyword">int</span> [])&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 好处是把信息传入函数前,不用先创建数组.</span></span><br></pre></td></tr></table></figure>





<h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h2><p>枚举是 C 语言中的一种基本数据类型</p>
<p>枚举一般被定义为 int  或者  unsigned int 类型 , 所以不能定义字符 浮点等类型.</p>
<p>枚举里面用逗号隔开,大括号后面要打分号结尾.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//定义第一个变量后,后面的变量被赋予的值都是在前一个变量的基础上 +1</span></span><br><span class="line"> <span class="comment">// 如果不定义第一个变量的值,就会默认值为 0 </span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">CHARATER</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line">     A = <span class="number">1</span>,B,C,D,E,F,G </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义枚举的同时定义枚举变量</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">CHARATER</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line">     A = <span class="number">1</span>,B,C,D,E,F,G </span><br><span class="line"> &#125;letter;</span><br><span class="line"><span class="comment">// 也可省略枚举名</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line">     A = <span class="number">1</span>,B,C,D,E,F,G </span><br><span class="line"> &#125;letter;</span><br></pre></td></tr></table></figure>

<p>见如下代码,可知可以直接对枚举成员调用:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="comment">//定义第一个变量后,后面的变量被赋予的值都是在前一个变量的基础上 +1</span></span><br><span class="line">    <span class="comment">// 如果不定义第一个变量的值,就会默认值为 0 </span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CHARATER</span></span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">        A1 = <span class="number">1</span>,B1,C1,D1,E1,F1,G1 </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 定义枚举的同时定义枚举变量</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CHARATER2</span></span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">        A2 = <span class="number">11</span>,B2,C2,D2,E2,F2,G2 </span><br><span class="line">    &#125;letter_2;</span><br><span class="line">    <span class="comment">// 也可省略枚举名</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">        A3 = <span class="number">21</span>,B3,C3,D3,E3,F3,G3</span><br><span class="line">    &#125;letter_3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个枚举,在main方法里面声明他的变量,</span></span><br><span class="line">    <span class="comment">// 可以创建一个CHARATER的变量用来接收枚举元素的值.</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CHARATER</span> <span class="title">letter</span>;</span></span><br><span class="line">    letter = C1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  不声明 一样可以直接输出</span></span><br><span class="line"><span class="comment">//    enum CHARATER2 letter_2;</span></span><br><span class="line">    letter_2 = D2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举名不定义 一样可以直接用</span></span><br><span class="line">    letter_3 = D3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;letter is %d %d\n&quot;</span>,D1,C1); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;letter_2 is %d \n&quot;</span>,letter_2); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;letter_3 is %d \n&quot;</span>,letter_3); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历枚举"><a href="#遍历枚举" class="headerlink" title="遍历枚举"></a>遍历枚举</h3><p>正因为连续 我们用For循环可以遍历它</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历 CHARATER 这个枚举 </span></span><br><span class="line"><span class="keyword">for</span> (letter = A1; letter &lt; G1; letter++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,letter);</span><br></pre></td></tr></table></figure>

<p>但是像如下这种没规律的枚举则不可遍历:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">No_regular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    n_regular_one,			<span class="comment">// 默认为 0</span></span><br><span class="line">    n_regular_three = <span class="number">33</span>,</span><br><span class="line">    n_regular_eleven 		<span class="comment">// 值是34 默认前位加1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对枚举赋值"><a href="#对枚举赋值" class="headerlink" title="对枚举赋值"></a>对枚举赋值</h3><p>既然我们说过枚举是一种变量类型,那么当然我们给枚举赋值时需要转换类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">No_regular</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        n_regular_one,</span><br><span class="line">        n_regular_three,</span><br><span class="line">        n_regular_eleven</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没赋值之前:%d\n&quot;</span>,n_regular_eleven);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	下面这样直接赋值是不对的!!!</span></span><br><span class="line"><span class="comment">	n_regular_eleven = a;</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 显得声明这个枚举和他的变量</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">No_regular</span> <span class="title">n_regular_eleven</span>;</span></span><br><span class="line">    n_regular_eleven = (<span class="keyword">enum</span> No_regular) a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;赋值之后:%d\n&quot;</span>,n_regular_eleven);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字const。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。</p>
<h1 id="第八章-指针-pointer"><a href="#第八章-指针-pointer" class="headerlink" title="第八章 指针(pointer)"></a>第八章 指针(pointer)</h1><p>&amp; * 这两个都表示一元<br>&amp;   &gt;&gt;  地址与那算符</p>
<p>flizny 是一个数组</p>
<p>flizny == &amp;flizny[0]; // 数组名是该数组首元素的地址<br>转换说明%p通常以十六进制显示指针的值</p>
<p>在指针前面使用*运算符可以得到该指针所指向对象的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>　urn[<span class="number">5</span>]　=　&#123;　<span class="number">100</span>,　<span class="number">200</span>,　<span class="number">300</span>,　<span class="number">400</span>,　<span class="number">500</span>　&#125;;</span><br><span class="line">ptr1 = urn;　　　　　　　<span class="comment">// 把一个地址赋给指针</span></span><br><span class="line">ptr2 = &amp;urn[<span class="number">2</span>];　　　　 <span class="comment">// 把一个地址赋给指针</span></span><br></pre></td></tr></table></figure>



<p>至于C语言，ar[i]和*(ar+i)这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用ar++这样的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dates + <span class="number">2</span> == &amp;date[<span class="number">2</span>]　　　 <span class="comment">// 相同的地址</span></span><br><span class="line">    </span><br><span class="line">*(dates + <span class="number">2</span>) == dates[<span class="number">2</span>]　 <span class="comment">// 相同的值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*(dates + 2):到内存dates的地址,向后移动2个单检索存储在哪的数据的值.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>一个指针未被初始化时,铁定不要使用.<br>当一个指针不知道赋给它何值时,那么赋 null 值 是个好习惯.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int  *ptr = NULL;</span><br></pre></td></tr></table></figure>



<p>下面就是严重的错误例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;<span class="comment">// 未初始化的指针</span></span><br><span class="line">*pt = <span class="number">5</span>;　　　<span class="comment">// 严重的错误</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *j = &amp;i;  <span class="comment">//*j表示一个指针变量, 将变量i的地址赋给它</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*j = %d\n&quot;</span>, *j);  <span class="comment">//此时*j完全等同于i</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);    <span class="comment">//j里面存储的是变量i的地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">有效语句　　　　　　　　　　无效语句</span><br><span class="line">ptr1++;　　　　　　　　　　　　 urn++;</span><br><span class="line">ptr2　=　ptr1　+　<span class="number">2</span>;　　　　　 ptr2　=　ptr2　+　ptr1;</span><br><span class="line">ptr2　=　urn　+　<span class="number">1</span>;　　　　　　 ptr2　=　urn　*　ptr1;</span><br></pre></td></tr></table></figure>

<p>指针数组</p>
<p>函数指针</p>
<p>指向指针的指针数组</p>
<p>指向函数的指针数组</p>
<h3 id="函数-数组-和-指针"><a href="#函数-数组-和-指针" class="headerlink" title="函数 数组 和 指针"></a>函数 数组 和 指针</h3><p>在声明一个要使用数组作为参数的函数时,以下四种方法都可以:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum</span><span class="params">(<span class="keyword">int</span>　ar[],　<span class="keyword">int</span>　n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum</span><span class="params">(<span class="keyword">int</span>　[],　<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是,在定义函数的时候,不能省略参数名:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 其他代码已省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum</span><span class="params">(<span class="keyword">int</span>　ar[],　<span class="keyword">int</span>　n)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//其他代码已省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="comment">// 声明时省略参数名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> *start,<span class="keyword">int</span> *end )</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> marbles[SIZE] = &#123; <span class="number">30</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span>&#125;;</span><br><span class="line">     <span class="keyword">long</span> answer;</span><br><span class="line">     answer = SUM(marbles,marbles + SIZE);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The　total　number　of　marbles　is　%ld.\n&quot;</span>, answer);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> *start,<span class="keyword">int</span> *end )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">          total = total + *start;  <span class="comment">//数组元素的总和</span></span><br><span class="line">          start++;	<span class="comment">//指向下一个元素</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>指针与整数相加：</p>
<p>可以使用+运算符把指针与整数相加，或整数与指针相加。<br>无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。<br>因此 p1 + 4与&amp;urn[4]等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。<br>除非正好超过数组末尾第一个位置，C保证该指针有效。</p>
<p>同一个int类型的数组中两个元素指针之间的差值表示这两个元素之间相隔几个int</p>
<p><strong>C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效。</strong></p>
<p><strong>使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</strong><br><strong>注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// total = total + *start++;  先把原值用来运算 在指向下一个元素</span></span><br><span class="line"><span class="comment">// total = total + *++start;  先指向下一个元素 在把值用来运算</span></span><br><span class="line"><span class="comment">// total = total + (*start)++; 先指向值用来运算,再再原来的值上加一</span></span><br><span class="line"><span class="comment">// *(start++) 和这个  *start++  效果一样的 </span></span><br></pre></td></tr></table></figure>



<h2 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a>保护数组中的数据</h2><p><strong>如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const</strong></p>
<p>这个const并不是表示把数组定义为常量,而是指函数在处理数组时会将这个数组视为常量.这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span> <span class="comment">/* 函数定义 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    	total += ar[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-运用"><a href="#const-运用" class="headerlink" title="const 运用"></a>const 运用</h3><p>虽然用#define指令可以创建类似功能的符号常量，<br>但是const的用法更加灵活。可以创建const数组、const指针和指向const的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pd = rates;　　 <span class="comment">// pd指向数组的首元素</span></span><br><span class="line"><span class="comment">// 虽然pd不可改变其指向的指,但是可以让它指向别处</span></span><br><span class="line"><span class="comment">// 如 : pd++; 表示指向rates[1]  -- 没问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>const关键字初始化了的指针.可以给他赋值 const关键字声明过的 数组,也可以给它赋值普通(没用const声明)数组元素,都是表示这个const声明的指针它不可改变.<br>但是 普通的指针就只能够接收普通的数组,变量之类的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>　<span class="keyword">double</span>　locked[<span class="number">4</span>]　=　&#123;<span class="number">0.08</span>,　<span class="number">0.075</span>,　<span class="number">0.0725</span>,　<span class="number">0.07</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pc = rates; <span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">pc = locked;　　　　　　　　 <span class="comment">//有效</span></span><br><span class="line"></span><br><span class="line">pc = &amp;rates[<span class="number">3</span>];　　　　　　　<span class="comment">//有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然而，只能把非const数据的地址赋给普通指针：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>　<span class="keyword">double</span>　locked[<span class="number">4</span>]　=　&#123;<span class="number">0.08</span>,　<span class="number">0.075</span>,　<span class="number">0.0725</span>,　<span class="number">0.07</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> * pnc = rates;　<span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">pnc = locked;　　　　　 <span class="comment">// 无效</span></span><br><span class="line"></span><br><span class="line">pnc = &amp;rates[<span class="number">3</span>];　　　　<span class="comment">// 有效</span></span><br></pre></td></tr></table></figure>

<h4 id="const关键字可以声明并初始化一个不能指向别处的指针"><a href="#const关键字可以声明并初始化一个不能指向别处的指针" class="headerlink" title="const关键字可以声明并初始化一个不能指向别处的指针"></a>const关键字可以声明并初始化一个不能指向别处的指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double * const pc = rates;</span><br></pre></td></tr></table></figure>


<p>表示只能指向这个rates数组(也就是数组第一个rates[0]),不可以更改成其他地址,但是可以更改rates[0]的值.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>] = &#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> * <span class="keyword">const</span> pc = rates;<span class="comment">// pc指向数组的开始</span></span><br><span class="line">pc = &amp;rates[<span class="number">2</span>];<span class="comment">// 不允许，因为该指针不能指向别处</span></span><br><span class="line">*pc = <span class="number">92.99</span>;<span class="comment">// 没问题 -- 更改rates[0]的值</span></span><br></pre></td></tr></table></figure>



<p>那么 你既希望一个指针只指向一个地址,并且还不能够修改这个指向地址的值,那么可以用const声明两次.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> pc = rates;</span><br><span class="line">pc = &amp;rates[<span class="number">2</span>];　　<span class="comment">//不允许赋值其他地址</span></span><br><span class="line">*pc = <span class="number">92.99</span>;　　　<span class="comment">//不允许修改其地址上的数据.</span></span><br></pre></td></tr></table></figure>





<h2 id="指针和多维指针"><a href="#指针和多维指针" class="headerlink" title="指针和多维指针"></a>指针和多维指针</h2><p>处理多维数组时,我们需要用到多维指针.</p>
<p>int zippo[4] [2]; /* 内含int数组的数组 */<br>在本例中，zippo的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。</p>
<p>因为zippo是数组首元素的地址，所以zippo的值和&amp;zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址（即&amp;zippo[0] [0]的值）相同。简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">          &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,    <span class="comment">// -- array[0]</span></span><br><span class="line">          &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">          &#123;<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;array = %p,array+1 = %p\n&quot;</span>,<span class="built_in">array</span>,<span class="built_in">array</span>+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %p,array[0]+1 = %p\n&quot;</span>,<span class="built_in">array</span>[<span class="number">0</span>],<span class="built_in">array</span>[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*array = %p,*array+1 = %p\n&quot;</span>,*<span class="built_in">array</span>,*<span class="built_in">array</span>+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;array[0][0] = %d\n&quot;</span>,<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*array[0] = %d\n&quot;</span>,*<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;**array = %d\n&quot;</span>,**<span class="built_in">array</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;array[2][1] = %d\n&quot;</span>,<span class="built_in">array</span>[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*(*(array+2)+1) = %d \n&quot;</span>,*(*(<span class="built_in">array</span>+<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="指向多维数组的指针"><a href="#指向多维数组的指针" class="headerlink" title="指向多维数组的指针"></a>指向多维数组的指针</h2><p>如何声明一个指针变量pz指向一个二维数组（如，zippo）？在编写处理类似zippo这样的二维数组时会用到这样的指针。把指针声明为指向int的类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指向一个int类型值，其声明如下：</p>
<p>int (* pz)[2];　　// pz指向一个内含两个int类型值的数组</p>
<p>以上代码把pz声明为指向一个数组的指针，该数组内含两个int类型值。为什么要在声明中使用圆括号？因为[]的优先级高于*。考虑下面的声明：</p>
<p>int * pax[2];　　<br> // pax是一个内含两个指针元素的数组，每个元素都指向int的指针</p>
<p>由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数组。然后<em>表示pax数组内含两个指针。最后，int表示pax数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号的版本，</em>先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针。程序清单10.16演示了如何使用指向二维数组的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">          &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,    <span class="comment">// -- array[0]</span></span><br><span class="line">          &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">          &#123;<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">          &#123;<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">int</span>(*pz)[<span class="number">2</span>];</span><br><span class="line">     pz=<span class="built_in">array</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;pz=%p,pz+1=%p\n&quot;</span>,pz,pz+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;pz[0]=%p,pz[0]+1=%p\n&quot;</span>,pz[<span class="number">0</span>],pz[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;　*pz = %p,　 *pz + 1 = %p\n&quot;</span>,*pz, *pz + <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;pz[0][0]　=　%d\n&quot;</span>,pz[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;　*pz[0] = %d\n&quot;</span>, *pz[<span class="number">0</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;　 **pz = %d\n&quot;</span>, **pz);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;　pz[2][1]　=　%d\n&quot;</span>,pz[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*(*(pz+2) + 1) = %d\n&quot;</span>, *(*(pz + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zippo[m][n] == *(*(zippo + m) + n)</span><br><span class="line">pz[m][n] == *(*(pz + m) + n)</span><br></pre></td></tr></table></figure>



<h2 id="数组的兼容性"><a href="#数组的兼容性" class="headerlink" title="数组的兼容性"></a>数组的兼容性</h2><p>创建一个指针时,一定要明确这个指针的指向.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 <span class="keyword">int</span> 类型的值赋给<span class="keyword">double</span>类型的变量，但是两个类型的指针不能这样做。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>　n　=　<span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span>　x;</span><br><span class="line"><span class="keyword">int</span> * p1 = &amp;n;</span><br><span class="line"><span class="keyword">double</span> * pd = &amp;x;</span><br><span class="line">x = n;　　　　　　　<span class="comment">// 隐式类型转换</span></span><br><span class="line">pd = p1;　　　　　　<span class="comment">// 编译时错误</span></span><br><span class="line"></span><br><span class="line">更复杂的类型也是如此。假设有如下声明：</span><br><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>　ar1[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>　ar2[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> **p2; <span class="comment">// 一个指向指针的指针</span></span><br><span class="line"></span><br><span class="line">有如下的语句：</span><br><span class="line">pt = &amp;ar1[<span class="number">0</span>][<span class="number">0</span>];　<span class="comment">// 都是指向int的指针</span></span><br><span class="line">pt = ar1[<span class="number">0</span>];　　　 <span class="comment">// 都是指向int的指针</span></span><br><span class="line">pt = ar1;　　　　　 <span class="comment">// 无效</span></span><br><span class="line">pa = ar1;　　　　　 <span class="comment">// 都是指向内含3个int类型元素数组的指针</span></span><br><span class="line">pa = ar2;　　　　　 <span class="comment">// 无效</span></span><br><span class="line">p2 = &amp;pt;　　　　 <span class="comment">// both pointer-to-int *</span></span><br><span class="line">*p2 = ar2[<span class="number">0</span>];　　 <span class="comment">// 可以 都是指向int的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面式子无效,因为ar2是指向数组的指针,p2时指向指针的指针,但是它指向 int 类型,为不是数组类型*/</span></span><br><span class="line">p2 = ar2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*********************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>　x　=　<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span>　<span class="keyword">int</span>　y　=　<span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> * p1 = &amp;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p2 = &amp;y;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ** pp2;</span><br><span class="line">p1 = p2;　　　 <span class="comment">// 不安全 -- 把const指针赋给非const指针</span></span><br><span class="line">p2 = p1;　　　 <span class="comment">// 有效 -- 把非const指针赋给const指针</span></span><br><span class="line">pp2 = &amp;p1;　　<span class="comment">// 不安全 –- 嵌套指针类型赋值</span></span><br><span class="line">前面提到过，把<span class="keyword">const</span>指针赋给非<span class="keyword">const</span>指针不安全，因为这样可以使用新的指针改变<span class="keyword">const</span>指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非<span class="keyword">const</span>指针赋给<span class="keyword">const</span>指针没问题，前提是只进行一级解引用：</span><br><span class="line"></span><br><span class="line">p2 = p1; <span class="comment">// 有效 -- 把非const指针赋给const指针</span></span><br><span class="line"></span><br><span class="line">但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代码：</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **pp2;</span><br><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">const</span>　<span class="keyword">int</span>　n　=　<span class="number">13</span>;</span><br><span class="line">pp2 = &amp;p1;　　<span class="comment">// 允许，但是这导致const限定符失效（根据第1行代码，不能通过*pp2修改它所指向的内容）</span></span><br><span class="line">*pp2 = &amp;n;　　<span class="comment">// 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修改）</span></span><br><span class="line">*p1 = <span class="number">10</span>;<span class="comment">//有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发生了什么？如前所示，标准规定了通过非const指针更改const数据是未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编译包含以上代码的小程序，导致n最终的值是13，但是在相同系统下使用clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果都是未定义的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int *p1 = &amp;x 错误,只能把非const数据地址赋值给普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;x;</span><br><span class="line"><span class="keyword">int</span> *p2 = p1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 但是 const指针接收const 数据地址却可以赋值给普通指针,如果这样做的话会非常不安全,因为可以普通指针就变得可以修改用const 声明的数据的值了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="变长数组-1"><a href="#变长数组-1" class="headerlink" title="变长数组"></a>变长数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2d</span><span class="params">(<span class="keyword">int</span> ar[rows][cols], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>; <span class="comment">// 无效的顺序</span></span><br><span class="line"></span><br><span class="line">C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2d</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> ar[*][*])</span></span>; <span class="comment">// ar是一个变长数组（VLA），省略了维度形参名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS 4</span></span><br><span class="line"><span class="comment">// 变长数组 声明方式,先声明变量参数,再声明数组.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> clos , <span class="keyword">int</span> ar[row][clos])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int sum(int ar[rows][cols], int rows, int cols); // 无效的顺序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以省略参数,在定义函数的时候再写</span></span><br><span class="line"><span class="comment">int sum(int, int, int ar[*][*]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">int</span> rs = <span class="number">3</span>;</span><br><span class="line">     <span class="keyword">int</span> cs = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">int</span> junk[ROWS][COLS] = &#123;</span><br><span class="line">          &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">          &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;,</span><br><span class="line">          &#123;<span class="number">12</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>&#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> morejunk[ROWS<span class="number">-1</span>][COLS+<span class="number">2</span>] = &#123;</span><br><span class="line">          &#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;,</span><br><span class="line">          &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span> varr[rs][cs];  <span class="comment">//变长数组</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;rs;i++)&#123;  <span class="comment">//给varr数组初始化</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;cs;j++)</span><br><span class="line">               varr[i][j] = i*j+j;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;3 X 4  array\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Sum　of　all　elements　=　%d\n&quot;</span>,sum(ROWS,COLS,junk));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;2x6　array\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Sum　of　all　elements　=　%d\n&quot;</span>,sum(ROWS<span class="number">-1</span>,COLS+<span class="number">2</span>,morejunk));</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;3x10　VLA\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Sum　of　all　elements　=　%d\n&quot;</span>,sum(rs,cs,varr));</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> clos , <span class="keyword">int</span> ar[row][clos])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row;i++)&#123;  <span class="comment">//给varr数组初始化</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;clos;j++)</span><br><span class="line">               total += ar[i][j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="复合字面量-1"><a href="#复合字面量-1" class="headerlink" title="复合字面量"></a>复合字面量</h2><p>假如要给一个int类型的函数传一个值,这个值可以是一个变量,也可以是一个常量,但是如果传数组,你会发现没有常量的数组,所以就出现了复合字面量.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int diva[2] = &#123;10, 20&#125;;  //普通数组声明</span><br><span class="line">(int [2])&#123;10, 20&#125;　　　// 复合字面量</span><br><span class="line">(int [])&#123;50, 20, 90&#125; // 和数组一样,可以省略[]中的长度.</span><br></pre></td></tr></table></figure>

<p>复合字面量必须在创建的同时使用它,不能创建之后再使用<br>与数组名类似,复合字面量的类型名也带表首元素地址.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * pt1;</span><br><span class="line">pt1 = (int [2]) &#123;10, 20&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　COLS　4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum2d</span><span class="params">(<span class="keyword">const</span>　<span class="keyword">int</span>　ar[][COLS],　<span class="keyword">int</span>　rows)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum</span><span class="params">(<span class="keyword">const</span>　<span class="keyword">int</span>　ar[],　<span class="keyword">int</span>　n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>　total1,　total2,　total3;</span><br><span class="line">    <span class="keyword">int</span> * pt1;</span><br><span class="line">    <span class="keyword">int</span>(*pt2)[COLS];</span><br><span class="line">    pt1　=　(<span class="keyword">int</span>[<span class="number">2</span>])　&#123;　<span class="number">10</span>,　<span class="number">20</span>　&#125;;</span><br><span class="line">    pt2　=　(<span class="keyword">int</span>[<span class="number">2</span>][COLS])　&#123;　&#123;<span class="number">1</span>,　<span class="number">2</span>,　<span class="number">3</span>,　<span class="number">-9</span>&#125;,　&#123;　<span class="number">4</span>,　<span class="number">5</span>,　<span class="number">6</span>,　<span class="number">-8</span>　&#125;　&#125;;</span><br><span class="line">    total1　=　sum(pt1,　<span class="number">2</span>);</span><br><span class="line">    total2　=　sum2d(pt2,　<span class="number">2</span>);</span><br><span class="line">    total3　=　sum((<span class="keyword">int</span>　[])&#123;　<span class="number">4</span>,　<span class="number">4</span>,　<span class="number">4</span>,　<span class="number">5</span>,　<span class="number">5</span>,　<span class="number">5</span>　&#125;,　<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total1　=　%d\n&quot;</span>,　total1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total2　=　%d\n&quot;</span>,　total2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total3　=　%d\n&quot;</span>,　total3);</span><br><span class="line">    <span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum</span><span class="params">(<span class="keyword">const</span>　<span class="keyword">int</span>　ar　[],　<span class="keyword">int</span>　n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>　i;</span><br><span class="line">    <span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>　(i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">    total　+=　ar[i];</span><br><span class="line">    <span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">sum2d</span><span class="params">(<span class="keyword">const</span>　<span class="keyword">int</span>　ar　[][COLS],　<span class="keyword">int</span>　rows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>　r;</span><br><span class="line">    <span class="keyword">int</span>　c;</span><br><span class="line">    <span class="keyword">int</span>　tot　=　<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>　(r　=　<span class="number">0</span>;　r　&lt;　rows;　r++)</span><br><span class="line">    <span class="keyword">for</span>　(c　=　<span class="number">0</span>;　c　&lt;　COLS;　c++)</span><br><span class="line">    tot　+=　ar[r][c];</span><br><span class="line">    <span class="keyword">return</span>　tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) total+=arr[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*如果不使用复合字面量，则需要以下代码</span></span><br><span class="line"><span class="comment">    char * str1=&quot;良い世、来いよ!&quot;;</span></span><br><span class="line"><span class="comment">    int arr1[]=&#123;1,1,4,5,1,4&#125;;</span></span><br><span class="line"><span class="comment">    str_print(str1);</span></span><br><span class="line"><span class="comment">    sum(arr1);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用复合字面量，代码如下：</span></span><br><span class="line">    str_print((<span class="keyword">char</span> *)<span class="string">&quot;良い世、来いよ!&quot;</span>); </span><br><span class="line">    sum((<span class="keyword">int</span> [])&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>&#125;); </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域，也就是说，一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在</p>
<h2 id="指针复习题-和编程题"><a href="#指针复习题-和编程题" class="headerlink" title="指针复习题 和编程题"></a>指针复习题 和编程题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>在下面的代码中，*ptr和*(ptr + <span class="number">2</span>)的值分别是什么？</span><br><span class="line"></span><br><span class="line">a.</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line"><span class="comment">//第一个为&#123;12,14&#125; 第二个数组为&#123;16,0&#125;</span></span><br><span class="line"><span class="keyword">int</span>　torf[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>&#125;; </span><br><span class="line">ptr　=　torf[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// *ptr : 12      *(ptr + 2) : 16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.</span><br><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line"><span class="comment">//声明数组其中元素后,其他元素默认变为0</span></span><br><span class="line"><span class="comment">//第一个为&#123;12,0&#125; 第二个数组为&#123;14,16&#125;</span></span><br><span class="line"><span class="keyword">int</span>　fort[<span class="number">2</span>][<span class="number">2</span>]　=　&#123;&#123;<span class="number">12</span>&#125;,&#123;<span class="number">14</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">ptr　=　fort[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//           *ptr : 12      *(ptr + 2) : 14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>在下面的代码中，**ptr和**(ptr + <span class="number">1</span>)的值分别是什么？</span><br><span class="line"></span><br><span class="line">a.</span><br><span class="line"><span class="comment">//指向含有两个int类型元素的数组指针</span></span><br><span class="line"><span class="keyword">int</span>　(*ptr)[<span class="number">2</span>]; </span><br><span class="line"><span class="comment">//第一个为&#123;12,14&#125; 第二个数组为&#123;16,0&#125;</span></span><br><span class="line"><span class="keyword">int</span>　torf[<span class="number">2</span>][<span class="number">2</span>]　=　&#123;<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>&#125;;</span><br><span class="line">ptr　=　torf;</span><br><span class="line"><span class="comment">//          **ptr: 12         **(ptr + 1):16</span></span><br><span class="line"></span><br><span class="line">b.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>　(*ptr)[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//第一个为&#123;12,0&#125; 第二个数组为&#123;14,16&#125;</span></span><br><span class="line"><span class="keyword">int</span>　fort[<span class="number">2</span>][<span class="number">2</span>]　=　&#123;　&#123;<span class="number">12</span>&#125;,　&#123;<span class="number">14</span>,<span class="number">16</span>&#125;　&#125;;</span><br><span class="line">ptr　=　fort;</span><br><span class="line"><span class="comment">//          **ptr: 12         **(ptr + 1): 14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"><span class="number">6.</span>假设有下面的声明：</span><br><span class="line"></span><br><span class="line">Suppose you have the following declaration: <span class="keyword">int</span> grid[<span class="number">30</span>][<span class="number">100</span>];.</span><br><span class="line">a. Express the address of grid[<span class="number">22</span>][<span class="number">56</span>] one way. </span><br><span class="line">b. Express the address of grid[<span class="number">22</span>][<span class="number">0</span>] two ways. </span><br><span class="line">c. Express the address of grid[<span class="number">0</span>][<span class="number">0</span>] three ways. </span><br><span class="line">    </span><br><span class="line">a. 用<span class="number">1</span>种写法表示gird[<span class="number">22</span>][<span class="number">56</span>]的地址</span><br><span class="line">	&amp;grid[<span class="number">22</span>][<span class="number">56</span>]</span><br><span class="line">b. 用<span class="number">2</span>种写法表示gird[<span class="number">22</span>][<span class="number">0</span>]的地址</span><br><span class="line">	&amp;gird[<span class="number">22</span>][<span class="number">0</span>], </span><br><span class="line">	gird[<span class="number">22</span>]		</span><br><span class="line">c. 用<span class="number">3</span>种写法表示gird[<span class="number">0</span>][<span class="number">0</span>]的地址</span><br><span class="line">	&amp;gird[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">	(<span class="keyword">int</span> *) gird			<span class="comment">//注意看下面字，强制转换为指向int类型的指针，</span></span><br><span class="line">								<span class="comment">//gird[0][0]也指向int类型</span></span><br><span class="line">     gird[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">注意这里fird是内含<span class="number">100</span>个元素的gird[<span class="number">0</span>]数组的地址，这两个地址的值，相同但是类型不同，使用强制类型转换将其转换成相同的类型</span><br><span class="line">        </span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Create an appropriate declaration <span class="keyword">for</span> each of the following variables: </span><br><span class="line">a. digits is an <span class="built_in">array</span> of <span class="number">10</span> ints .   					-- <span class="keyword">int</span> digits[<span class="number">10</span>];</span><br><span class="line">b. rates is an <span class="built_in">array</span> of six floats . 					-- <span class="keyword">float</span> rates[<span class="number">6</span>];</span><br><span class="line">c. mat is an <span class="built_in">array</span> of three arrays of five integers. 	  -- <span class="keyword">int</span> mat [<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">d. psa is an <span class="built_in">array</span> of <span class="number">20</span> pointers to <span class="keyword">char</span> . 			 -- <span class="keyword">char</span>* psa[<span class="number">20</span>]</span><br><span class="line">e. pstr is a pointer to an <span class="built_in">array</span> of <span class="number">20</span> chars . 			 -- <span class="keyword">char</span> (*pstr)[<span class="number">20</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"><span class="number">8.</span></span><br><span class="line">a.声明一个内含<span class="number">6</span>个<span class="keyword">int</span>类型值的数组，并初始化各元素为<span class="number">1</span>、<span class="number">2</span>、<span class="number">4</span>、<span class="number">8</span>、<span class="number">16</span>、<span class="number">32</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</span><br><span class="line">b.用数组表示法表示a声明的数组的第<span class="number">3</span>个元素（其值为<span class="number">4</span>）</span><br><span class="line">	<span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line">c.假设编译器支持C99/C11标准，声明一个内含<span class="number">100</span>个<span class="keyword">int</span>类型值的数组，并初始化最后一个元素为<span class="number">-1</span>，其他元素不考虑</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">100</span>] = &#123;[<span class="number">99</span>=<span class="number">-1</span>]&#125;; </span><br><span class="line">d.假设编译器支持C99/C11标准，声明一个内含<span class="number">100</span>个<span class="keyword">int</span>类型值的数组，并初始化下标为<span class="number">5</span>、<span class="number">10</span>、<span class="number">11</span>、<span class="number">12</span>、<span class="number">3</span>的元素为<span class="number">101</span>，其他元素不考虑    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">100</span>] = &#123;[<span class="number">5</span>=<span class="number">101</span>],[<span class="number">11</span>=<span class="number">101</span>],[<span class="number">12</span>=<span class="number">101</span>],[<span class="number">10</span> = <span class="number">101</span>],[<span class="number">3</span>=<span class="number">101</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"><span class="number">9.</span>内含<span class="number">10</span>个元素的数组下标范围是什么？  是 (<span class="number">0</span><span class="number">-9</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"><span class="number">10.</span>假设有下面的声明：</span><br><span class="line"><span class="keyword">float</span> rootbeer[<span class="number">10</span>], things[<span class="number">10</span>][<span class="number">5</span>], *pf, value = <span class="number">2.2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">判断以下各项是否有效：</span><br><span class="line">a.rootbeer[<span class="number">2</span>] = value;			<span class="comment">//有效</span></span><br><span class="line">b. <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;rootbeer ); 		 无效	应该指定一个下标元素的</span><br><span class="line">c. rootbeer = value; 				无效	应该指定一个下标元素的</span><br><span class="line">d. <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, rootbeer); 			 无效	应该指定一个下标元素的</span><br><span class="line">e.things[<span class="number">4</span>][<span class="number">4</span>] = rootbeer[<span class="number">3</span>];	<span class="comment">//有效</span></span><br><span class="line">f.things[<span class="number">5</span>] = rootbeer;			<span class="comment">//无效</span></span><br><span class="line">g.pf = value;				   <span class="comment">//无效 </span></span><br><span class="line">h.pf = rootbeer;			   <span class="comment">// 有效</span></span><br><span class="line"><span class="comment">//**********************************分割线*******************************//</span></span><br><span class="line"><span class="number">11.</span> 太简单 不写了</span><br><span class="line">    </span><br><span class="line"><span class="number">12.</span>下面声明了<span class="number">3</span>个数组：</span><br><span class="line"><span class="keyword">double</span> trots[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">short</span> clops[<span class="number">10</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">long</span> shots[<span class="number">5</span>][<span class="number">10</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  </span></span><br><span class="line"><span class="comment">  这题启示我们多维数组作为参数,数组中一定要有二维长度,因为C语言中将数组作为参数本质是把数组起始的一个元素或者自己将要操作数组的哪一部分段里的第一个元素的地址传过去,然后直接程序指向该数组直接对原数组做手脚.然后既然当作参数是作为数组指针,那么就是指向这个多维数组的第一个数组,那么就需要这个多维数组第一个数组的长度,也就是为啥多维数组的第二长度必须要有.因为这个多维数组中哥哥数组的寻址,都是基于这个第一个指向的数组来的.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 然后再定义一个变量是用来传入行数的,也就是代表这个多维数组有几个数组.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.分别以传统方式和以变长数组为参数的方式编写处理trots数组的<span class="keyword">void</span>函数原型和函数调用</span><br><span class="line">    </span><br><span class="line">traditional:   	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span> <span class="params">(<span class="keyword">double</span> *p,<span class="keyword">int</span> lenght)</span></span>;</span><br><span class="line">function1(trots,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">new</span> mode : </span><br><span class="line"><span class="keyword">void</span> function1 (<span class="keyword">int</span> row,<span class="keyword">double</span> arr[row]); </span><br><span class="line">function1 (<span class="number">20</span>,trots);</span><br><span class="line">    </span><br><span class="line">b.分别以传统方式和以变长数组为参数的方式编写处理clops数组的<span class="keyword">void</span>函数原型和函数调用</span><br><span class="line">    </span><br><span class="line">traditional:   	</span><br><span class="line"><span class="comment">//多维数组作为参数,必须要有第二维度的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span> <span class="params">(<span class="keyword">short</span> arr[][<span class="number">30</span>],<span class="keyword">int</span> row)</span></span>; </span><br><span class="line">function2(clops,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> mode : </span><br><span class="line"><span class="keyword">void</span> function2(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">short</span> arr[row][col]);</span><br><span class="line">function2(<span class="number">10</span>, <span class="number">30</span>, clops);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">c.分别以传统方式和以变长数组为参数的方式编写处理shots数组的<span class="keyword">void</span>函数原型和函数调用</span><br><span class="line">    </span><br><span class="line">traditional:   	</span><br><span class="line"><span class="comment">//多维数组作为参数,必须要有第二维度的长度,所以定义变量n.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">long</span> * [][<span class="number">10</span>][<span class="number">15</span>], <span class="keyword">int</span> row)</span></span>;</span><br><span class="line">function3(shots, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">new</span> mode : </span><br><span class="line"><span class="keyword">void</span> function3(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">long</span> arr[x][y][z]);</span><br><span class="line">function3(<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, shots)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************************************//    </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">13.</span>下面有两个函数原型：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;　<span class="comment">// n是数组元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar2[][<span class="number">3</span>], <span class="keyword">int</span> n)</span></span>;<span class="comment">// n是二维数组的行数</span></span><br><span class="line">a.编写一个函数调用，把一个内含<span class="number">8</span>、<span class="number">3</span>、<span class="number">9</span>和<span class="number">2</span>的复合字面量传递给show()函数。</span><br><span class="line">    show((<span class="keyword">double</span> []) &#123;<span class="number">8</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>&#125;);</span><br><span class="line">	show((<span class="keyword">double</span> [<span class="number">4</span>]) &#123;<span class="number">8</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>&#125;);</span><br><span class="line">b.编写一个函数调用，把一个<span class="number">2</span>行<span class="number">3</span>列的复合字面量（<span class="number">8</span>、<span class="number">3</span>、<span class="number">9</span>作为第<span class="number">1</span>行，<span class="number">5</span>、<span class="number">4</span>、<span class="number">1</span>作为第<span class="number">2</span>行）传递给show2()函数。</span><br><span class="line">    show2((<span class="keyword">double</span> [][<span class="number">3</span>])&#123;&#123;<span class="number">8</span>,<span class="number">3</span>,<span class="number">9</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    show2( (<span class="keyword">int</span> [<span class="number">2</span>][<span class="number">3</span>]) &#123; &#123;<span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125; &#125; );</span><br></pre></td></tr></table></figure>











<h1 id="第九章-字符串-和字符串函数"><a href="#第九章-字符串-和字符串函数" class="headerlink" title="第九章 字符串 和字符串函数"></a>第九章 字符串 和字符串函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.C语言中什么叫做字符串?</span><br><span class="line">	字符串是以空字符（\0）结尾的char类型数组</span><br><span class="line">2.字符串函数如何使用?</span><br><span class="line">3.字符串和字符数组有什么区别?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h2><p>函数：</p>
<p>gets()、fgets()、puts()、fputs()、 gets_s()、</p>
<p>strcat()、strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr() </p>
<p>如果不用修改字符串,一般就不要用指针指向字符字面量.</p>
<p>char　greeting[50]　=　“Hello,　and””　how　are”　“　you”<br>“　today!”;<br>与下面的代码等价：<br>char greeting[50] = “Hello, and how are you today!”;</p>
<h3 id="使用刷个双引号"><a href="#使用刷个双引号" class="headerlink" title="使用刷个双引号"></a>使用刷个双引号</h3><p>如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）：<br>printf(“&quot;Run, Spot, run!&quot; exclaimed Dick.\n”);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(%c\n,*<span class="string">&quot;space farers&quot;</span>); </span><br><span class="line"><span class="comment">// 表示打印出这个字符串地址上的值,也就是首字母s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> pets[<span class="number">12</span>] = <span class="string">&quot;nice cat.&quot;</span>  <span class="comment">// 多于位置自动初始化为 \0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> m2[] = <span class="string">&quot;If you can&#x27;t think of anything, fake it.&quot;</span>; <span class="comment">//这样自动计算大小</span></span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2021/06/20/75TIrdXcV3Hwkit.png" alt="img"></p>
<p><strong>字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：</strong></p>
<p><strong>char car[10] = “Tata”;</strong></p>
<p><strong>那么，以下表达式都为真：</strong></p>
<p><strong>car == &amp;car[0]、<em>car == ‘T’、</em>(car+1) == car[1] == ‘a’。</strong></p>
<p><strong>const char * pt1 = “Something is pointing at me.”;</strong><br><strong>该声明和下面的声明几乎相同：</strong><br><strong>const char ar1[] = “Something is pointing at me.”</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEN 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIM 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *mytalents[LIM] = &#123;</span><br><span class="line">          <span class="string">&quot;Adding numbers swiftly&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Multiplying accurately&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Stashing data&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Following instructions to the letter&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Understanding the C language&quot;</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> yourtalents[LIM][SLEN] = &#123;</span><br><span class="line">     <span class="string">&quot;Walking　in　a　straight　line&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Sleeping&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Watching　television&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Mailing　letters&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Reading　email&quot;</span></span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s　compare　talents.&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%-36s %-25s\n&quot;</span>,<span class="string">&quot;My　Talents&quot;</span>,<span class="string">&quot;Your　Talents&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;LIM;i++)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%-36s　 %-25s\n&quot;</span>,mytalents[i],yourtalents[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\nsizeof　mytalents:　%zd,　sizeof　yourtalents:　%zd\n&quot;</span>,<span class="keyword">sizeof</span>(mytalents),<span class="keyword">sizeof</span>(yourtalents));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mytalents数组是一个内含5个指针的数组，在我们的系统中共占用40字节。而yourtalents是一个内含5个数组的数组，每个数组内含40个char类型的值，共占用200字节。所以，虽然mytalents[0]和yourtalents[0]都分别表示一个字符串，但mytalents和yourtalents的类型并不相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/06/20/OKHQ3eM4ZVJkWwI.png" alt="img"></p>
<h2 id="字符串输出和输入"><a href="#字符串输出和输入" class="headerlink" title="字符串输出和输入"></a>字符串输出和输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *name;          //这个指针并没有初始化</span><br><span class="line">scanf(&quot;%s&quot;, name);   //这样使用未初始化的指针式错误的</span><br><span class="line"></span><br><span class="line">简单得方法就是声明时提前定义长度</span><br><span class="line">char name [10];</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line"></span><br><span class="line">// 由于数组名就相当于数组首元素地址 (即是指针)</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">     char array[100];</span><br><span class="line">     scanf(&quot;%s&quot;,array);  // 不用在name前加 &amp;</span><br><span class="line">     printf(&quot;%s\n&quot;,array);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符( \0 )使其成为一个 C 字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line">     gets(<span class="built_in">array</span>);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="built_in">array</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>gets()函数得缺点:<br>由于gets() 函数它不会去计算你输入得大小会不会超过数组得长度,所以容易超过数组下标,倘若超过的数据只是占用尚未使用的内存则没什么,但是如何占用了已经使用得内存,擦出了原本得数据,就会导致程序异常终止</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><p>由此 我们引进来了另一个替代它的函数: fgets()函数</p>
<p>fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。</p>
<p><strong>如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。</strong></p>
<p>fgets()函数的第3 个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。</p>
<p>fgets()函数返回指向 char的指针。如果一切进行顺利，该函数返回的地址与传入的第 1 个参数相同。<br>如果fgets()返回 NULL 就表示文件读到结尾或者读取错误.</p>
<h4 id="fgets-简单用法"><a href="#fgets-简单用法" class="headerlink" title="fgets()简单用法"></a>fgets()简单用法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;please enter string:&quot;</span>);</span><br><span class="line">     <span class="comment">// fgets(输出对象,输出长度,stdin);</span></span><br><span class="line">     fgets(<span class="built_in">array</span>,<span class="number">5</span>,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="built_in">array</span>);</span><br><span class="line">     <span class="comment">// fputs就两个参数 要输出的东西, </span></span><br><span class="line">     <span class="built_in">fputs</span>(<span class="built_in">array</span>,<span class="built_in">stdout</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="fgets-用循环-缓冲区"><a href="#fgets-用循环-缓冲区" class="headerlink" title="fgets()用循环,缓冲区"></a>fgets()用循环,缓冲区</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> words[STLEN];</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;enter String (empty line to quit);&quot;</span>);</span><br><span class="line">     <span class="comment">// fgets() 读到结尾和错误都会返回空值.</span></span><br><span class="line">     <span class="keyword">while</span> (fgets(words,STLEN,<span class="built_in">stdin</span>)!=<span class="literal">NULL</span> &amp;&amp; words[<span class="number">0</span>]!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">          <span class="built_in">fputs</span>(words,<span class="built_in">stdout</span>);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">I write the C language that I like the C language. --输入</span></span><br><span class="line"><span class="comment">I write the C language that I like the C language. --输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可见 哪怕fgets()函数每次都只读9个,但是它会循环接收这一句话,直到将这一句话接收完,然后fgets()也是按照缓冲区的顺序循环输出,完整打印这一句话.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>由于fgets()函数会保存回车符号,所以为了去除最后的回车符号,使用fgets()函数时要添加额外代码来将这个回车变成空格.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> words[STLEN];</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;enter String (empty line to quit);&quot;</span>);</span><br><span class="line">     <span class="comment">// fgets() 读到结尾和错误都会返回空值.</span></span><br><span class="line">     <span class="keyword">while</span> (fgets(words,STLEN,<span class="built_in">stdin</span>)!=<span class="literal">NULL</span> &amp;&amp; words[<span class="number">0</span>]!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (words[i]!=<span class="string">&#x27;\n&#x27;</span>&amp;&amp;words[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">               i++;</span><br><span class="line">          <span class="keyword">if</span>(words[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               words[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">          <span class="built_in">puts</span>(words);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><p><strong>该函数只能输出字符串字符</strong></p>
<p>与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符</p>
<p>puts(地址)  括号内只用传送地址就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">&quot;I am a symbolic string constant.&quot;</span>  <span class="comment">//字符串常量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLENGTH 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> words[MAXLENGTH] = <span class="string">&quot;i am a string in an array.&quot;</span>;  <span class="comment">// 类型数组</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* pt1 = <span class="string">&quot;Something is pointing at me.&quot;</span>;  <span class="comment">//指向char的指针</span></span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;here are some strings:&quot;</span>);</span><br><span class="line">     <span class="built_in">puts</span>(MSG);</span><br><span class="line">     <span class="built_in">puts</span>(words);</span><br><span class="line">     <span class="built_in">puts</span>(pt1);     <span class="comment">// 打印指针是直接打印指向的字符串</span></span><br><span class="line">     words[<span class="number">8</span>] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">     <span class="built_in">puts</span>(words);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>那么 既然只用传送地址,puts()函数就可以从地址处开始打印,那么puts()函数,它如何知道什么时候停止呢?</p>
<p>这就就字符串后面的 ‘\0’作用了,一般字符串都会在末尾添加一个’\0’,puts()遇见这个’\0’之后,就会停止.</p>
<p>你肯定又想问,如果没有’\0’呢?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>　side_a[]　=　<span class="string">&quot;Side　A&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>　dont[]　=　&#123;　<span class="string">&#x27;W&#x27;</span>,　<span class="string">&#x27;O&#x27;</span>,　<span class="string">&#x27;W&#x27;</span>,　<span class="string">&#x27;!&#x27;</span>　&#125;;</span><br><span class="line">    <span class="keyword">char</span>　side_b[]　=　<span class="string">&quot;Side　B&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(dont); <span class="comment">/* dont 不是一个字符串 */</span></span><br><span class="line">    <span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于dont缺少一个表示结束的空字符，所以它不是一个字符串，因此puts()不知道在何处停止。它会一直打印dont后面内存中的内容，直到发现一个空字符为止。为了让puts()能尽快读到空字符，我们把dont放在side_a和side_b之间。下面是该程序的一个运行示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">WOW!Side A</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们使用的编译器把side_a数组储存在dont数组之后，所以puts()一直输出至遇到side_a中的空字符。你所使用的编译器输出的内容可能不同，这取决于编译器如何在内存中储存数据。如果删除程序中的side_a和side_b数组会怎样？通常内存中有许多空字符，如果幸运的话，puts()很快就会发现一个。但是，这样做很不靠谱。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--------------------摘抄自书上内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="fput"><a href="#fput" class="headerlink" title="fput()"></a>fput()</h3><p>fputs()函数的第 2 个参数指明要写入数据的文件。如果要打印在显示器上，可以用定义在stdio.h中的stdout（标准输出）作为该参数。</p>
<p><strong>与puts()不同，fputs()不会在输出的末尾添加换行符。</strong></p>
<p><strong>puts()应与gets()配对使用，fputs()应与fgets()配对使用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGHT 30</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> <span class="built_in">array</span>[LENGHT];</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;please input string on last line: &quot;</span>);</span><br><span class="line">     fgets(<span class="built_in">array</span>,LENGHT,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;you input string are :\n&quot;</span>);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="built_in">array</span>,<span class="built_in">stdout</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><p>与puts()不同的是，printf()不会自动在每个字符串末尾加上一个换行符。因此，必须在参数中指明应该在哪里使用换行符。例如：</p>
<p>printf(“%s\n”, string);</p>
<p>和下面的语句效果相同：</p>
<p>puts(string);</p>
<p>如上所示，printf()的形式更复杂些，需要输入更多代码，而且计算机执行的时间也更长（但是你觉察不到）。然而，使用 printf()打印多个字符串更加简单。例如，下面的语句把 Well、用户名和一个#define定义的字符串打印在一行：</p>
<p>printf(“Well, %s, %s\n”, name, MSG);</p>
<h3 id="gets-s"><a href="#gets-s" class="headerlink" title="gets_s()"></a>gets_s()</h3><p>get() fgets() gets_s() 小总结</p>
<p>get() 接收字符数量大于字符串数组长度时,多余的数据可能会擦除已使用的数据内存,倒是出现问题.</p>
<p>fgets() 它会保留输入的 回车符 , 需要写额外代码来消除它保留的回车符</p>
<p><strong>gets_s(接收对象,接收长度 );</strong>  //  他不需要第三个参数.</p>
<h3 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h3><p><img src="https://i.loli.net/2021/06/20/gifDHsRIlexzKou.png" alt="image-20210208160539130"></p>
<p>scanf()函数返回一个整数值，该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF）。</p>
<h3 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a>strlen()函数</h3><p><strong>strlen()函数用于统计字符串的长度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用来缩短字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> * , <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* ---- strlen()---------------------------*/</span></span><br><span class="line">     <span class="keyword">char</span> mesg [] = <span class="string">&quot;Things should be as simple as possible,&quot;</span>            <span class="string">&quot;but not simpler.&quot;</span>;</span><br><span class="line">     <span class="built_in">puts</span>(mesg);</span><br><span class="line">     fit(mesg,<span class="number">38</span>);</span><br><span class="line">     <span class="built_in">puts</span>(mesg);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s　look　at　some　more　of　the　string.&quot;</span>);</span><br><span class="line">     <span class="comment">// 表达式mesg + 39是mesg[39]的地址该地址上储存的是空格字符。</span></span><br><span class="line">     <span class="comment">//所以put()显示该字符并继续输出直至遇到原来字符串中的空字符</span></span><br><span class="line">     <span class="built_in">puts</span>(mesg+<span class="number">39</span>); </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//strlen函数  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span>*<span class="built_in">string</span> , <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="built_in">string</span>)&gt;size)</span><br><span class="line">          <span class="built_in">string</span>[size] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>strlen()计算时 并不会计算字符串中末尾得 \0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;please enter string:&quot;</span>);</span><br><span class="line">     <span class="comment">// fgets(输出对象,输出长度,stdin);</span></span><br><span class="line">     fgets(<span class="built_in">array</span>,<span class="number">5</span>,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="built_in">array</span>);</span><br><span class="line">     <span class="comment">// fputs就两个参数 要输出的东西, </span></span><br><span class="line">     <span class="built_in">fputs</span>(<span class="built_in">array</span>,<span class="built_in">stdout</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     <span class="comment">// strlen计算字符串长度并不会把最后得 \0 纳入计算</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;strlen计算得长度为:%d&quot;</span>,<span class="built_in">strlen</span>(<span class="built_in">array</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat()函数"></a>strcat()函数</h3><p>strcat()用于拼接字符串,它将两个字符串作为参数.<br>它会把字符串二拼接在字符串一的身后,并返回这个拼接完成的字符串一.<br>stracat()函数类型是 char*(即是指向char的指针)<br>但是 strcat()函数无法检查第1个数组是否能容纳第2个字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用来缩短字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> * , <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* ---- strlen()---------------------------*/</span></span><br><span class="line">     <span class="keyword">char</span> mesg [] = <span class="string">&quot;Things should be as simple as possible,&quot;</span>            <span class="string">&quot;but not simpler.&quot;</span>;</span><br><span class="line">     <span class="built_in">puts</span>(mesg);</span><br><span class="line">     fit(mesg,<span class="number">38</span>);</span><br><span class="line">     <span class="built_in">puts</span>(mesg);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s　look　at　some　more　of　the　string.&quot;</span>);</span><br><span class="line">     <span class="comment">// 表达式mesg + 39是mesg[39]的地址该地址上储存的是空格字符。</span></span><br><span class="line">     <span class="comment">//所以put()显示该字符并继续输出直至遇到原来字符串中的空字符</span></span><br><span class="line">     <span class="built_in">puts</span>(mesg+<span class="number">39</span>); </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ---- strcat()---------------------------*/</span></span><br><span class="line">     <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">     <span class="keyword">char</span> addon [] = <span class="string">&quot;s smell like old shoes.&quot;</span>;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;What　is　your　favorite　flower?&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(s_gets(flower,SIZE)) <span class="comment">// 接收flower字符串</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">strcat</span>(flower,addon);</span><br><span class="line">          <span class="built_in">puts</span>(flower);</span><br><span class="line">          <span class="built_in">puts</span>(addon);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;End of file encountered!&quot;</span>);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//strlen函数  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span>*<span class="built_in">string</span> , <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="built_in">string</span>)&gt;size)</span><br><span class="line">          <span class="built_in">string</span>[size] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strcat函数</span></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> * ret_val;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="comment">// 检验接收的字符串是否到结尾</span></span><br><span class="line">     <span class="keyword">if</span>(ret_val)&#123;</span><br><span class="line">          <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] !=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">               i++;</span><br><span class="line">          <span class="comment">// 如果接收了回车符 得把它去掉</span></span><br><span class="line">          <span class="keyword">if</span>(st[i]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="strncat-函数"><a href="#strncat-函数" class="headerlink" title="strncat() 函数"></a>strncat() 函数</h3><p>就是因为strcat()函数拼接时不能计算第一个字符数组长度是否够长,所以我们得strncat()应运而生,strncat()第三个参数可以指定最大添加字符数.</p>
<p>例如，strncat(bugs, addon, 13)将把 addon字符串的内容附加给bugs，在加到第13个字符或遇到空字符时停止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE2 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUGSIZE 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用来缩短字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> * , <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* ---- strlen()---------------------------*/</span></span><br><span class="line">     <span class="keyword">char</span> mesg [] = <span class="string">&quot;Things should be as simple as possible,&quot;</span>            <span class="string">&quot;but not simpler.&quot;</span>;</span><br><span class="line">     <span class="built_in">puts</span>(mesg);</span><br><span class="line">     fit(mesg,<span class="number">38</span>);</span><br><span class="line">     <span class="built_in">puts</span>(mesg);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s　look　at　some　more　of　the　string.&quot;</span>);</span><br><span class="line">     <span class="comment">// 表达式mesg + 39是mesg[39]的地址该地址上储存的是空格字符。</span></span><br><span class="line">     <span class="comment">//所以put()显示该字符并继续输出直至遇到原来字符串中的空字符</span></span><br><span class="line">     <span class="built_in">puts</span>(mesg+<span class="number">39</span>); </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ---- strcat()---------------------------*/</span></span><br><span class="line">     <span class="comment">// char flower[SIZE];</span></span><br><span class="line">     <span class="comment">// char addon [] = &quot;s smell like old shoes.&quot;;</span></span><br><span class="line">     <span class="comment">// puts(&quot;What　is　your　favorite　flower?&quot;);</span></span><br><span class="line">     <span class="comment">// if(s_gets(flower,SIZE)) // 接收flower字符串</span></span><br><span class="line">     <span class="comment">// &#123;</span></span><br><span class="line">     <span class="comment">//      strcat(flower,addon);</span></span><br><span class="line">     <span class="comment">//      puts(flower);</span></span><br><span class="line">     <span class="comment">//      puts(addon);</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="comment">// else</span></span><br><span class="line">     <span class="comment">//      puts(&quot;End of file encountered!&quot;);</span></span><br><span class="line">     <span class="comment">// puts(&quot;bye&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ---- strncat()---------------------------*/</span></span><br><span class="line">     <span class="keyword">char</span> flower[SIZE2];</span><br><span class="line">     <span class="keyword">char</span> addon [] = <span class="string">&quot;s smell like old shoes.&quot;</span>;</span><br><span class="line">     <span class="keyword">char</span> bug[BUGSIZE];</span><br><span class="line">     <span class="keyword">int</span> available;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;What　is　your　favorite　flower?&quot;</span>);</span><br><span class="line">     s_gets(flower,SIZE);</span><br><span class="line">     <span class="keyword">if</span>((<span class="built_in">strlen</span>(addon)+<span class="built_in">strlen</span>(flower)+<span class="number">1</span>)&lt;=SIZE)</span><br><span class="line">          <span class="built_in">strcat</span>(flower,addon);</span><br><span class="line">     <span class="built_in">puts</span>(flower);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;What　is　your　favorite　bug?&quot;</span>);</span><br><span class="line">     s_gets(bug,BUGSIZE);</span><br><span class="line">     <span class="comment">// 计算bug最大能存储得字符</span></span><br><span class="line">     available = BUGSIZE - <span class="built_in">strlen</span>(bug) - <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">strncat</span>(bug,addon,available);</span><br><span class="line">     <span class="built_in">puts</span>(bug);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//strlen函数  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span>*<span class="built_in">string</span> , <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="built_in">string</span>)&gt;size)</span><br><span class="line">          <span class="built_in">string</span>[size] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strcat函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> * ret_val;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="comment">// 检验接收的字符串是否到结尾</span></span><br><span class="line">     <span class="keyword">if</span>(ret_val)&#123;</span><br><span class="line">          <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] !=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">               i++;</span><br><span class="line">          <span class="comment">// 如果接收了回车符 得把它去掉</span></span><br><span class="line">          <span class="keyword">if</span>(st[i]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="strcmp-函数"><a href="#strcmp-函数" class="headerlink" title="strcmp() 函数"></a>strcmp() 函数</h3><p>strcmp()函数就像比较数字一样。如果两个字符串参数相同，该函数就返回0，否则返回非零值<br>如果在字母表中第1个字符串位于第2个字符串前面，strcmp()中就返回负数；反之，strcmp()则返回正数</p>
<p>返回值：</p>
<ul>
<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>
<li>如果返回值 &gt; 0，则表示 str2 小于 str1。</li>
<li>如果返回值 = 0，则表示 str1 等于 str2。</li>
</ul>
<p>比如 abcd  和 abbb<br>    先 a和a比较 发现一样大<br>    再b 和b比较 发现一样大<br>    再发现c 和 b 比较 发现 c的ASCII码比b大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANSWER <span class="meta-string">&quot;GRANT&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* ,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">strcmp() 比较两个函数是否一样</span></span><br><span class="line"><span class="comment">strcmp() 函数就像比较数字一样。</span></span><br><span class="line"><span class="comment">如果两个字符串参数相同，该函数就返回0，否则返回非零值</span></span><br><span class="line"><span class="comment">而C语言中非 0 即为真</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> <span class="keyword">try</span>[SIZE];</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Who　is　buried　in　Grant&#x27;s　tomb?&quot;</span>);</span><br><span class="line">     s_gets(<span class="keyword">try</span>,SIZE);</span><br><span class="line">     <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="keyword">try</span>,ANSWER))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;No,　that&#x27;s　wrong.　Try　again.&quot;</span>);</span><br><span class="line">          s_gets(<span class="keyword">try</span>,SIZE);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;that&#x27;s right!&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *ret_val;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret_val)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">while</span> (st[i] == <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i]==<span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">               i++;</span><br><span class="line">          <span class="keyword">if</span>(st[i]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret_val;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="strncmp-函数"><a href="#strncmp-函数" class="headerlink" title="strncmp()函数"></a>strncmp()函数</h3><p>strcmp()函数比较字符串中的字符，直到发现不同的字符为止，这一过程可能会持续到字符串的末尾。而strncmp()函数在比较两个字符串时，可以比较到字符不同的地方，也可以只比较第3个参数指定的字符数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANSWER <span class="meta-string">&quot;GRANT&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* ,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">strcmp() 比较两个函数是否一样</span></span><br><span class="line"><span class="comment">strcmp()函数就像比较数字一样。</span></span><br><span class="line"><span class="comment">如果两个字符串参数相同，该函数就返回0，否则返回非零值</span></span><br><span class="line"><span class="comment">而C语言中非 0 即为真</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> <span class="keyword">try</span>[SIZE];</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Who　is　buried　in　Grant&#x27;s　tomb?&quot;</span>);</span><br><span class="line">     s_gets(<span class="keyword">try</span>,SIZE);</span><br><span class="line">     <span class="keyword">while</span> (<span class="built_in">strcmp</span>(<span class="keyword">try</span>,ANSWER))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;No,　that&#x27;s　wrong.　Try　again.&quot;</span>);</span><br><span class="line">          s_gets(<span class="keyword">try</span>,SIZE);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;that&#x27;s right!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 可以自定义strcmp()函数比较内容</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">array</span>[<span class="number">6</span>]= &#123;</span><br><span class="line">          <span class="string">&quot;astronomy&quot;</span>,<span class="string">&quot;astounding&quot;</span>,</span><br><span class="line">          <span class="string">&quot;astrophysics&quot;</span>,<span class="string">&quot;ostracize&quot;</span>,</span><br><span class="line">          <span class="string">&quot;asterism&quot;</span>,<span class="string">&quot;astrophobia&quot;</span></span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">strncmp</span>(<span class="built_in">array</span>[i],<span class="string">&quot;astro&quot;</span>,<span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;Found : %s \n&quot;</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">               count++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;一共找到了 %d astro 开头得字符串\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *ret_val;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret_val)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] !=<span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">               i++;</span><br><span class="line">          <span class="keyword">if</span>(st[i]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret_val;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="strcpy-函数"><a href="#strcpy-函数" class="headerlink" title="strcpy() 函数"></a>strcpy() 函数</h3><p>strcpy()函数 用来拷贝字符串   strcpy()函数相当于字符串赋值运算符。</p>
<p>strcpy(qwords[i],temp);  // 将 temp 拷贝至 qwords[i]中.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LIM 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> *st,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> qwords[LIM][SIZE];</span><br><span class="line">     <span class="keyword">char</span> temp[SIZE];</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Enter　%d　words　beginning　with　q:\n&quot;</span>,LIM);</span><br><span class="line">     <span class="keyword">while</span> (i&lt;LIM &amp;&amp; s_gets(temp,SIZE))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp[<span class="number">0</span>] != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;%s doesn&#x27;t begin with q!\n&quot;</span>,temp);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">strcpy</span>(qwords[i],temp);</span><br><span class="line">               i++;</span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Here are the words accepted:&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; LIM; i++)</span><br><span class="line">          <span class="built_in">puts</span>(qwords[i]);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>*st , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *ret_val;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="keyword">if</span> (ret_val)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span>,st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">               i++;</span><br><span class="line">          <span class="keyword">if</span> (st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>strcpy()函数接收两个指针作为参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char * str = NULL;   // 使用指针前一定要初始化</span><br><span class="line">strcpy (str, &quot;The C of Tranquility&quot;);</span><br></pre></td></tr></table></figure>

<p>strcpy()接受两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；而指向源字符串副本的第1个指针应指向一个数据对象（如，数组），且该对象有足够的空间储存源字符串的副本。记住，声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间</p>
<h4 id="strcpy-函数两个属性"><a href="#strcpy-函数两个属性" class="headerlink" title="strcpy()函数两个属性"></a>strcpy()函数两个属性</h4><h5 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h5><p>strcpy()的返回类型是 char *，该函数返回的是第 1个参数的值，即一个字符的地址</p>
<h5 id="不必是数组的开始"><a href="#不必是数组的开始" class="headerlink" title="不必是数组的开始"></a>不必是数组的开始</h5><p>第 1 个参数不必指向数组的开始。这个属性可用于拷贝数组的一部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORDS <span class="meta-string">&quot;beast&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>*orig = WORDS;</span><br><span class="line">     <span class="keyword">char</span> copy [SIZE] = <span class="string">&quot;Be the best that you can be.&quot;</span>;</span><br><span class="line">     <span class="keyword">char</span>*ps;</span><br><span class="line">     <span class="built_in">puts</span>(orig);</span><br><span class="line">     <span class="built_in">puts</span>(copy);</span><br><span class="line">     ps = <span class="built_in">strcpy</span>(copy + <span class="number">7</span>,orig);</span><br><span class="line">     <span class="built_in">puts</span>(copy);</span><br><span class="line">     <span class="built_in">puts</span>(ps);     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果不理解  ps = strcpy(copy + 7,orig);  请看图:</p>
<p><img src="https://i.loli.net/2021/06/20/bkJIaTCGZnqOUcF.png" alt="image-20210211150848389"></p>
<h3 id="strncpy-函数"><a href="#strncpy-函数" class="headerlink" title="strncpy()函数"></a>strncpy()函数</h3><p>然而 strcpy()和 strcat()都有同样的问题，它们都不能检查目标空间是否能容纳源字符串的副本。</p>
<p>拷贝字符串用 strncpy()更安全，该函数的第 3 个参数指明可拷贝的最大字符数。</p>
<p>strncpy(target, source, n)把source中的n个字符或空字符之前的字符（先满足哪个条件就拷贝到何处）拷贝至target中。<br>如果拷贝到第n个字符时还未拷贝完整个源字符串，就不会拷贝空字符。所以，拷贝的副本中不一定有空字符。<br>如果想拥有,可以把该程序把 n 设置为比目标数组大小少1（TARGSIZE-1），然后把数组最后一个元素设置为空字符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(qwords[i],　temp,　TARGSIZE<span class="number">-1</span>);</span><br><span class="line">qwords[i][TARGSIZE　-　<span class="number">1</span>]　=　<span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h5 id="sprintf-函数"><a href="#sprintf-函数" class="headerlink" title="sprintf()函数"></a>sprintf()函数</h5><p>sprintf()函数声明在stdio.h中，而不是在string.h中。<br>它是把数据写入字符串，而不是打印在显示器上。因此，该函数可以把多个元素组合成一个字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * , <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> first [MAX];</span><br><span class="line">     <span class="keyword">char</span> last [MAX];</span><br><span class="line">     <span class="keyword">char</span> formal[<span class="number">2</span>*MAX + <span class="number">10</span>];</span><br><span class="line">     <span class="keyword">double</span> prize;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;enter you first name:&quot;</span>);</span><br><span class="line">     s_gets(first,MAX);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;enter you last name:&quot;</span>);</span><br><span class="line">     s_gets(last,MAX);</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;enter you prize money:&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;prize);</span><br><span class="line">     <span class="built_in">sprintf</span>(formal,<span class="string">&quot;%s,%-19s:$%6.2f\n&quot;</span>,last,first,prize);</span><br><span class="line">     <span class="built_in">puts</span>(formal);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> *st,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *ret_val;</span><br><span class="line">     <span class="keyword">int</span> i ;</span><br><span class="line">     ret_val = fgets(st,n,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="keyword">if</span> (ret_val)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] !=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">               i++;</span><br><span class="line">          <span class="keyword">if</span> (st[i]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 用于过滤掉多余得字符得</span></span><br><span class="line">               <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结字符串函数"><a href="#总结字符串函数" class="headerlink" title="总结字符串函数"></a>总结字符串函数</h3><p>char *strcpy(char * restrict s1, const char * restrict s2);</p>
<p>该函数把s2指向的字符串（包括空字符）拷贝至s1指向的位置，返回值是s1。</p>
<p>char *strncpy(char * restrict s1, const char * restrict s2, size_t n);</p>
<p>该函数把s2指向的字符串拷贝至s1指向的位置，拷贝的字符数不超过n，其返回值是s1。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于n个，目标字符串就以拷贝的空字符结尾；如果源字符串有n个或超过n个字符，就不拷贝空字符。</p>
<p>char *strcat(char * restrict s1, const char * restrict s2);</p>
<p>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。该函数返回s1。</p>
<p>char *strncat(char * restrict s1, const char * restrict s2, size_t n);</p>
<p>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。不会拷贝s2字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回s1。</p>
<p>int strcmp(const char * s1, const char * s2);</p>
<p>如果s1字符串在机器排序序列中位于s2字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回0；如果s1字符串在机器排序序列中位于s2字符串的前面，则返回一个负数。</p>
<p>总结 :<br>如果两个字符串相等，则返回0(假 – false)；<br>如果两个字符不相等则返回非零数(真 – true).</p>
<p>int strncmp(const char * s1, const char * s2, size_t n);</p>
<p>该函数的作用和strcmp()类似，不同的是，该函数在比较n个字符后或遇到第1个空字符时停止比较。</p>
<p>char *strchr(const char * s, int c);</p>
<p>如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。</p>
<p>char *strpbrk(const char * s1, const char * s2);如果 s1 字符中包含 s2 字符串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。<br><strong>总结:判断两个函数中的元素是否有交集,有则返回s1首位置指针,没有交集则返回空字符串.</strong></p>
<p>char *strrchr(const char * s, int c);该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。</p>
<p>char *strstr(const char * s1, const char * s2);</p>
<p>该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。<br><strong>总结:如果s1包含s2,那么在s1中找s2出现得首位置,找到就返回这个首位置,没有找到则返回空指针.</strong></p>
<p>size_t strlen(const char * s);</p>
<p><strong>该函数返回s字符串中的字符数，不包括末尾的空字符。</strong></p>
<p>请注意，那些使用const关键字的函数原型表明，函数不会更改字符串。例如，下面的函数原型：</p>
<p>char *strcpy(char * restrict s1, const char * restrict s2);</p>
<p>表明不能更改s2指向的字符串，至少不能在strcpy()函数中更改。但是可以更改s1指向的字符串。这样做很合理，因为s1是目标字符串，要改变，而s2是源字符串，不能更改。</p>
<p>size_t类型是sizeof运算符返回的类型。C规定sizeof运算符返回一个整数类型，但是并未指定是哪种整数类型，所以size_t在一个系统中可以是unsigned int，而在另一个系统中可以是 unsigned long</p>
<h2 id="空指针-and-空字符"><a href="#空指针-and-空字符" class="headerlink" title="空指针 and 空字符"></a>空指针 and 空字符</h2><p>空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因是：它们都可以用数值0来表示。但是，从概念上看，两者是不同类型的0。另外，<strong>空字符是一个字符，占1字节；而空指针是一个地址，通常占4字节</strong>。</p>
<h1 id="第十章-储存类别-链接-内存管理"><a href="#第十章-储存类别-链接-内存管理" class="headerlink" title="第十章 储存类别 链接 内存管理"></a>第十章 储存类别 链接 内存管理</h1><p>关键字：</p>
<p>auto、extern、static、register</p>
<p>const、volatile、restricted、_Thread_local、_Atomic</p>
<p>函数：rand()、srand()、time()、malloc()、calloc()、free()</p>
<p>如何确定变量的作用域（可见的范围）和生命期（它存在多长时间）</p>
<p>设计更复杂的程序</p>
<p>储存类别:</p>
<p><strong>auto</strong> 局部用来修饰局部变量,一般函数中变量都是默认是auto.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;   <span class="comment">// 相当于就是 auto int a = 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>register  寄存器类别</p>
<p>就是它不同款 ,  别人都是放在内存中,他为了提高速度,将数据放在寄存器中.</p>
<p><strong>entern储存类</strong></p>
<p>比如A文件中有一个 entern int a = 100;</p>
<p>我可以再B文件中调用 这个变量,就是有entern修饰了的变量可以再其他文件中调用.</p>
<p><strong>static储存类</strong></p>
<p>只属于程序本身,不可以被外部调用.<br>并且改变值后,再次使用会接着是上次改变后的值.</p>
<p><strong>左值</strong></p>
<p><strong>一般而言，那些指定对象的表达式被称为左值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;  </span><br><span class="line"><span class="comment">// entity是一个标识符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> ranks + <span class="number">2</span>*entity;  <span class="comment">// 这不是一个左值 </span></span><br><span class="line"><span class="number">2.</span> *(ranks + <span class="number">2</span>*entity); <span class="comment">//但这个是一个左值</span></span><br><span class="line">因为 <span class="number">2</span> 相比 <span class="number">1</span> 来说 它明确的指向了一个对象 就是ranks[<span class="number">7</span>].  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * pc = <span class="string">&quot;Behold a string literal!&quot;</span>;</span><br><span class="line">	<span class="comment">// 同样 *pc也是一个左值,但是是一个不可以修改的左值.</span></span><br><span class="line"></span><br><span class="line">可以用存储期（storage duration）描述对象，</span><br><span class="line">    所谓存储期是指对象在内存中保留了多长时间。标识符用于访问对象，</span><br><span class="line">    可以用作用域（scope）和链接（linkage）描述标识符</span><br></pre></td></tr></table></figure>





<h3 id="关于左值的基本了解"><a href="#关于左值的基本了解" class="headerlink" title="关于左值的基本了解"></a>关于左值的基本了解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// 一般而言 那些指定对象的表达式被称为左值.</span></span><br><span class="line">     <span class="comment">// entity 既是标识符也是左值</span></span><br><span class="line">     <span class="comment">// pointer 既是表达式也是左值</span></span><br><span class="line">     <span class="keyword">int</span> entity = <span class="number">3</span>;</span><br><span class="line">     <span class="keyword">int</span> *pointer = &amp;entity;</span><br><span class="line">     <span class="keyword">int</span> ranks[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     按照这个思路，ranks + 2 * entity既不是标识符（不是名称）</span></span><br><span class="line"><span class="comment">     也不是左值（它不指定内存位置上的内容）</span></span><br><span class="line"><span class="comment">     但是表达式*(ranks + 2 * entity)是一个左值</span></span><br><span class="line"><span class="comment">     因为它的确指定了特定内存位置的值，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> a = *(ranks + <span class="number">2</span> * entity);</span><br><span class="line">     <span class="comment">// 都指向了ranks[6] 这个元素</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;*(ranks + 2 * entity) : %d ,\t a: %d&quot;</span>,*(ranks + <span class="number">2</span> * entity),a);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的左值。</span></span><br><span class="line">     <span class="comment">// const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串。</span></span><br><span class="line">     <span class="comment">//由于*pc指定了储存&#x27;B&#x27;字符的数据对象，所以*pc是一个左值 但不是一个可修改的左值。</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *pointer_char = <span class="string">&quot;Behold a string literal!&quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域</strong></p>
<p><strong>块作用域</strong> :<br>就是花括号里面的作用范围.<br>一个语句花括号是一个块作用域,一个函数花括号也是一个块作用域.</p>
<p><strong>函数原型作用域</strong> :<br>这个很好理解 , 指的就是函数 () 中的形参,当使用时开辟空间,用完了就销毁.<br><strong>函数原型作用域的范围是从形参定义处到原型声明结束。</strong></p>
<p><strong>函数作用域</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数作用域（function scope）仅用于<span class="keyword">goto</span>语句的标签。这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。</span><br></pre></td></tr></table></figure>

<p>我来跟你解释解释,首先说明了<strong>仅用于goto语句</strong>,也就是对于其他语句来说没有所谓的<strong>函数作用域</strong>.<br>假如一个函数中有好几个内层块(比如: 循环,循环套循环.if…else…之类)<br>那么这个goto如果作用知识再块中的话,就很麻烦,不好用.<br>这也就是为啥说<strong>那个函数里面有 goto 语句 , 作用域就是这个函数,可以再这个函数里面跳.</strong></p>
<p><strong>文件作用域</strong>(全局变量) :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10;   // 定义再函数外  文件作用域</span><br><span class="line">int main(void)&#123;</span><br><span class="line">&#125;</span><br><span class="line">全局变量:就是本文件其他函数都可以使用</span><br></pre></td></tr></table></figure>







<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>具有文件作用域的变量可以是外部链接或内部链接。</strong></p>
<h3 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h3><p>int giants = 5;　　　　　　　// 文件作用域，外部链接<br>在其他文件中可以调用这个变量.</p>
<h3 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h3><p>static int dodgers = 3;　　 // 文件作用域，内部链接<br>只能够再本身文件中调用这个变量</p>
<h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p><strong>具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量</strong><br><strong>这意味着这些变量属于定义它们的块、函数或原型私有。</strong></p>
<h2 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h2><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C对象有4种存储期：</p>
<h3 id="静态存储期"><a href="#静态存储期" class="headerlink" title="静态存储期"></a>静态存储期</h3><p>如果对象具有静态存储期，那么它在程序的执行期间一直存在。<strong>所有的文件作用域变量具有静态存储期</strong></p>
<p>关键字 static表明了其链接属性，而非存储期。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;  <span class="comment">/* 全局变量 - static 是默认的 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span></span><br><span class="line"><span class="comment"> * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span></span><br><span class="line"><span class="comment"> */</span>                </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> thingy=<span class="number">5</span>;</span><br><span class="line">  thingy++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; thingy 为 %d ， count 为 %d\n&quot;</span>, thingy, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程存储期"><a href="#线程存储期" class="headerlink" title="线程存储期"></a>线程存储期</h3><p>线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在</p>
<p>_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。</p>
<h3 id="自动存储期"><a href="#自动存储期" class="headerlink" title="自动存储期"></a>自动存储期</h3><p>块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存</p>
<p>变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。</p>
<h3 id="动态分配存储期"><a href="#动态分配存储期" class="headerlink" title="动态分配存储期"></a>动态分配存储期</h3><h3 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h3><p><img src="https://i.loli.net/2021/06/20/5nyPhOZezHRau2o.jpg" alt="1"></p>
<h2 id="函数添加static"><a href="#函数添加static" class="headerlink" title="函数添加static"></a>函数添加static</h2><p>函数前面也是可以添加static , 用来表明是不是本文件自身私有的.</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>以下函数需要头文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure>





<p><strong>malloc()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维数组声明</span></span><br><span class="line"><span class="keyword">double</span> * ptd;</span><br><span class="line">ptd = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组声明</span></span><br><span class="line"><span class="keyword">double</span> (*point)[<span class="number">6</span>];</span><br><span class="line">point = ( <span class="keyword">double</span> * [col] ) <span class="built_in">malloc</span> (row * col * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">EXIT_SUCCESS（或者，相当于 <span class="number">0</span>）表示普通的程序结束， EXIT_FAILURE 表示程序异常中止。</span><br></pre></td></tr></table></figure>



<p><strong>calloc()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> * newmem;</span><br><span class="line">newmem = (<span class="keyword">long</span> *)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span> (<span class="keyword">long</span>));  <span class="comment">//和malloc不同 , 中间是 逗号 </span></span><br></pre></td></tr></table></figure>



<p><strong>free()</strong></p>
<p>malloc()  和  calloc()  都可以用free()函数释放内存.<br>free()释放的指针可以和  malloc()的指针不同,但是指针上的地址需要一样.</p>
<h2 id="ANSI-C类型限定符"><a href="#ANSI-C类型限定符" class="headerlink" title="ANSI C类型限定符"></a>ANSI C类型限定符</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>如果对于指针来说,cont再  * 号的左右,作用是不同的,见如下代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>,b = <span class="number">20</span>,c = <span class="number">30</span>,d = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址可以改变,但是通过这个地址去改变值就不行.</span></span><br><span class="line"><span class="comment">// 断绝通过地址去修改变量的值这条路</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *point_1 = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d,%d\n&quot;</span>,point_1,*point_1,a);</span><br><span class="line">    point_1 = &amp;b;  <span class="comment">//修改指针指向地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d,%d\n&quot;</span>,point_1,*point_1,b);</span><br><span class="line">    <span class="comment">// 比如修改b的值</span></span><br><span class="line">    <span class="comment">// *point_1 = 400;  直接报错</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********************************************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向的地址不能改变,但是可以在指针上修改值.</span></span><br><span class="line"><span class="comment">// 指针和标识符地址绑定在一起,同生共死,只能修改c的值,不能让地址再指向其他值.</span></span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> point_2 = &amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d,%d\n&quot;</span>,point_2,*point_2,c);</span><br><span class="line">    *point_2 = <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d,%d\n&quot;</span>,point_2,*point_2,c);</span><br><span class="line">    <span class="comment">// 当我们想把指针指向d时 直接报错</span></span><br><span class="line">    <span class="comment">//  point_2 = &amp;d;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>const 常用的用法就是在函数参数中声明指针.<br>这样就不会让函数更改主函数里面数据的可能.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> s2)</span></span>;</span><br></pre></td></tr></table></figure>







<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>的语法和<span class="keyword">const</span>一样：</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> loc1;<span class="comment">/* loc1 是一个易变的位置 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> * ploc;　 <span class="comment">/* ploc 是一个指向易变的位置的指针 */</span></span><br></pre></td></tr></table></figure>





<p>以上代码把loc1声明为volatile变量，把ploc声明为指向volatile变量的指针。</p>
<p>读者可能认为volatile是个可有可无的概念，为何ANSI委员把volatile关键字放入标准？原因是它涉及编译器的优化。例如，假设有下面的代码：</p>
<p>vall =x;<br>/* 一些不使用 x 的代码*/<br>val2　=　x</p>
<p>智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时间。这个过程被称为高速缓存（caching）。通常，高速缓存是个不错的优化方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这样优化了。如果没有volatile关键字，编译器就不知道这种事情是否会发生。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情况。现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。</p>
<p>可以同时用const和volatile限定一个值。例如，通常用const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只能在声明中同时使用这两个限定符，它们的顺序不重要，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile const int loc;</span><br><span class="line">const volatile int * ploc;</span><br></pre></td></tr></table></figure>



<p>总结:   <strong>就是加这个修饰符,可以让数据在访问的过程中更快速.</strong></p>
<h3 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h3><p><strong>restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。</strong></p>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="_Atomic"></a><strong>_Atomic</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的（不是必须实现的）管理方法。值得注意的是，要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。例如，下面的代码：</span><br><span class="line"></span><br><span class="line">int hogs;// 普通声明</span><br><span class="line"></span><br><span class="line">hogs = 12;　　// 普通赋值</span><br><span class="line"></span><br><span class="line">可以替换成：</span><br><span class="line"></span><br><span class="line">_Atomic int hogs;　　　　　　// hogs 是一个原子类型的变量</span><br><span class="line"></span><br><span class="line">atomic_store(&amp;hogs, 12);　 // stdatomic.h中的宏</span><br><span class="line"></span><br><span class="line">这里，在hogs中储存12是一个原子过程，其他线程不能访问hogs。</span><br><span class="line"></span><br><span class="line">编写这种代码的前提是，编译器要支持这一新特性。</span><br></pre></td></tr></table></figure>



<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>struct 可以创建像枚举一样但是可以半酣不同数据类型的结构体.<br>struct 语句语法如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tag 是结构体标签。</span></span><br><span class="line"><span class="comment">member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</span></span><br><span class="line"><span class="comment">variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="结构体的创建"><a href="#结构体的创建" class="headerlink" title="结构体的创建"></a>结构体的创建</h3><p>结构体是定义在方法外面的</p>
<p>就像Java中面向对象的思想,一个对象的相关数据我们封装到一起.</p>
<p>以下代码包含结构体的创建和结构体的初始化.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 体态全齐结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book_one</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="comment">// 不能像枚举一样直接在这个里面赋值</span></span><br><span class="line">    <span class="keyword">char</span> bookname[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">int</span> book_id;</span><br><span class="line">&#125;book1 = &#123; <span class="string">&quot;aaaaaaaaaaaaa&quot;</span>,<span class="string">&quot;zxcvb&quot;</span>,<span class="number">0.0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少结构变量结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book_two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="comment">// 不能像枚举一样直接在这个里面赋值</span></span><br><span class="line">    <span class="keyword">char</span> bookname[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用Book_two的标签 创建多个结构变量;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book_two</span> <span class="title">b1</span>[20],<span class="title">b2</span>[10],*<span class="title">b3</span>,<span class="title">b4</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少结构名的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="comment">// 不能像枚举一样直接在这个里面赋值</span></span><br><span class="line">    <span class="keyword">char</span> bookname[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">int</span> book_id;</span><br><span class="line">&#125;book3 = &#123;<span class="string">&quot;&lt;阿强爱情故事&gt;&quot;</span>,<span class="string">&quot;刘英俊&quot;</span>,<span class="number">10.5</span>,<span class="number">133</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;书名:%-20s \t 作者:%-10s \t 价格:%-5.2f \t 书编号:%-5d\n&quot;</span>,book1.bookname,book1.author,book1.price,book1.book_id);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     -- struct中的字符串是不能够用 = 号来复制的</span></span><br><span class="line"><span class="comment">     book1.bookname = &quot;&lt;C语言修从入门到放弃炼手册大全&gt;&quot;;</span></span><br><span class="line"><span class="comment">     book1.author = &quot;YAOGUI&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 用拷贝函数 strcpy() 给结构体里面的字符串赋值</span></span><br><span class="line">     <span class="built_in">strcpy</span>(book1.bookname,<span class="string">&quot;&lt;C语言修从入门到放弃炼手册大全&gt;&quot;</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(book1.author,<span class="string">&quot;YAOGUI&quot;</span>);</span><br><span class="line">     <span class="comment">//但是像int float 等数据类型的值可以像一下这样再赋值.</span></span><br><span class="line">     book1.price = <span class="number">50.5</span>;</span><br><span class="line">     book1.book_id = <span class="number">111</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;书名:%-20s \t 作者:%-10s \t 价格:%-5.2f \t 书编号:%-5d\n&quot;</span>,book1.bookname,book1.author,book1.price,book1.book_id);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 声明 book2 book2_2 是Book2类型 */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Book_two</span> <span class="title">book2</span>, <span class="title">book2_2</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(book2.bookname,<span class="string">&quot;C++入门到放弃终极路线大全&quot;</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(book2.author,<span class="string">&quot;yaogui&quot;</span>);</span><br><span class="line">     book2.price = <span class="number">20</span>;</span><br><span class="line">     book2.book_id = <span class="number">112</span>;</span><br><span class="line">     <span class="comment">/* book2_2 he book2 是两个独立的对象 只是用的Book_two这样的房子,各自所代表的房间里的数据是不一样的 */</span></span><br><span class="line">     <span class="built_in">strcpy</span>(book2_2.bookname,<span class="string">&quot;C++入门到放弃终极路线大全2&quot;</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(book2_2.author,<span class="string">&quot;yaogui2&quot;</span>);</span><br><span class="line">     book2_2.price = <span class="number">220</span>;</span><br><span class="line">     book2_2.book_id = <span class="number">113</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;书名:%-20s \t 作者:%-10s \t 价格:%-5.2f \t 书编号:%-5d\n&quot;</span>,book2.bookname,book2.author,book2.price,book2.book_id);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;书名:%-20s \t 作者:%-10s \t 价格:%-5.2f \t 书编号:%-5d\n&quot;</span>,book2_2.bookname,book2_2.author,book2_2.price,book2_2.book_id);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// book3 没有结构体名一样可以直接使用</span></span><br><span class="line">     <span class="built_in">puts</span>(book3.bookname);</span><br><span class="line">     <span class="keyword">int</span> frequency = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (frequency&lt;<span class="built_in">strlen</span>(book3.author))&#123;</span><br><span class="line">          <span class="built_in">putchar</span>(book3.author[frequency]);</span><br><span class="line">          frequency++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;价格 :%.2f  编号: %d&quot;</span>,book3.price,book3.book_id);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体杂糅"><a href="#结构体杂糅" class="headerlink" title="结构体杂糅"></a>结构体杂糅</h3><p>当然本身是没有这个结构体杂糅这个概念的,只是我为了方便记忆,自己草率想到的一个词.</p>
<p>为啥叫它结构体杂糅呢?</p>
<p>因为结构体不仅仅向上面那样简单存储数据,还可存储指针,包含自身的指针, 包含其他结构体的指针.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 两个结构体 那个先做了不完整声明就靠后再详细声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>  <span class="comment">//不完整声明 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">pointer_B</span>;</span>  <span class="comment">// 包含指向B结构体的指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">pointer_A_own</span>;</span>  <span class="comment">// 包含指向本身这个结构体的指针</span></span><br><span class="line">     <span class="keyword">int</span> a;</span><br><span class="line">&#125;AAA;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">pointer_A</span>;</span>  <span class="comment">// 指向A结构体的指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">pointer_B_own</span>;</span>  <span class="comment">// 包含指向本身这个结构体的指针</span></span><br><span class="line">     <span class="keyword">int</span> b;</span><br><span class="line">&#125;BBB;</span><br></pre></td></tr></table></figure>



<h3 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShuChu</span><span class="params">(struct Book_one book)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 两个结构体 那个先做了不完整声明就靠后再详细声明</span></span><br><span class="line"><span class="comment">// 体态全齐结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book_one</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="comment">// 不能像枚举一样直接在这个里面赋值</span></span><br><span class="line">    <span class="keyword">char</span> bookname[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShuChu</span><span class="params">(struct Book_one book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Book_one</span> <span class="title">book1</span>,<span class="title">book2</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">strcpy</span>(book1.bookname,<span class="string">&quot;&lt;C语言修从入门到放弃炼手册大全&gt;&quot;</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(book1.author,<span class="string">&quot;YAOGUI&quot;</span>);</span><br><span class="line">     <span class="comment">//但是像int float 等数据类型的值可以像一下这样再赋值.</span></span><br><span class="line">     book1.price = <span class="number">50.5</span>;</span><br><span class="line">     book1.book_id = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">strcpy</span>(book2.bookname,<span class="string">&quot;C++入门到放弃终极路线大全&quot;</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(book2.author,<span class="string">&quot;yaogui&quot;</span>);</span><br><span class="line">     book2.price = <span class="number">20</span>;</span><br><span class="line">     book2.book_id = <span class="number">112</span>;</span><br><span class="line"></span><br><span class="line">     ShuChu(book1);</span><br><span class="line">     ShuChu(book2);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShuChu</span><span class="params">(struct Book_one book)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;书名:%-20s \t 作者:%-10s \t 价格:%-5.2f \t 书编号:%-5d\n&quot;</span>,book.bookname,book.author,book.price,book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用指针操作结构体"><a href="#使用指针操作结构体" class="headerlink" title="使用指针操作结构体"></a>使用指针操作结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">pointer_1</span> =</span> &amp;Book1;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">pointer_2</span> =</span> &amp;Book2;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">100000</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">1000001</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book1 的地址来输出 Book1 信息 */</span></span><br><span class="line">   printBook( pointer_1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book2 的地址来输出 Book2 信息 */</span></span><br><span class="line">   printBook( pointer_2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book title : %s\n&quot;</span>, book-&gt;title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book author : %s\n&quot;</span>, book-&gt;author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book subject : %s\n&quot;</span>, book-&gt;subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>用struct 定义一个位域</p>
<p>切记 赋值时不要让值大于自己所规定的位域大小;<br>比如 a:2 表示 00 两个位,用2就只能够表示 00(0) 01(1) 10(2) 11(3);<br>这时给a赋值5(101)要用到三位,而a只限制了两位,这时就会出错.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">WeiYu</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">     <span class="keyword">unsigned</span>  a:<span class="number">4</span>;	<span class="comment">// 表示a占有四个位 0000</span></span><br><span class="line">     <span class="keyword">unsigned</span>   :<span class="number">4</span>;  <span class="comment">/* 空域  不可使用 */</span></span><br><span class="line">     <span class="keyword">unsigned</span>  c:<span class="number">3</span>;</span><br><span class="line">     <span class="keyword">unsigned</span>  d:<span class="number">1</span>;</span><br><span class="line">     &#125;bit,*pointer;</span><br><span class="line"></span><br><span class="line">     bit.a = <span class="number">12</span>;</span><br><span class="line">     bit.c = <span class="number">4</span>;</span><br><span class="line">     bit.d = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a:%d c:%d  d:%d\n&quot;</span>,bit.a,bit.c,bit.d);</span><br><span class="line">     pointer = &amp;bit;</span><br><span class="line">     pointer-&gt;a = <span class="number">9</span>;</span><br><span class="line">     pointer-&gt;c = <span class="number">3</span>;</span><br><span class="line">     pointer-&gt;d = <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a:%d c:%d  d:%d\n&quot;</span>,pointer-&gt;a,pointer-&gt;c,pointer-&gt;d);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<p>同一时间只能用到一个成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">int</span> height;</span><br><span class="line">     <span class="keyword">float</span> weight;</span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">&#125;information,information_two;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     information.age = <span class="number">20</span>;</span><br><span class="line">     information.height = <span class="number">166</span>;</span><br><span class="line">     information.weight = <span class="number">150.5</span>;</span><br><span class="line">     <span class="built_in">strcpy</span>(information.name,<span class="string">&quot;哈利波特·伏地魔&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;名字:%-10s,\n年龄:%3d,\n身高:%3d,\n体重:%5.2f\n&quot;</span>,information.name,information.age,information.height,information.weight);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;*********************************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">strcpy</span>(information_two.name,<span class="string">&quot;哈利波特·伏地魔&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%20s\n&quot;</span>,information_two.name);</span><br><span class="line"></span><br><span class="line">     information_two.age = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>,information_two.age);</span><br><span class="line"></span><br><span class="line">     information_two.height = <span class="number">166</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>,information_two.height);</span><br><span class="line"></span><br><span class="line">     information_two.weight = <span class="number">150.5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%5.2f\n&quot;</span>,information_two.weight);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">    名字:哈利波特·伏地魔,</span></span><br><span class="line"><span class="comment">    年龄:-71237959,</span></span><br><span class="line"><span class="comment">    身高:-71237959,</span></span><br><span class="line"><span class="comment">    体重:-2004174772176159100000000000000000000.00</span></span><br><span class="line"><span class="comment">    *********************************************************************</span></span><br><span class="line"><span class="comment">        哈利波特·伏地魔</span></span><br><span class="line"><span class="comment">       20</span></span><br><span class="line"><span class="comment">      166</span></span><br><span class="line"><span class="comment">    150.50</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">上面一组数据损坏,问下面一组数据可以输出,就是因为同一时间只能够使用一个成员.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h1 id="终章-C语言文件流"><a href="#终章-C语言文件流" class="headerlink" title="终章 /  C语言文件流 /"></a>终章 /  C语言文件流 /</h1><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode )</span></span>;</span><br></pre></td></tr></table></figure>



<p>函数：</p>
<p>fopen()、getc()、putc()、exit()、fclose()</p>
<p>fprintf()、fscanf()、fgets()、fputs()</p>
<p>rewind()、fseek()、ftell()、fflush()</p>
<p>fgetpos()、fsetpos()、feof()、ferror()</p>
<p>ungetc()、setvbuf()、fread()、fwrite()</p>
<p><strong>C把文件看作是一系列连续的字节，每个字节都能被单独读取</strong><br><strong>C提供两种文件模式：文本模式和二进制模式。</strong></p>
<p>要区分<strong>文本内容和二进制内容</strong></p>
<p><strong>文本文件格式和二进制文件格式</strong></p>
<p><strong>以及文件的文本模式和二进制模式。</strong></p>
<p>windows 系统中每行的结尾是&lt;回车&gt;&lt;换行&gt; 即是一个 \r \n<br>Mac系统中每行结尾就是一个&lt;回车&gt;  \r<br>Uinx系统中结尾每行只有一个&lt;换行&gt;  \n</p>
<p>C程序会自动打开3个文件，它们被称为标准输入（standard input）、标准输出（standard output）和标准错误输出（standard error output）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个指针字符串数组</span></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">array</span>[];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array[] 数组的所有元素都是指针,指针都指向一个字符串.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个指向字符型指针数组的指针</span></span><br><span class="line"><span class="keyword">char</span> **<span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>



<p><strong>exit()函数关闭所有打开的文件并结束程序。</strong><br>通常的惯例是：<strong>正常结束的程序传递0，异常结束的程序传递非零值</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit(0);  //退出程序（结束程序）</span><br></pre></td></tr></table></figure>





<p><img src="https://i.loli.net/2021/06/20/JHx2c73uliGqdtT.png" alt="image-20210219203020723"></p>
<p>新的C11新增了带x字母的写模式，与以前的写模式相比具有更多特性。第一，如果以传统的一种写模式打开一个现有文件，fopen()会把该文件的长度截为 0，这样就丢失了该文件的内容。<strong>但是使用带 x字母的写模式，即使 fopen()操作失败，原文件的内容也不会被删除。</strong>第二，如果环境允许，x模式的独占特性使得其他程序或线程无法访问正在被打开的文件。</p>
<p>警告</p>
<p>如果使用任何一种”w”模式（不带x字母）打开一个现有文件，该文件的内容会被删除，以便程序在一个空白文件中开始操作。然而，如果使用带x字母的任何一种模式，将无法打开一个现有文件。</p>
<h2 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h2><p>fopen( *filepointer  , “指定打开文件的模式”)<br>*filepointer 指的是 包含该字符串文件名的字符串地址<br>可以用该文件名的指针,是不是也可以直接打名字 和 路径之类的?</p>
<p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回</p>
<p>所以我们一般要创建一个结构体的变量去接收这个由fopen()函数的返回值.</p>
<p>如果文件打开失败,fopen()函数会返回一个空指针,我们可以还用这个来判断文件是否成功被打开</p>
<table>
<thead>
<tr>
<th>控制读写权限的字符串（必须指明）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>打开方式</td>
<td>说明</td>
</tr>
<tr>
<td>“r”</td>
<td>以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td>“w”</td>
<td>以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td>
</tr>
<tr>
<td>“a”</td>
<td>以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td>
</tr>
<tr>
<td>“r+”</td>
<td>以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td>“w+”</td>
<td>以“写入/更新”方式打开文件，相当于<code>w</code>和<code>r+</code>叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td>
</tr>
<tr>
<td>“a+”</td>
<td>以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td>
</tr>
<tr>
<td>控制读写方式的字符串（可以不写）</td>
<td></td>
</tr>
<tr>
<td>打开方式</td>
<td>说明</td>
</tr>
<tr>
<td>“t”</td>
<td>文本文件。如果不写，默认为<code>&quot;t&quot;</code>。</td>
</tr>
<tr>
<td>“b”</td>
<td>二进制文件。</td>
</tr>
</tbody></table>
<p>读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。例如：</p>
<ul>
<li>将读写方式放在读写权限的末尾：”rb”、”wt”、”ab”、”r+b”、”w+t”、”a+t”</li>
<li>将读写方式放在读写权限的中间：”rb+”、”wt+”、”ab+”</li>
</ul>
<p>整体来说，文件打开方式由 r、w、a、t、b、+ 六个字符拼成，各字符的含义是：</p>
<ul>
<li>r(read)：读</li>
<li>w(write)：写</li>
<li>a(append)：追加</li>
<li>t(text)：文本文件</li>
<li>b(binary)：二进制文件</li>
<li>+：读和写</li>
</ul>
<h2 id="getc-and-putc"><a href="#getc-and-putc" class="headerlink" title="getc()   and  putc()"></a>getc()   and  putc()</h2><p>getc() 在文件中获取字符<br>putc() 在文件中放入字符</p>
<p>从标准输入中获取一个字符”：<br>ch = getchar();<br>然而，下面这条语句的意思是“从fp指定的文件中获取一个字符”：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = getc(fp);</span><br><span class="line"><span class="comment">// 把字符ch放入FILE指针fpout指定的文件中</span></span><br><span class="line">putc(ch, fpout);</span><br></pre></td></tr></table></figure>





<h2 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose()函数"></a>fclose()函数</h2><p>close(fp)函数关闭fp指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。<strong>如果成功关闭，fclose()函数返回0，否则返回EOF：</strong></p>
<p>if (fclose(fp) != 0)</p>
<p>printf(“Error in closing file %s\n”, argv[1]);</p>
<p>如果磁盘已满、移动硬盘被移除或出现I/O错误，都会导致调用fclose()函数失败。</p>
<h2 id="指向标准文件的指针"><a href="#指向标准文件的指针" class="headerlink" title="指向标准文件的指针"></a>指向标准文件的指针</h2><p>stdio.h头文件把3个文件指针与3个标准文件相关联，C程序会自动打开这3个标准文件。</p>
<ul>
<li>分别是:<ul>
<li>stdin   (标准输入)    对应键盘</li>
<li>stdout (标准输出)    对应显示器</li>
<li>stderr  (标准错误)    对应显示器</li>
</ul>
</li>
</ul>
<h2 id="ferror-函数"><a href="#ferror-函数" class="headerlink" title="ferror()函数"></a>ferror()函数</h2><p>用来判断文件是否出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ferror ( FILE *fp ); //出错返回非0 否则返回0</span><br></pre></td></tr></table></figure>





<h2 id="简单文件读写程序"><a href="#简单文件读写程序" class="headerlink" title="简单文件读写程序"></a>简单文件读写程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>  <span class="comment">// 提供exit()函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">// 提供 strcpy()  strcat()两个函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 40</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     FILE *into,*out;  <span class="comment">//声明两个指向FILE的指针</span></span><br><span class="line">     <span class="keyword">int</span> ch; <span class="comment">//用来判断是否到结尾</span></span><br><span class="line">     <span class="keyword">char</span> name[LEN];  <span class="comment">//储存输出文件名</span></span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检查命令行参数</span></span><br><span class="line">     <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage : %s filename\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">          <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置输入</span></span><br><span class="line">     <span class="keyword">if</span>((into = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;I couldn&#x27;t open the file \&quot;%s\&quot;  \n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">          <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置输出</span></span><br><span class="line">     <span class="built_in">strncpy</span>(name,argv[<span class="number">1</span>],LEN<span class="number">-5</span>);</span><br><span class="line">     name[LEN<span class="number">-5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="built_in">strcat</span>(name,<span class="string">&quot;.red&quot;</span>);  <span class="comment">//在文件名后面添加 .red</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((out = fopen(name,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 以写的模式打开文件</span></span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Can&#x27;t create output file.\n&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//拷贝数据</span></span><br><span class="line">     <span class="keyword">while</span>((ch=getc(into))!=EOF)</span><br><span class="line">          <span class="keyword">if</span>(count++%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">               putc(ch,out);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 收尾工作</span></span><br><span class="line">     <span class="keyword">if</span>(fclose(into)!=<span class="number">0</span> || fclose(out) != <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error in closing files \n&quot;</span>);</span><br><span class="line">          </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YaoGui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/06/20/C-language-one/">http://example.com/2021/06/20/C-language-one/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">YaoGui's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/06/20/hexo+github/"><span>/HEXO+GITHUB/搭建博客</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/arcaneyaogui/photosBed@master/20210618/wallhaven-0w6j7q.67qv3jyz5zs0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By YaoGui</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>